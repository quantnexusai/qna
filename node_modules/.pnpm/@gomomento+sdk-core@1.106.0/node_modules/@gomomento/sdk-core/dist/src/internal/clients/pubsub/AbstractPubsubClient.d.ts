import { TopicPublish, TopicItem, MomentoLogger, TopicSubscribe, SubscribeCallOptions, MomentoLoggerFactory, TopicDiscontinuity, TopicHeartbeat } from '../../../index';
import { SubscriptionState } from '../../subscription-state';
import { IPubsubClient } from './IPubsubClient';
import { ICacheServiceErrorMapper } from '../../../errors/ICacheServiceErrorMapper';
/**
 * Encapsulates parameters for the `sendSubscribe` method.
 */
export interface SendSubscribeOptions {
    cacheName: string;
    topicName: string;
    onItem: (item: TopicItem) => void;
    onError: (error: TopicSubscribe.Error, subscription: TopicSubscribe.Subscription) => void;
    onDiscontinuity: (discontinuity: TopicDiscontinuity) => void;
    onHeartbeat: (heartbeat: TopicHeartbeat) => void;
    subscriptionState: SubscriptionState;
    subscription: TopicSubscribe.Subscription;
    /**
     * Whether the stream was restarted due to an error. If so, we skip the end stream handler
     * logic as the error handler will have restarted the stream.
     */
    restartedDueToError: boolean;
    /**
     * If the first message is an error, we return an error immediately and do not subscribe.
     */
    firstMessage: boolean;
}
/**
 * Encapsulates parameters for the subscribe callback prepare methods.
 */
export interface PrepareSubscribeCallbackOptions extends SendSubscribeOptions {
    /**
     * The promise resolve function.
     */
    resolve: (value: TopicSubscribe.Response | PromiseLike<TopicSubscribe.Subscription>) => void;
}
export declare abstract class AbstractPubsubClient<TGrpcError> implements IPubsubClient {
    private readonly loggerFactory;
    private readonly logger;
    private readonly cacheServiceErrorMapper;
    protected constructor(loggerFactory: MomentoLoggerFactory, logger: MomentoLogger, cacheServiceErrorMapper: ICacheServiceErrorMapper<TGrpcError>);
    protected getLogger(): MomentoLogger;
    protected getCacheServiceErrorMapper(): ICacheServiceErrorMapper<TGrpcError>;
    publish(cacheName: string, topicName: string, value: string | Uint8Array): Promise<TopicPublish.Response>;
    protected abstract sendPublish(cacheName: string, topicName: string, value: string | Uint8Array): Promise<TopicPublish.Response>;
    subscribe(cacheName: string, topicName: string, options: SubscribeCallOptions): Promise<TopicSubscribe.Response>;
    protected abstract sendSubscribe(options: SendSubscribeOptions): Promise<TopicSubscribe.Response>;
    protected prepareEndCallback(options: PrepareSubscribeCallbackOptions): () => void;
    protected handleSubscribeError(options: PrepareSubscribeCallbackOptions, momentoError: TopicSubscribe.Error, shouldReconnectSubscription: boolean): void;
}
