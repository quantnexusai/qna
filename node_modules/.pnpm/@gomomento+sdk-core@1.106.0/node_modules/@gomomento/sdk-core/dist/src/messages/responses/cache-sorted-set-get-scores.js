"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Error = exports.Miss = exports.Hit = void 0;
const errors_1 = require("../../errors");
const response_base_1 = require("./response-base");
const grpc_response_types_1 = require("./grpc-response-types");
const enums_1 = require("./enums");
const index_1 = require("../../index");
/**
 * Indicates that the requested data was successfully retrieved from the cache.  Provides
 * `value*` accessors to retrieve the data in the appropriate format.
 */
class Hit extends response_base_1.ResponseBase {
    constructor(scores, values) {
        super();
        this._responses = [];
        this.type = enums_1.CacheSortedSetGetScoresResponse.Hit;
        scores.forEach((score, index) => {
            if (score.result === grpc_response_types_1._ECacheResult.Hit) {
                this._responses.push(new index_1.CacheSortedSetGetScore.Hit(score.score, values[index]));
            }
            else if (score.result === grpc_response_types_1._ECacheResult.Miss) {
                this._responses.push(new index_1.CacheSortedSetGetScore.Miss(values[index]));
            }
            else {
                this._responses.push(new index_1.CacheSortedSetGetScore.Error(new errors_1.UnknownError(score.result.toString()), values[index]));
            }
        });
    }
    responses() {
        return this._responses;
    }
    /**
     * Returns the data as a Map whose keys are utf-8 strings, decoded from the underlying byte arrays and values are numbers.
     * @returns {Map<string, number>}
     */
    valueMapString() {
        return this._responses.reduce((acc, response) => {
            if (response instanceof index_1.CacheSortedSetGetScore.Hit) {
                acc.set(response.valueString(), response.score());
            }
            return acc;
        }, new Map());
    }
    /**
     * Returns the data as a Map whose keys and values are utf-8 strings, decoded from the underlying byte arrays.
     * This is a convenience alias for {valueMapStringString}.
     * @returns {Map<string, number>}
     */
    valueMap() {
        return this.valueMapString();
    }
    /**
     * Returns the data as a Record whose keys and values are utf-8 strings, decoded from the underlying byte arrays.
     * This can be used in most places where an Object is desired.
     * @returns {Record<string, number>}
     */
    valueRecordString() {
        return this._responses.reduce((acc, response) => {
            if (response instanceof index_1.CacheSortedSetGetScore.Hit) {
                acc[response.valueString()] = response.score();
            }
            return acc;
        }, {});
    }
    /**
     * Returns the data as a Record whose keys and values are utf-8 strings, decoded from the underlying byte arrays.
     * This can be used in most places where an Object is desired.  This is a convenience alias for
     * {valueRecordStringString}.
     * @returns {Record<string, number>}
     */
    valueRecord() {
        return this.valueRecordString();
    }
    /**
     * Returns the data as a Record whose keys and values are utf-8 strings, decoded from the underlying byte arrays.
     * This can be used in most places where an Object is desired.  This is a convenience alias for
     * {valueRecordStringString}.
     * @returns {Record<string, number>}
     */
    value() {
        return this.valueRecord();
    }
    toString() {
        let stringRepresentation = '';
        this.valueMapString().forEach((value, key) => {
            const keyValue = `${key}: ${value}, `;
            stringRepresentation = stringRepresentation + keyValue;
        });
        return `${super.toString()}: valueMapString: ${stringRepresentation.slice(0, -2)}`;
    }
}
exports.Hit = Hit;
/**
 * Indicates that the requested data was not available in the cache.
 */
class Miss extends response_base_1.BaseResponseMiss {
    constructor() {
        super(...arguments);
        this.type = enums_1.CacheSortedSetGetScoresResponse.Miss;
    }
    value() {
        return undefined;
    }
}
exports.Miss = Miss;
/**
 * Indicates that an error occurred during the dictionary get fields request.
 *
 * This response object includes the following fields that you can use to determine
 * how you would like to handle the error:
 *
 * - `errorCode()` - a unique Momento error code indicating the type of error that occurred.
 * - `message()` - a human-readable description of the error
 * - `innerException()` - the original error that caused the failure; can be re-thrown.
 */
class Error extends response_base_1.BaseResponseError {
    constructor(_innerException) {
        super(_innerException);
        this.type = enums_1.CacheSortedSetGetScoresResponse.Error;
    }
    value() {
        return undefined;
    }
}
exports.Error = Error;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FjaGUtc29ydGVkLXNldC1nZXQtc2NvcmVzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL21lc3NhZ2VzL3Jlc3BvbnNlcy9jYWNoZS1zb3J0ZWQtc2V0LWdldC1zY29yZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEseUNBQW9EO0FBQ3BELG1EQUl5QjtBQUN6QiwrREFHK0I7QUFDL0IsbUNBQXdEO0FBQ3hELHVDQUFtRDtBQU9uRDs7O0dBR0c7QUFDSCxNQUFhLEdBQUksU0FBUSw0QkFBWTtJQUtuQyxZQUFZLE1BQXdDLEVBQUUsTUFBb0I7UUFDeEUsS0FBSyxFQUFFLENBQUM7UUFMTyxlQUFVLEdBQXNDLEVBQUUsQ0FBQztRQUMzRCxTQUFJLEdBQ1gsdUNBQStCLENBQUMsR0FBRyxDQUFDO1FBSXBDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEVBQUU7WUFDOUIsSUFBSSxLQUFLLENBQUMsTUFBTSxLQUFLLG1DQUFhLENBQUMsR0FBRyxFQUFFO2dCQUN0QyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FDbEIsSUFBSSw4QkFBc0IsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FDM0QsQ0FBQzthQUNIO2lCQUFNLElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxtQ0FBYSxDQUFDLElBQUksRUFBRTtnQkFDOUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSw4QkFBc0IsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUN0RTtpQkFBTTtnQkFDTCxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FDbEIsSUFBSSw4QkFBc0IsQ0FBQyxLQUFLLENBQzlCLElBQUkscUJBQVksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQ3pDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FDZCxDQUNGLENBQUM7YUFDSDtRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVNLFNBQVM7UUFDZCxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUM7SUFDekIsQ0FBQztJQUVEOzs7T0FHRztJQUNJLGNBQWM7UUFDbkIsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxRQUFRLEVBQUUsRUFBRTtZQUM5QyxJQUFJLFFBQVEsWUFBWSw4QkFBc0IsQ0FBQyxHQUFHLEVBQUU7Z0JBQ2xELEdBQUcsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxFQUFFLFFBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO2FBQ25EO1lBQ0QsT0FBTyxHQUFHLENBQUM7UUFDYixDQUFDLEVBQUUsSUFBSSxHQUFHLEVBQWtCLENBQUMsQ0FBQztJQUNoQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLFFBQVE7UUFDYixPQUFPLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztJQUMvQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLGlCQUFpQjtRQUN0QixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUF5QixDQUFDLEdBQUcsRUFBRSxRQUFRLEVBQUUsRUFBRTtZQUN0RSxJQUFJLFFBQVEsWUFBWSw4QkFBc0IsQ0FBQyxHQUFHLEVBQUU7Z0JBQ2xELEdBQUcsQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsS0FBSyxFQUFFLENBQUM7YUFDaEQ7WUFDRCxPQUFPLEdBQUcsQ0FBQztRQUNiLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUNULENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLFdBQVc7UUFDaEIsT0FBTyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztJQUNsQyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxLQUFLO1FBQ1YsT0FBTyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDNUIsQ0FBQztJQUVlLFFBQVE7UUFDdEIsSUFBSSxvQkFBb0IsR0FBRyxFQUFFLENBQUM7UUFDOUIsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsRUFBRTtZQUMzQyxNQUFNLFFBQVEsR0FBRyxHQUFHLEdBQUcsS0FBSyxLQUFLLElBQUksQ0FBQztZQUN0QyxvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRyxRQUFRLENBQUM7UUFDekQsQ0FBQyxDQUFDLENBQUM7UUFDSCxPQUFPLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRSxxQkFBcUIsb0JBQW9CLENBQUMsS0FBSyxDQUN2RSxDQUFDLEVBQ0QsQ0FBQyxDQUFDLENBQ0gsRUFBRSxDQUFDO0lBQ04sQ0FBQztDQUNGO0FBaEdELGtCQWdHQztBQUVEOztHQUVHO0FBQ0gsTUFBYSxJQUFLLFNBQVEsZ0NBQWdCO0lBQTFDOztRQUNXLFNBQUksR0FDWCx1Q0FBK0IsQ0FBQyxJQUFJLENBQUM7SUFLekMsQ0FBQztJQUhRLEtBQUs7UUFDVixPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0NBQ0Y7QUFQRCxvQkFPQztBQUVEOzs7Ozs7Ozs7R0FTRztBQUNILE1BQWEsS0FBTSxTQUFRLGlDQUFpQjtJQUkxQyxZQUFZLGVBQXlCO1FBQ25DLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUpoQixTQUFJLEdBQ1gsdUNBQStCLENBQUMsS0FBSyxDQUFDO0lBSXhDLENBQUM7SUFFTSxLQUFLO1FBQ1YsT0FBTyxTQUFTLENBQUM7SUFDbkIsQ0FBQztDQUNGO0FBWEQsc0JBV0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1Nka0Vycm9yLCBVbmtub3duRXJyb3J9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5pbXBvcnQge1xuICBSZXNwb25zZUJhc2UsXG4gIEJhc2VSZXNwb25zZU1pc3MsXG4gIEJhc2VSZXNwb25zZUVycm9yLFxufSBmcm9tICcuL3Jlc3BvbnNlLWJhc2UnO1xuaW1wb3J0IHtcbiAgX0VDYWNoZVJlc3VsdCxcbiAgX1NvcnRlZFNldEdldFNjb3JlUmVzcG9uc2VQYXJ0LFxufSBmcm9tICcuL2dycGMtcmVzcG9uc2UtdHlwZXMnO1xuaW1wb3J0IHtDYWNoZVNvcnRlZFNldEdldFNjb3Jlc1Jlc3BvbnNlfSBmcm9tICcuL2VudW1zJztcbmltcG9ydCB7Q2FjaGVTb3J0ZWRTZXRHZXRTY29yZX0gZnJvbSAnLi4vLi4vaW5kZXgnO1xuXG5pbnRlcmZhY2UgSVJlc3BvbnNlIHtcbiAgdmFsdWUoKTogUmVjb3JkPHN0cmluZywgbnVtYmVyPiB8IHVuZGVmaW5lZDtcbiAgcmVhZG9ubHkgdHlwZTogQ2FjaGVTb3J0ZWRTZXRHZXRTY29yZXNSZXNwb25zZTtcbn1cblxuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCB0aGUgcmVxdWVzdGVkIGRhdGEgd2FzIHN1Y2Nlc3NmdWxseSByZXRyaWV2ZWQgZnJvbSB0aGUgY2FjaGUuICBQcm92aWRlc1xuICogYHZhbHVlKmAgYWNjZXNzb3JzIHRvIHJldHJpZXZlIHRoZSBkYXRhIGluIHRoZSBhcHByb3ByaWF0ZSBmb3JtYXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBIaXQgZXh0ZW5kcyBSZXNwb25zZUJhc2UgaW1wbGVtZW50cyBJUmVzcG9uc2Uge1xuICBwcml2YXRlIHJlYWRvbmx5IF9yZXNwb25zZXM6IENhY2hlU29ydGVkU2V0R2V0U2NvcmUuUmVzcG9uc2VbXSA9IFtdO1xuICByZWFkb25seSB0eXBlOiBDYWNoZVNvcnRlZFNldEdldFNjb3Jlc1Jlc3BvbnNlLkhpdCA9XG4gICAgQ2FjaGVTb3J0ZWRTZXRHZXRTY29yZXNSZXNwb25zZS5IaXQ7XG5cbiAgY29uc3RydWN0b3Ioc2NvcmVzOiBfU29ydGVkU2V0R2V0U2NvcmVSZXNwb25zZVBhcnRbXSwgdmFsdWVzOiBVaW50OEFycmF5W10pIHtcbiAgICBzdXBlcigpO1xuICAgIHNjb3Jlcy5mb3JFYWNoKChzY29yZSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChzY29yZS5yZXN1bHQgPT09IF9FQ2FjaGVSZXN1bHQuSGl0KSB7XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlcy5wdXNoKFxuICAgICAgICAgIG5ldyBDYWNoZVNvcnRlZFNldEdldFNjb3JlLkhpdChzY29yZS5zY29yZSwgdmFsdWVzW2luZGV4XSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoc2NvcmUucmVzdWx0ID09PSBfRUNhY2hlUmVzdWx0Lk1pc3MpIHtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VzLnB1c2gobmV3IENhY2hlU29ydGVkU2V0R2V0U2NvcmUuTWlzcyh2YWx1ZXNbaW5kZXhdKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZXNwb25zZXMucHVzaChcbiAgICAgICAgICBuZXcgQ2FjaGVTb3J0ZWRTZXRHZXRTY29yZS5FcnJvcihcbiAgICAgICAgICAgIG5ldyBVbmtub3duRXJyb3Ioc2NvcmUucmVzdWx0LnRvU3RyaW5nKCkpLFxuICAgICAgICAgICAgdmFsdWVzW2luZGV4XVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyByZXNwb25zZXMoKTogQ2FjaGVTb3J0ZWRTZXRHZXRTY29yZS5SZXNwb25zZVtdIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzcG9uc2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRhdGEgYXMgYSBNYXAgd2hvc2Uga2V5cyBhcmUgdXRmLTggc3RyaW5ncywgZGVjb2RlZCBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ5dGUgYXJyYXlzIGFuZCB2YWx1ZXMgYXJlIG51bWJlcnMuXG4gICAqIEByZXR1cm5zIHtNYXA8c3RyaW5nLCBudW1iZXI+fVxuICAgKi9cbiAgcHVibGljIHZhbHVlTWFwU3RyaW5nKCk6IE1hcDxzdHJpbmcsIG51bWJlcj4ge1xuICAgIHJldHVybiB0aGlzLl9yZXNwb25zZXMucmVkdWNlKChhY2MsIHJlc3BvbnNlKSA9PiB7XG4gICAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBDYWNoZVNvcnRlZFNldEdldFNjb3JlLkhpdCkge1xuICAgICAgICBhY2Muc2V0KHJlc3BvbnNlLnZhbHVlU3RyaW5nKCksIHJlc3BvbnNlLnNjb3JlKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkYXRhIGFzIGEgTWFwIHdob3NlIGtleXMgYW5kIHZhbHVlcyBhcmUgdXRmLTggc3RyaW5ncywgZGVjb2RlZCBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ5dGUgYXJyYXlzLlxuICAgKiBUaGlzIGlzIGEgY29udmVuaWVuY2UgYWxpYXMgZm9yIHt2YWx1ZU1hcFN0cmluZ1N0cmluZ30uXG4gICAqIEByZXR1cm5zIHtNYXA8c3RyaW5nLCBudW1iZXI+fVxuICAgKi9cbiAgcHVibGljIHZhbHVlTWFwKCk6IE1hcDxzdHJpbmcsIG51bWJlcj4ge1xuICAgIHJldHVybiB0aGlzLnZhbHVlTWFwU3RyaW5nKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGF0YSBhcyBhIFJlY29yZCB3aG9zZSBrZXlzIGFuZCB2YWx1ZXMgYXJlIHV0Zi04IHN0cmluZ3MsIGRlY29kZWQgZnJvbSB0aGUgdW5kZXJseWluZyBieXRlIGFycmF5cy5cbiAgICogVGhpcyBjYW4gYmUgdXNlZCBpbiBtb3N0IHBsYWNlcyB3aGVyZSBhbiBPYmplY3QgaXMgZGVzaXJlZC5cbiAgICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIG51bWJlcj59XG4gICAqL1xuICBwdWJsaWMgdmFsdWVSZWNvcmRTdHJpbmcoKTogUmVjb3JkPHN0cmluZywgbnVtYmVyPiB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc3BvbnNlcy5yZWR1Y2U8UmVjb3JkPHN0cmluZywgbnVtYmVyPj4oKGFjYywgcmVzcG9uc2UpID0+IHtcbiAgICAgIGlmIChyZXNwb25zZSBpbnN0YW5jZW9mIENhY2hlU29ydGVkU2V0R2V0U2NvcmUuSGl0KSB7XG4gICAgICAgIGFjY1tyZXNwb25zZS52YWx1ZVN0cmluZygpXSA9IHJlc3BvbnNlLnNjb3JlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkYXRhIGFzIGEgUmVjb3JkIHdob3NlIGtleXMgYW5kIHZhbHVlcyBhcmUgdXRmLTggc3RyaW5ncywgZGVjb2RlZCBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ5dGUgYXJyYXlzLlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIGluIG1vc3QgcGxhY2VzIHdoZXJlIGFuIE9iamVjdCBpcyBkZXNpcmVkLiAgVGhpcyBpcyBhIGNvbnZlbmllbmNlIGFsaWFzIGZvclxuICAgKiB7dmFsdWVSZWNvcmRTdHJpbmdTdHJpbmd9LlxuICAgKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgbnVtYmVyPn1cbiAgICovXG4gIHB1YmxpYyB2YWx1ZVJlY29yZCgpOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+IHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVJlY29yZFN0cmluZygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRhdGEgYXMgYSBSZWNvcmQgd2hvc2Uga2V5cyBhbmQgdmFsdWVzIGFyZSB1dGYtOCBzdHJpbmdzLCBkZWNvZGVkIGZyb20gdGhlIHVuZGVybHlpbmcgYnl0ZSBhcnJheXMuXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgaW4gbW9zdCBwbGFjZXMgd2hlcmUgYW4gT2JqZWN0IGlzIGRlc2lyZWQuICBUaGlzIGlzIGEgY29udmVuaWVuY2UgYWxpYXMgZm9yXG4gICAqIHt2YWx1ZVJlY29yZFN0cmluZ1N0cmluZ30uXG4gICAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBudW1iZXI+fVxuICAgKi9cbiAgcHVibGljIHZhbHVlKCk6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4ge1xuICAgIHJldHVybiB0aGlzLnZhbHVlUmVjb3JkKCk7XG4gIH1cblxuICBwdWJsaWMgb3ZlcnJpZGUgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICBsZXQgc3RyaW5nUmVwcmVzZW50YXRpb24gPSAnJztcbiAgICB0aGlzLnZhbHVlTWFwU3RyaW5nKCkuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgY29uc3Qga2V5VmFsdWUgPSBgJHtrZXl9OiAke3ZhbHVlfSwgYDtcbiAgICAgIHN0cmluZ1JlcHJlc2VudGF0aW9uID0gc3RyaW5nUmVwcmVzZW50YXRpb24gKyBrZXlWYWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gYCR7c3VwZXIudG9TdHJpbmcoKX06IHZhbHVlTWFwU3RyaW5nOiAke3N0cmluZ1JlcHJlc2VudGF0aW9uLnNsaWNlKFxuICAgICAgMCxcbiAgICAgIC0yXG4gICAgKX1gO1xuICB9XG59XG5cbi8qKlxuICogSW5kaWNhdGVzIHRoYXQgdGhlIHJlcXVlc3RlZCBkYXRhIHdhcyBub3QgYXZhaWxhYmxlIGluIHRoZSBjYWNoZS5cbiAqL1xuZXhwb3J0IGNsYXNzIE1pc3MgZXh0ZW5kcyBCYXNlUmVzcG9uc2VNaXNzIGltcGxlbWVudHMgSVJlc3BvbnNlIHtcbiAgcmVhZG9ubHkgdHlwZTogQ2FjaGVTb3J0ZWRTZXRHZXRTY29yZXNSZXNwb25zZS5NaXNzID1cbiAgICBDYWNoZVNvcnRlZFNldEdldFNjb3Jlc1Jlc3BvbnNlLk1pc3M7XG5cbiAgcHVibGljIHZhbHVlKCk6IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIEluZGljYXRlcyB0aGF0IGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyB0aGUgZGljdGlvbmFyeSBnZXQgZmllbGRzIHJlcXVlc3QuXG4gKlxuICogVGhpcyByZXNwb25zZSBvYmplY3QgaW5jbHVkZXMgdGhlIGZvbGxvd2luZyBmaWVsZHMgdGhhdCB5b3UgY2FuIHVzZSB0byBkZXRlcm1pbmVcbiAqIGhvdyB5b3Ugd291bGQgbGlrZSB0byBoYW5kbGUgdGhlIGVycm9yOlxuICpcbiAqIC0gYGVycm9yQ29kZSgpYCAtIGEgdW5pcXVlIE1vbWVudG8gZXJyb3IgY29kZSBpbmRpY2F0aW5nIHRoZSB0eXBlIG9mIGVycm9yIHRoYXQgb2NjdXJyZWQuXG4gKiAtIGBtZXNzYWdlKClgIC0gYSBodW1hbi1yZWFkYWJsZSBkZXNjcmlwdGlvbiBvZiB0aGUgZXJyb3JcbiAqIC0gYGlubmVyRXhjZXB0aW9uKClgIC0gdGhlIG9yaWdpbmFsIGVycm9yIHRoYXQgY2F1c2VkIHRoZSBmYWlsdXJlOyBjYW4gYmUgcmUtdGhyb3duLlxuICovXG5leHBvcnQgY2xhc3MgRXJyb3IgZXh0ZW5kcyBCYXNlUmVzcG9uc2VFcnJvciBpbXBsZW1lbnRzIElSZXNwb25zZSB7XG4gIHJlYWRvbmx5IHR5cGU6IENhY2hlU29ydGVkU2V0R2V0U2NvcmVzUmVzcG9uc2UuRXJyb3IgPVxuICAgIENhY2hlU29ydGVkU2V0R2V0U2NvcmVzUmVzcG9uc2UuRXJyb3I7XG5cbiAgY29uc3RydWN0b3IoX2lubmVyRXhjZXB0aW9uOiBTZGtFcnJvcikge1xuICAgIHN1cGVyKF9pbm5lckV4Y2VwdGlvbik7XG4gIH1cblxuICBwdWJsaWMgdmFsdWUoKTogdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIFJlc3BvbnNlID0gSGl0IHwgTWlzcyB8IEVycm9yO1xuIl19