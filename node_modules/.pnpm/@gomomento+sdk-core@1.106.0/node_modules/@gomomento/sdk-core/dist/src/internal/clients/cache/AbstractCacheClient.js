"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractCacheClient = void 0;
const index_1 = require("../../../index");
const momento_cache_1 = require("./momento-cache");
class AbstractCacheClient {
    constructor(controlClient, dataClients, pingClient) {
        this.controlClient = controlClient;
        this.dataClients = dataClients;
        this.pingClient = pingClient;
        // We round-robin the requests through all of our clients.  Since javascript
        // is single-threaded, we don't have to worry about thread safety on this
        // index variable.
        this.nextDataClientIndex = 0;
    }
    cache(cacheName) {
        return new momento_cache_1.MomentoCache(this, cacheName);
    }
    /**
     * Ping the service to verify it is up and running
     */
    async ping() {
        var _a;
        return await ((_a = this.pingClient) === null || _a === void 0 ? void 0 : _a.ping());
    }
    /**
     * Creates a cache if it does not exist.
     *
     * @param {string} cacheName - The cache to be created.
     * @returns {Promise<CreateCache.Response>} -
     * {@link CreateCache.Success} on success.
     * {@link CreateCache.AlreadyExists} if the cache already exists.
     * {@link CreateCache.Error} on failure.
     */
    async createCache(cacheName) {
        return await this.controlClient.createCache(cacheName);
    }
    /**
     * Deletes a cache and all items stored in it.
     *
     * @param {string} cacheName - The cache to delete.
     * @returns {Promise<DeleteCache.Response>} -
     * {@link DeleteCache.Success} on success.
     * {@link DeleteCache.Error} on failure.
     */
    async deleteCache(cacheName) {
        return await this.controlClient.deleteCache(cacheName);
    }
    /**
     * Lists all caches.
     *
     * @returns {Promise<ListCaches.Response>} -
     * {@link ListCaches.Success} containing the list on success.
     * {@link ListCaches.Error} on failure.
     */
    async listCaches() {
        return await this.controlClient.listCaches();
    }
    /**
     * Gets the value stored for the given key.
     *
     * @param {string} cacheName - The cache to perform the lookup in.
     * @param {string | Uint8Array} key - The key to look up.
     * @param {GetOptions} [options]
     * @param {decompress} [options.decompress=false] - Whether to decompress the value. Overrides the client-wide
     * automatic decompression setting.
     * @returns {Promise<CacheGet.Response>} -
     * {@link CacheGet.Hit} containing the value if one is found.
     * {@link CacheGet.Miss} if the key does not exist.
     * {@link CacheGet.Error} on failure.
     */
    async get(cacheName, key, options) {
        return await this.getNextDataClient().get(cacheName, key, options);
    }
    /**
     * Associates the given key with the given value. If a value for the key is
     * already present it is replaced with the new value.
     *
     * @param {string} cacheName - The cache to store the value in.
     * @param {string | Uint8Array} key - The key to set.
     * @param {string | Uint8Array} value - The value to be stored.
     * @param {SetOptions} [options]
     * @param {number} [options.ttl] - The time to live for the item in the cache.
     * Uses the client's default TTL if this is not supplied.
     * @param {boolean} [options.compress=false] - Whether to compress the value. Defaults to false.
     * @returns {Promise<CacheSet.Response>} -
     * {@link CacheSet.Success} on success.
     * {@link CacheSet.Error} on failure.
     */
    async set(cacheName, key, value, options) {
        // this typeof check wouldn't be necessary in TS, but it can help catch bugs in JS code at runtime.
        if (typeof options === 'number') {
            throw new index_1.InvalidArgumentError('Options must be an object with a ttl property.');
        }
        const client = this.getNextDataClient();
        return await client.set(cacheName, key, value, options);
    }
    /**
     * Removes the given key from the cache. The key can represent a single value
     * or a collection.
     *
     * @param {string} cacheName - The cache to delete from.
     * @param {string | Uint8Array} key - The key to delete.
     * @returns {Promise<CacheDelete.Response>} -
     * {@link CacheDelete.Success} on success.
     * {@link CacheDelete.Error} on failure.
     */
    async delete(cacheName, key) {
        const client = this.getNextDataClient();
        return await client.delete(cacheName, key);
    }
    /**
     * Gets the value stored for the given keys.
     *
     * @param {string} cacheName - The cache to perform the lookup in.
     * @param {string[] | Uint8Array[]} keys - The list of keys to look up.
     * @param {GetBatchOptions} [options]
     * @param {decompress} [options.decompress=false] - Whether to decompress the value. Overrides the client-wide
     * automatic decompression setting.
     * @returns {Promise<CacheGetBatch.Response>} -
     * {@link CacheGetBatch.Success} containing the values if they were found.
     * {@link CacheGetBatch.Error} on failure.
     */
    async getBatch(cacheName, keys, options) {
        return await this.getNextDataClient().getBatch(cacheName, keys, options);
    }
    /**
     * Associates the given keys with the given values. If a value for the key is
     * already present it is replaced with the new value.
     *
     * @param {string} cacheName - The cache to store the values in.
     * @param {Record<string, string | Uint8Array | SetBatchItem> | Map<string | Uint8Array, string | Uint8Array | SetBatchItem>} items - The key-value pairs to be stored, with the option to set a TTL per item.
     * @param {SetBatchOptions} [options]
     * @param {number} [options.ttl] - The time to live for the items in the cache.
     * Uses the client's default TTL if this is not supplied.
     * @param {boolean} [options.compress=false] - Whether to compress the value. Defaults to false.
     * @returns {Promise<CacheSetBatch.Response>} -
     * {@link CacheSetBatch.Success} on success.
     * {@link CacheSetBatch.Error} on failure.
     */
    async setBatch(cacheName, items, options) {
        const client = this.getNextDataClient();
        return await client.setBatch(cacheName, items, options);
    }
    /**
     * Adds multiple elements to the back of the given list. Creates the list if
     * it does not already exist.
     *
     * @param {string} cacheName - The cache to store the list in.
     * @param {string} listName - The list to add to.
     * @param {string[] | Uint8Array[]} values - The elements to add to the list.
     * @param {ListConcatenateBackOptions} [options]
     * @param {number} [options.truncateFrontToSize] - If the list exceeds this
     * length, remove excess from the front of the list. Must be positive.
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the list's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheListConcatenateBack.Response>} -
     * {@link CacheListConcatenateBack.Success} on success.
     * {@link CacheListConcatenateBack.Error} on failure.
     */
    async listConcatenateBack(cacheName, listName, values, options) {
        const client = this.getNextDataClient();
        return await client.listConcatenateBack(cacheName, listName, values, options === null || options === void 0 ? void 0 : options.truncateFrontToSize, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Adds multiple elements to the front of the given list. Creates the list if
     * it does not already exist.
     *
     * @param {string} cacheName - The cache to store the list in.
     * @param {string} listName - The list to add to.
     * @param {string[] | Uint8Array[]} values - The elements to add to the list.
     * @param {ListConcatenateFrontOptions} [options]
     * @param {number} [options.truncateBackToSize] - If the list exceeds this
     * length, remove excess from the back of the list. Must be positive.
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the list's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheListConcatenateFront.Response>} -
     * {@link CacheListConcatenateFront.Success} on success.
     * {@link CacheListConcatenateFront.Error} on failure.
     */
    async listConcatenateFront(cacheName, listName, values, options) {
        const client = this.getNextDataClient();
        return await client.listConcatenateFront(cacheName, listName, values, options === null || options === void 0 ? void 0 : options.truncateBackToSize, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Fetches all elements of the given list.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to fetch.
     * @param {ListFetchCallOptions} [options]
     * @param {number} [options.startIndex] - Start inclusive index for fetch operation.
     * @param {number} [options.endIndex] - End exclusive index for fetch operation.
     * @returns {Promise<CacheListFetch.Response>} -
     * {@link CacheListFetch.Hit} containing the list elements if the list exists.
     * {@link CacheListFetch.Miss} if the list does not exist.
     * {@link CacheListFetch.Error} on failure.
     */
    async listFetch(cacheName, listName, options) {
        const client = this.getNextDataClient();
        return await client.listFetch(cacheName, listName, options === null || options === void 0 ? void 0 : options.startIndex, options === null || options === void 0 ? void 0 : options.endIndex);
    }
    /**
     * Gets the number of elements in the given list.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to get the length of.
     * @returns {Promise<CacheListLength.Response>} -
     * {@link CacheListLength.Hit} containing the length if the list exists.
     * {@link CacheListLength.Miss} if the list does not exist.
     * {@link CacheListLength.Error} on failure.
     */
    async listLength(cacheName, listName) {
        const client = this.getNextDataClient();
        return await client.listLength(cacheName, listName);
    }
    /**
     * Gets and removes the last value from the given list.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to pop.
     * @returns {Promise<CacheListPopBack.Response>} -
     * {@link CacheListPopBack.Hit} containing the element if the list exists.
     * {@link CacheListPopBack.Miss} if the list does not exist.
     * {@link CacheListPopBack.Error} on failure.
     */
    async listPopBack(cacheName, listName) {
        const client = this.getNextDataClient();
        return await client.listPopBack(cacheName, listName);
    }
    /**
     * Gets and removes the first value from the given list.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to pop.
     * @returns {Promise<CacheListPopFront.Response>} -
     * {@link CacheListPopFront.Hit} containing the element if the list exists.
     * {@link CacheListPopFront.Miss} if the list does not exist.
     * {@link CacheListPopFront.Error} on failure.
     */
    async listPopFront(cacheName, listName) {
        const client = this.getNextDataClient();
        return await client.listPopFront(cacheName, listName);
    }
    /**
     * Adds an element to the back of the given list. Creates the list if
     * it does not already exist.
     *
     * @param {string} cacheName - The cache to store the list in.
     * @param {string} listName - The list to push to.
     * @param {string | Uint8Array} value - The value to push.
     * @param {ListPushBackOptions} [options]
     * @param {number} [options.truncateFrontToSize] - If the list exceeds this
     * length, remove excess from the front of the list. Must be positive.
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the list's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheListPushBack.Response>} -
     * {@link CacheListPushBack.Success} containing the list's new length on
     * success.
     * {@link CacheListPushBack.Error} on failure.
     */
    async listPushBack(cacheName, listName, value, options) {
        const client = this.getNextDataClient();
        return await client.listPushBack(cacheName, listName, value, options === null || options === void 0 ? void 0 : options.truncateFrontToSize, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Adds an element to the front of the given list. Creates the list if
     * it does not already exist.
     *
     * @param {string} cacheName - The cache to store the list in.
     * @param {string} listName - The list to push to.
     * @param {string | Uint8Array} value - The value to push.
     * @param {ListPushFrontOptions} [options]
     * @param {number} [options.truncateBackToSize] - If the list exceeds this
     * length, remove excess from the end of the list. Must be positive.
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the list's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheListPushFront.Response>} -
     * {@link CacheListPushFront.Success} containing the list's new length on
     * success.
     * {@link CacheListPushFront.Error} on failure.
     */
    async listPushFront(cacheName, listName, value, options) {
        const client = this.getNextDataClient();
        return await client.listPushFront(cacheName, listName, value, options === null || options === void 0 ? void 0 : options.truncateBackToSize, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Removes all elements from the given list equal to the given value.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to remove from.
     * @param {string | Uint8Array} value - The value to remove.
     * @returns {Promise<CacheListRemoveValue.Response>} -
     * {@link CacheListRemoveValue.Success} on success. Removing an element that
     * does not occur in the list or removing from a non-existent list counts as a
     * success.
     * {@link CacheListRemoveValue.Error} on failure.
     */
    async listRemoveValue(cacheName, listName, value) {
        const client = this.getNextDataClient();
        return await client.listRemoveValue(cacheName, listName, value);
    }
    /**
     * Retains slice of elements of a given list, deletes the rest of the list
     * that isn't being retained. Returns a Success or Error.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to retain a slice of.
     * @param {ListRetainCallOptions} [options]
     * @param {number} [options.startIndex] - Start inclusive index for fetch
     * operation. Defaults to start of array if not given, 0.
     * @param {number} [options.endIndex] - End exclusive index for fetch
     * operation. Defaults to end of array if not given.
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the list's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheListRetain.Response>} -
     * {@link CacheListRetain.Success} on success.
     * {@link CacheListRetain.Error} on failure.
     */
    async listRetain(cacheName, listName, options) {
        const client = this.getNextDataClient();
        return await client.listRetain(cacheName, listName, options === null || options === void 0 ? void 0 : options.startIndex, options === null || options === void 0 ? void 0 : options.endIndex, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Fetches all elements of the given set
     *
     * @param {string} cacheName - The cache containing the set.
     * @param {string} setName - The set to fetch.
     * @returns {Promise<CacheSetFetch.Response>} -
     * {@link CacheSetFetch.Hit} containing the set elements if the set exists.
     * {@link CacheSetFetch.Miss} if the set does not exist.
     * {@link CacheSetFetch.Error} on failure.
     */
    async setFetch(cacheName, setName) {
        const client = this.getNextDataClient();
        return await client.setFetch(cacheName, setName);
    }
    /**
     * Adds an element to the given set. Creates the set if it does not already
     * exist.
     *
     * @remarks
     * After this operation the set will contain the union of the element passed
     * in and the original elements of the set.
     *
     * @param {string} cacheName - The cache to store the set in.
     * @param {string} setName - The set to add to.
     * @param {string | Uint8Array} element - The element to add.
     * @param {SetAddElementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the set's TTL using the client's default if this is not supplied.
     * @returns {Promise<CacheSetAddElement.Response>} -
     * {@link CacheSetAddElement.Success} on success.
     * {@link CacheSetAddElement.Error} on failure.
     */
    async setAddElement(cacheName, setName, element, options) {
        return (await this.setAddElements(cacheName, setName, [element], options)).toSingularResponse();
    }
    /**
     * Adds multiple elements to the given set. Creates the set if it does not
     * already exist.
     *
     * @remarks
     * After this operation, the set will contain the union of the elements passed
     * in and the original elements of the set.
     *
     * @param {string} cacheName - The cache to store the set in.
     * @param {string} setName - The set to add to.
     * @param {string[] | Uint8Array[]} elements - The elements to add.
     * @param {SetAddElementsOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the set's TTL using the client's default if this is not supplied.
     * @returns {Promise<CacheSetAddElements.Response>} -
     * {@link CacheSetAddElements.Success} on success.
     * {@link CacheSetAddElements.Error} on failure.
     */
    async setAddElements(cacheName, setName, elements, options) {
        const client = this.getNextDataClient();
        return await client.setAddElements(cacheName, setName, elements, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Tests if the given set contains the given element.
     * @param cacheName - The cache containing the set.
     * @param setName - The set to check.
     * @param element - The element to check for.
     * @returns {Promise<CacheSetContainsElement.Response>} -
     * {@link CacheSetContainsElement.Hit} if the set exists and contains the element.
     * {@link CacheSetContainsElement.Miss} if the set does not contain the element.
     * {@link CacheSetContainsElement.Error} on failure.
     */
    async setContainsElement(cacheName, setName, element) {
        const client = this.getNextDataClient();
        return await client.setContainsElement(cacheName, setName, element);
    }
    /**
     * Tests if the given set contains the given elements.
     * @param cacheName - The cache containing the set.
     * @param setName - The set to check.
     * @param elements - The elements to check for.
     * @returns {Promise<CacheSetContainsElements.Response>} -
     * {@link CacheSetContainsElements.Hit} containing the elements to their presence in the cache.
     * {@link CacheSetContainsElements.Miss} if the set does not contain the elements.
     * {@link CacheSetContainsElements.Error} on failure.
     */
    async setContainsElements(cacheName, setName, elements) {
        const client = this.getNextDataClient();
        return await client.setContainsElements(cacheName, setName, elements);
    }
    /**
     * Removes an element from the given set.
     *
     * @param {string} cacheName - The cache containing the set.
     * @param {string} setName - The set to remove from.
     * @param {string | Uint8Array} element - The element to remove.
     * @returns {Promise<CacheSetRemoveElement.Response>} -
     * {@link CacheSetRemoveElement.Success} on success. Removing an element that
     * does not occur in the set or removing from a non-existent set counts as a
     * success.
     * {@link CacheSetRemoveElement.Error} on failure.
     */
    async setRemoveElement(cacheName, setName, element) {
        return (await this.setRemoveElements(cacheName, setName, [element])).toSingularResponse();
    }
    /**
     * Removes multiple elements from the given set.
     *
     * @param {string} cacheName - The cache containing the set.
     * @param {string} setName - The set to remove from.
     * @param {string[] | Uint8Array[]} elements - The elements to remove.
     * @returns {Promise<CacheSetRemoveElements.Response>} -
     * {@link CacheSetRemoveElements.Success} on success. Removing elements that
     * do not occur in the set or removing from a non-existent set counts as a
     * success.
     * {@link CacheSetRemoveElements.Error} on failure.
     */
    async setRemoveElements(cacheName, setName, elements) {
        const client = this.getNextDataClient();
        return await client.setRemoveElements(cacheName, setName, elements);
    }
    /**
     * Fetch a random sample of elements from the set.
     * Returns a different random sample for each call.
     *
     * @param {string} cacheName - The cache containing the set.
     * @param {string} setName - The set to remove from.
     * @param {number} limit - The maximum number of elements to return.
     * If the set contains fewer than 'limit' elements, the entire set will be returned.
     * @returns {Promise<CacheSetSample.Response>} -
     * {@link CacheSetSample.Hit} containing the set elements if the set exists.
     * {@link CacheSetSample.Miss} if the set does not exist.
     * {@link CacheSetSample.Error} on failure.
     */
    async setSample(cacheName, setName, limit) {
        const client = this.getNextDataClient();
        return await client.setSample(cacheName, setName, limit);
    }
    /**
     * Pops a random sample of elements from the set.
     *
     * @param {string} cacheName - The cache containing the set.
     * @param {string} setName - The set to remove from.
     * @param {number} count - The maximum number of elements to return.
     * If the set contains fewer than 'limit' elements, the entire set will be returned.
     * @returns {Promise<CacheSetPop.Response>} -
     * {@link CacheSetPop.Hit} containing the set elements if the set exists.
     * {@link CacheSetPop.Miss} if the set does not exist.
     * {@link CacheSetPop.Error} on failure.
     */
    async setPop(cacheName, setName, count) {
        const client = this.getNextDataClient();
        return await client.setPop(cacheName, setName, count);
    }
    /**
     * Get the number of elements in the set.
     *
     * @param {string} cacheName - The cache containing the set.
     * @param {string} setName - The set to remove from.
     * @returns {Promise<CacheSetLength.Response>} -
     * {@link CacheSetLength.Hit} containing the set elements if the set exists.
     * {@link CacheSetLength.Miss} if the set does not exist.
     * {@link CacheSetLength.Error} on failure.
     */
    async setLength(cacheName, setName) {
        const client = this.getNextDataClient();
        return await client.setLength(cacheName, setName);
    }
    /**
     * Associates the given key with the given value if key is not already present in the cache.
     *
     * @deprecated Use setIfAbsent instead.
     * @param {string} cacheName - The cache to store the value in.
     * @param {string | Uint8Array} key - The key to set.
     * @param {string | Uint8Array} field - The value to be stored.
     * @param {SetIfNotExistsOptions} [options]
     * @param {number} [options.ttl] - The time to live for the item in the cache.
     * Uses the client's default TTL if this is not supplied.
     * @returns {Promise<CacheSetIfNotExists.Response>} -
     * {@link CacheSetIfNotExists.Stored} on storing the new value.
     * {@link CacheSetIfNotExists.NotStored} on not storing the new value.
     * {@link CacheSetIfNotExists.Error} on failure.
     */
    async setIfNotExists(cacheName, key, field, options) {
        const client = this.getNextDataClient();
        return await client.setIfNotExists(cacheName, key, field, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Associates the given key with the given value if key is not already present in the cache.
     *
     * @param {string} cacheName - The cache to store the value in.
     * @param {string | Uint8Array} key - The key to set.
     * @param {string | Uint8Array} field - The value to be stored.
     * @param {SetIfAbsentOptions} [options]
     * @param {number} [options.ttl] - The time to live for the item in the cache.
     * Uses the client's default TTL if this is not supplied.
     * @param {boolean} [options.compress=false] - Whether to compress the value. Defaults to false.
     * @returns {Promise<CacheSetIfAbsent.Response>} -
     * {@link CacheSetIfAbsent.Stored} on storing the new value.
     * {@link CacheSetIfAbsent.NotStored} on not storing the new value.
     * {@link CacheSetIfAbsent.Error} on failure.
     */
    async setIfAbsent(cacheName, key, field, options) {
        const client = this.getNextDataClient();
        return await client.setIfAbsent(cacheName, key, field, options);
    }
    /**
     * Associates the given key with the given value if the key is present in the cache.
     *
     * @param {string} cacheName - The cache to store the value in.
     * @param {string | Uint8Array} key - The key to set.
     * @param {string | Uint8Array} field - The value to be stored.
     * @param {SetIfPresentOptions} [options]
     * @param {number} [options.ttl] - The time to live for the item in the cache.
     * Uses the client's default TTL if this is not supplied.
     * @returns {Promise<CacheSetIfPresent.Response>} -
     * {@link CacheSetIfPresent.Stored} on storing the new value.
     * {@link CacheSetIfPresent.NotStored} on not storing the new value.
     * {@link CacheSetIfPresent.Error} on failure.
     */
    async setIfPresent(cacheName, key, field, options) {
        const client = this.getNextDataClient();
        return await client.setIfPresent(cacheName, key, field, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Associates the given key with the given value if the key is present in the cache
     * and its value is equal to the supplied `equal` value.
     *
     * @param {string} cacheName - The cache to store the value in.
     * @param {string | Uint8Array} key - The key to set.
     * @param {string | Uint8Array} field - The value to be stored.
     * @param {string | Uint8Array} equal - The value to compare to the cached value.
     * @param {SetIfEqualOptions} [options]
     * @param {number} [options.ttl] - The time to live for the item in the cache.
     * Uses the client's default TTL if this is not supplied.
     * @returns {Promise<CacheSetIfEqual.Response>} -
     * {@link CacheSetIfEqual.Stored} on storing the new value.
     * {@link CacheSetIfEqual.NotStored} on not storing the new value.
     * {@link CacheSetIfEqual.Error} on failure.
     */
    async setIfEqual(cacheName, key, field, equal, options) {
        const client = this.getNextDataClient();
        return await client.setIfEqual(cacheName, key, field, equal, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Associates the given key with the given value if the key does not exist in the cache or
     * if the value for the key is not equal to the supplied `notEqual` parameter.
     *
     * @param {string} cacheName - The cache to store the value in.
     * @param {string | Uint8Array} key - The key to set.
     * @param {string | Uint8Array} field - The value to be stored.
     * @param {string | Uint8Array} notEqual - The value to compare to the cached value.
     * @param {SetIfNotEqualOptions} [options]
     * @param {number} [options.ttl] - The time to live for the item in the cache.
     * Uses the client's default TTL if this is not supplied.
     * @returns {Promise<CacheSetIfNotEqual.Response>} -
     * {@link CacheSetIfNotEqual.Stored} on storing the new value.
     * {@link CacheSetIfNotEqual.NotStored} on not storing the new value.
     * {@link CacheSetIfNotEqual.Error} on failure.
     */
    async setIfNotEqual(cacheName, key, field, notEqual, options) {
        const client = this.getNextDataClient();
        return await client.setIfNotEqual(cacheName, key, field, notEqual, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Associates the given key with the given value if key is present in the cache
     * and its value is not equal to the supplied `notEqual` value.
     *
     * @param {string} cacheName - The cache to store the value in.
     * @param {string | Uint8Array} key - The key to set.
     * @param {string | Uint8Array} field - The value to be stored.
     * @param {string | Uint8Array} notEqual - The value to compare to the cached value.
     * @param {SetIfAbsentOptions} [options]
     * @param {number} [options.ttl] - The time to live for the item in the cache.
     * Uses the client's default TTL if this is not supplied.
     * @returns {Promise<CacheSetIfPresentAndNotEqual.Response>} -
     * {@link CacheSetIfPresentAndNotEqual.Stored} on storing the new value.
     * {@link CacheSetIfPresentAndNotEqual.NotStored} on not storing the new value.
     * {@link CacheSetIfPresentAndNotEqual.Error} on failure.
     */
    async setIfPresentAndNotEqual(cacheName, key, field, notEqual, options) {
        const client = this.getNextDataClient();
        return await client.setIfPresentAndNotEqual(cacheName, key, field, notEqual, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Associates the given key with the given value if key is absent or if the key is
     * present and its value is equal to the given value.
     *
     * @param {string} cacheName - The cache to store the value in.
     * @param {string | Uint8Array} key - The key to set.
     * @param {string | Uint8Array} field - The value to be stored.
     * @param {string | Uint8Array} equal - The value to compare to the cached value.
     * @param {SetIfAbsentOrEqualOptions} [options]
     * @param {number} [options.ttl] - The time to live for the item in the cache.
     * Uses the client's default TTL if this is not supplied.
     * @returns {Promise<CacheSetIfAbsentOrEqual.Response>} -
     * {@link CacheSetIfAbsentOrEqual.Stored} on storing the new value.
     * {@link CacheSetIfAbsentOrEqual.NotStored} on not storing the new value.
     * {@link CacheSetIfAbsentOrEqual.Error} on failure.
     */
    async setIfAbsentOrEqual(cacheName, key, field, equal, options) {
        const client = this.getNextDataClient();
        return await client.setIfAbsentOrEqual(cacheName, key, field, equal, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Flushes / clears all the items of the given cache
     *
     * @param {string} cacheName - The cache to be flushed.
     * @returns {Promise<CacheFlush.Response>} -
     * {@link CacheFlush.Success} on success.
     * {@link CacheFlush.Error} on failure.
     */
    async flushCache(cacheName) {
        return await this.controlClient.flushCache(cacheName);
    }
    /**
     * Fetches all elements of the given dictionary.
     *
     * @param {string} cacheName - The cache to perform the lookup in.
     * @param {string} dictionaryName - The dictionary to fetch.
     * @returns {Promise<CacheDictionaryFetch.Response>} -
     * {@link CacheDictionaryFetch.Hit} containing the dictionary elements if the
     * dictionary exists.
     * {@link CacheDictionaryFetch.Miss} if the dictionary does not exist.
     * {@link CacheDictionaryFetch.Error} on failure.
     */
    async dictionaryFetch(cacheName, dictionaryName) {
        const client = this.getNextDataClient();
        return await client.dictionaryFetch(cacheName, dictionaryName);
    }
    /**
     * Adds an integer quantity to a field value.
     *
     * @remarks
     * Incrementing the value of a missing field sets the value to amount.
     *
     * @param {string} cacheName - The cache containing the field.
     * @param {string | Uint8Array} field - The field to increment.
     * @param {number} amount - The quantity to add to the value. May be positive,
     * negative, or zero. Defaults to 1.
     * @param {IncrementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * @returns {Promise<CacheIncrement>} -
     * {@link CacheIncrement.Success} containing the incremented value
     * on success.
     * {@link CacheIncrement.Error} on failure. Incrementing a value
     * that was not set using this method or is not the string representation of
     * an integer results in a failure with a FailedPreconditionException error.
     */
    async increment(cacheName, field, amount = 1, options) {
        const client = this.getNextDataClient();
        return await client.increment(cacheName, field, amount, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Adds an element to the given dictionary. Creates the dictionary if it does
     * not already exist.
     *
     * @param {string} cacheName - The cache to store the dictionary in.
     * @param {string} dictionaryName - The dictionary to add to.
     * @param {string | Uint8Array} field - The field to set.
     * @param {string | Uint8Array} value - The value to store.
     * @param {DictionarySetFieldOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the dictionary's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheDictionarySetField.Response>} -
     * {@link CacheDictionarySetField.Success} on success.
     * {@link CacheDictionarySetField.Error} on failure.
     */
    async dictionarySetField(cacheName, dictionaryName, field, value, options) {
        const client = this.getNextDataClient();
        return await client.dictionarySetField(cacheName, dictionaryName, field, value, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Adds multiple elements to the given dictionary. Creates the dictionary if
     * it does not already exist.
     *
     * @param {string} cacheName - The cache to store the dictionary in.
     * @param {string} dictionaryName - The dictionary to add to.
     * @param {Map<string | Uint8Array, string | Uint8Array>} elements - The
     * elements to set.
     * @param {DictionarySetFieldsOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the dictionary's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheDictionarySetFields.Response>} -
     * {@link CacheDictionarySetFields.Success} on success.
     * {@link CacheDictionarySetFields.Error} on failure.
     */
    async dictionarySetFields(cacheName, dictionaryName, elements, options) {
        const client = this.getNextDataClient();
        return await client.dictionarySetFields(cacheName, dictionaryName, elements, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Gets the value stored for the given dictionary and field.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to look up.
     * @param {string | Uint8Array} field - The field to look up.
     * @returns {Promise<CacheDictionaryGetField.Response>} -
     * {@link CacheDictionaryGetField.Hit} containing the dictionary element if
     * one is found.
     * {@link CacheDictionaryGetField.Miss} if the dictionary does not exist.
     * {@link CacheDictionaryGetField.Error} on failure.
     */
    async dictionaryGetField(cacheName, dictionaryName, field) {
        const client = this.getNextDataClient();
        return await client.dictionaryGetField(cacheName, dictionaryName, field);
    }
    /**
     * Gets multiple values from the given dictionary.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to look up.
     * @param {string[] | Uint8Array[]} fields - The fields to look up.
     * @returns {Promise<CacheDictionaryGetFields.Response>} -
     * {@link CacheDictionaryGetFields.Hit} containing the dictionary elements if
     * the dictionary exists.
     * {@link CacheDictionaryGetFields.Miss} if the dictionary does not exist.
     * {@link CacheDictionaryGetFields.Error} on failure.
     */
    async dictionaryGetFields(cacheName, dictionaryName, fields) {
        const client = this.getNextDataClient();
        return await client.dictionaryGetFields(cacheName, dictionaryName, fields);
    }
    /**
     * Removes an element from the given dictionary.
     *
     * @remarks
     * Performs a no-op if the dictionary or field does not exist.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to remove from.
     * @param {string | Uint8Array} field - The field to remove.
     * @returns {Promise<CacheDictionaryRemoveField.Response>} -
     * {@link CacheDictionaryRemoveField.Success} on success.
     * {@link CacheDictionaryRemoveField.Error} on failure.
     */
    async dictionaryRemoveField(cacheName, dictionaryName, field) {
        const client = this.getNextDataClient();
        return await client.dictionaryRemoveField(cacheName, dictionaryName, field);
    }
    /**
     * Removes multiple fields from the given dictionary.
     *
     * @remarks
     * Performs a no-op if the dictionary or fields do not exist.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to remove from.
     * @param {string[] | Uint8Array[]} fields - The fields to remove.
     * @returns {Promise<CacheDictionaryRemoveFields.Response>} -
     * {@link CacheDictionaryRemoveFields.Success} on success.
     * {@link CacheDictionaryRemoveFields.Error} on failure.
     */
    async dictionaryRemoveFields(cacheName, dictionaryName, fields) {
        const client = this.getNextDataClient();
        return await client.dictionaryRemoveFields(cacheName, dictionaryName, fields);
    }
    /**
     * Adds an integer quantity to a dictionary value.
     *
     * @remarks
     * Incrementing the value of a missing field sets the value to amount.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to set.
     * @param {string | Uint8Array} field - The field to increment.
     * @param {number} amount - The quantity to add to the value. May be positive,
     * negative, or zero. Defaults to 1.
     * @param {DictionaryIncrementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the dictionary's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheDictionaryIncrement.Response>} -
     * {@link CacheDictionaryIncrement.Success} containing the incremented value
     * on success.
     * {@link CacheDictionaryIncrement.Error} on failure. Incrementing a value
     * that was not set using this method or is not the string representation of
     * an integer results in a failure with a FailedPreconditionException error.
     */
    async dictionaryIncrement(cacheName, dictionaryName, field, amount = 1, options) {
        const client = this.getNextDataClient();
        return await client.dictionaryIncrement(cacheName, dictionaryName, field, amount, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Gets the number of elements in the given dictionary.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to get the length of.
     * @returns {Promise<CacheDictionaryLength.Response>} -
     * {@link CacheDictionaryLength.Hit} containing the length if the dictionary exists.
     * {@link CacheDictionaryLength.Miss} if the dictionary does not exist.
     * {@link CacheDictionaryLength.Error} on failure.
     */
    async dictionaryLength(cacheName, dictionaryName) {
        const client = this.getNextDataClient();
        return await client.dictionaryLength(cacheName, dictionaryName);
    }
    /**
     * Adds an element to the given sorted set. If the element already exists, its
     * score is updated. Creates the sorted set if it does not exist.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to add to.
     * @param {string | Uint8Array} value - The value to add.
     * @param {number} score - The score to assign to the value.
     * @param {SortedSetPutElementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the sorted set's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheSortedSetPutElement.Response>} -
     * {@link CacheSortedSetPutElement.Success} on success.
     * {@link CacheSortedSetPutElement.Error} on failure.
     * @returns
     */
    async sortedSetPutElement(cacheName, sortedSetName, value, score, options) {
        const client = this.getNextDataClient();
        return await client.sortedSetPutElement(cacheName, sortedSetName, value, score, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Adds elements to the given sorted set. For any values that already exist, it
     * the score is updated. Creates the sorted set if it does not exist.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to add to.
     * @param {Map<string | Uint8Array, number>| Record<string, number>} elements - The value->score pairs to add to the sorted set.
     * @param {SortedSetPutElementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the sorted set's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheSortedSetPutElements.Response>} -
     * {@link CacheSortedSetPutElements.Success} on success.
     * {@link CacheSortedSetPutElements.Error} on failure.
     * @returns
     */
    async sortedSetPutElements(cacheName, sortedSetName, elements, options) {
        const client = this.getNextDataClient();
        return await client.sortedSetPutElements(cacheName, sortedSetName, elements, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Fetch the elements in the given sorted set by index (rank).
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {SortedSetFetchByRankOptions} options
     * @param {number} [options.startRank] - The rank of the first element to
     * fetch. Defaults to 0. This rank is inclusive, ie the element at this rank
     * will be fetched.
     * @param {number} [options.endRank] - The rank of the last element to fetch.
     * This rank is exclusive, ie the element at this rank will not be fetched.
     * Defaults to null, which fetches up until and including the last element.
     * @param {SortedSetOrder} [options.order] - The order to fetch the elements in.
     * Defaults to ascending.
     * @returns {Promise<CacheSortedSetFetch.Response>}
     * {@link CacheSortedSetFetch.Hit} containing the requested elements when found.
     * {@link CacheSortedSetFetch.Miss} when the sorted set does not exist.
     * {@link CacheSortedSetFetch.Error} on failure.
     */
    async sortedSetFetchByRank(cacheName, sortedSetName, options) {
        var _a, _b;
        const client = this.getNextDataClient();
        return await client.sortedSetFetchByRank(cacheName, sortedSetName, (_a = options === null || options === void 0 ? void 0 : options.order) !== null && _a !== void 0 ? _a : index_1.SortedSetOrder.Ascending, (_b = options === null || options === void 0 ? void 0 : options.startRank) !== null && _b !== void 0 ? _b : 0, options === null || options === void 0 ? void 0 : options.endRank);
    }
    /**
     * Fetch the elements in the given sorted set by score.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {SortedSetFetchByScoreOptions} options
     * @param {number} [options.minScore] - The minimum score (inclusive) of the
     * elements to fetch. Defaults to negative infinity.
     * @param {number} [options.maxScore] - The maximum score (inclusive) of the
     * elements to fetch. Defaults to positive infinity.
     * @param {SortedSetOrder} [options.order] - The order to fetch the elements in.
     * Defaults to ascending.
     * @param {number} [options.offset] - The number of elements to skip before
     * returning the first element. Defaults to 0. Note: this is not the rank of
     * the first element to return, but the number of elements of the result set
     * to skip before returning the first element.
     * @param {number} [options.count] - The maximum number of elements to return.
     * Defaults to undefined, which returns all elements.
     * @returns {Promise<CacheSortedSetFetch.Response>} -
     * {@link CacheSortedSetFetch.Hit} containing the requested elements when found.
     * {@link CacheSortedSetFetch.Miss} when the sorted set does not exist.
     * {@link CacheSortedSetFetch.Error} on failure.
     */
    async sortedSetFetchByScore(cacheName, sortedSetName, options) {
        var _a;
        const client = this.getNextDataClient();
        return await client.sortedSetFetchByScore(cacheName, sortedSetName, (_a = options === null || options === void 0 ? void 0 : options.order) !== null && _a !== void 0 ? _a : index_1.SortedSetOrder.Ascending, options === null || options === void 0 ? void 0 : options.minScore, options === null || options === void 0 ? void 0 : options.maxScore, options === null || options === void 0 ? void 0 : options.offset, options === null || options === void 0 ? void 0 : options.count);
    }
    /**
     * Look up the rank of an element in the sorted set, by the value of the element.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {string | Uint8Array} value - The value of the element whose rank we are retrieving.
     * @param {SortedSetGetRankOptions} options
     * @param {SortedSetOrder} [options.order] - The order in which sorted set will be sorted to determine the rank.
     * Defaults to ascending.
     * @returns {Promise<CacheSortedSetGetRank.Response>}
     * {@link CacheSortedSetGetRank.Hit} containing the rank of the requested elements when found.
     * {@link CacheSortedSetGetRank.Miss} when the element does not exist.
     * {@link CacheSortedSetGetRank.Error} on failure.
     */
    async sortedSetGetRank(cacheName, sortedSetName, value, options) {
        const client = this.getNextDataClient();
        return await client.sortedSetGetRank(cacheName, sortedSetName, value, options === null || options === void 0 ? void 0 : options.order);
    }
    /**
     * Look up the score of an element in the sorted set, by the value of the element.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {string | Uint8Array} value - The value of the element whose score we are retrieving.
     * @returns {Promise<CacheSortedSetGetScore.Response>}
     * {@link CacheSortedSetGetScore.Hit} containing the score of the requested element when found.
     * {@link CacheSortedSetGetScore.Miss} when the element or collection does not exist.
     * {@link CacheSortedSetGetScore.Error} on failure.
     */
    async sortedSetGetScore(cacheName, sortedSetName, value) {
        const client = this.getNextDataClient();
        return await client.sortedSetGetScore(cacheName, sortedSetName, value);
    }
    /**
     * Look up the scores of multiple elements in the sorted set, by the value of the elements.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {string[] | Uint8Array[]} values - The values of the elements whose scores we are retrieving.
     * @returns {Promise<CacheSortedSetGetScores.Response>}
     * {@link CacheSortedSetGetScores.Hit} containing the scores of the requested elements when found.
     * {@link CacheSortedSetGetScores.Miss} when the element or collection does not exist.
     * {@link CacheSortedSetGetScores.Error} on failure.
     */
    async sortedSetGetScores(cacheName, sortedSetName, values) {
        const client = this.getNextDataClient();
        return await client.sortedSetGetScores(cacheName, sortedSetName, values);
    }
    /**
     * Increment the score of an element in the sorted set.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {string | Uint8Array} value - The value of the element whose score we are incrementing.
     * @param {number} amount - The quantity to add to the score. May be positive,
     * negative, or zero. Defaults to 1.
     * @param {SortedSetIncrementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the sorted set's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheSortedSetIncrementScore.Response>} -
     * {@link CacheSortedSetIncrementScore.Success} containing the incremented score
     * on success.
     * {@link CacheSortedSetIncrementScore.Error} on failure. Incrementing a score
     * that was not set using this method or is not the string representation of
     * an integer results in a failure with a FailedPreconditionException error.
     */
    async sortedSetIncrementScore(cacheName, sortedSetName, value, amount, options) {
        const client = this.getNextDataClient();
        return await client.sortedSetIncrementScore(cacheName, sortedSetName, value, amount || 1, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Remove an element from the sorted set
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to remove from.
     * @param {string | Uint8Array} value - The value of the element to remove from the set.
     * @returns {Promise<CacheSortedSetRemoveElement.Response>}
     * {@link CacheSortedSetRemoveElement.Success} if the element was successfully removed
     * {@link CacheSortedSetIncrementScore.Error} on failure
     */
    async sortedSetRemoveElement(cacheName, sortedSetName, value) {
        const client = this.getNextDataClient();
        return await client.sortedSetRemoveElement(cacheName, sortedSetName, value);
    }
    /**
     * Remove multiple elements from the sorted set
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to remove from.
     * @param {string | Uint8Array} values - The values of the elements to remove from the set.
     * @returns {Promise<CacheSortedSetRemoveElement.Response>}
     * {@link CacheSortedSetRemoveElement.Success} if the elements were successfully removed
     * {@link CacheSortedSetIncrementScore.Error} on failure
     */
    async sortedSetRemoveElements(cacheName, sortedSetName, values) {
        const client = this.getNextDataClient();
        return await client.sortedSetRemoveElements(cacheName, sortedSetName, values);
    }
    /**
     * Fetch length (number of items) of sorted set
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set name.
     * @returns {Promise<CacheSortedSetLength.Response>}
     * {@link CacheSortedSetLength.Hit} containing the length if the sorted set exists.
     * {@link CacheSortedSetLength.Miss} if the sorted set does not exist.
     * {@link CacheSortedSetLength.Error} on failure.
     */
    async sortedSetLength(cacheName, sortedSetName) {
        const client = this.getNextDataClient();
        return await client.sortedSetLength(cacheName, sortedSetName);
    }
    /**
     * Fetch length (number of items) of sorted set within the provided score range
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set name.
     * @param {SortedSetLengthByScoreOptions} options - Optional parameter for specifying the score range to search in.
     * @param {number} [options.minScore] - The lower bound on the score range to search in.
     * @param {number} [options.maxScore] - The upper bound on the score range to search in.
     * @returns {Promise<CacheSortedSetLengthByScore.Response>}
     * {@link CacheSortedSetLengthByScore.Hit} containing the length if the sorted set exists.
     * {@link CacheSortedSetLengthByScore.Miss} if the sorted set does not exist.
     * {@link CacheSortedSetLengthByScore.Error} on failure.
     */
    async sortedSetLengthByScore(cacheName, sortedSetName, options) {
        const client = this.getNextDataClient();
        return await client.sortedSetLengthByScore(cacheName, sortedSetName, options === null || options === void 0 ? void 0 : options.minScore, options === null || options === void 0 ? void 0 : options.maxScore);
    }
    /**
     * Return the type of the key in the cache
     * @param {string} cacheName - The cache containing the key.
     * @param {string} key - The key for which type is requested.
     * @returns {Promise<CacheItemGetType.Response>}
     * {@link CacheItemGetType.Hit} containing type of key when found.
     * {@link CacheItemGetType.Miss} when the key does not exist.
     * {@link CacheItemGetType.Error} on failure.
     */
    async itemGetType(cacheName, key) {
        const client = this.getNextDataClient();
        return await client.itemGetType(cacheName, key);
    }
    /**
     * Return the remaining ttl of the key in the cache in milliseconds.
     * @param {string} cacheName - The cache containing the key.
     * @param {string} key - The key for which the ttl remaining is requested.
     * @returns {Promise<CacheItemGetTtl.Response>}
     * {@link CacheItemGetTtl.Hit} containing ttl remaining of key when found.
     * {@link CacheItemGetTtl.Miss} when the key does not exist.
     * {@link CacheItemGetTtl.Error} on failure.
     */
    async itemGetTtl(cacheName, key) {
        const client = this.getNextDataClient();
        return await client.itemGetTtl(cacheName, key);
    }
    /**
     * Check if the provided key exists in the cache
     * @param {string} cacheName - The cache to look in.
     * @param {string | Uint8Array} key - The key to look up.
     * @returns {Promise<CacheKeyExists.Response>}
     * {@link CacheKeyExists.Success} returns boolean indicating whether the key was found.
     * {@link CacheKeyExists.Error} on failure.
     */
    async keyExists(cacheName, key) {
        const client = this.getNextDataClient();
        return await client.keyExists(cacheName, key);
    }
    /**
     * Check if the provided keys exist in the cache
     * @param {string} cacheName - The cache to look in.
     * @param {string[] | Uint8Array[]} keys - The keys to look up.
     * @returns {Promise<CacheKeysExist.Response>}
     * {@link CacheKeysExist.Success} returns list of booleans indicating whether each key was found.
     * {@link CacheKeysExist.Error} on failure.
     */
    async keysExist(cacheName, keys) {
        const client = this.getNextDataClient();
        return await client.keysExist(cacheName, keys);
    }
    /**
     * Update the ttl of the key in the cache in milliseconds.
     * @param {string} cacheName - The cache containing the key.
     * @param {string} key - The key for which the ttl remaining is requested.
     * @param {number} ttlMilliseconds - The ttl in milliseconds that should overwrite the current ttl.
     * @returns {Promise<CacheUpdateTtl.Response>}
     * {@link CacheUpdateTtl.Set} when the ttl was successfully overwritten.
     * {@link CacheUpdateTtl.Miss} when the key does not exist.
     * {@link CacheUpdateTtl.Error} on failure.
     */
    async updateTtl(cacheName, key, ttlMilliseconds) {
        const client = this.getNextDataClient();
        return await client.updateTtl(cacheName, key, ttlMilliseconds);
    }
    /**
     * Increase the ttl of the key in the cache in milliseconds.
     * @param {string} cacheName - The cache containing the key.
     * @param {string} key - The key for which the ttl remaining is requested.
     * @param {number} ttlMilliseconds - The ttl in milliseconds that should
     * overwrite the current ttl. Should be greater than the current ttl.
     * @returns {Promise<CacheIncreaseTtl.Response>}
     * {@link CacheIncreaseTtl.Set} when the ttl was successfully increased.
     * {@link CacheIncreaseTtl.Miss} when the key does not exist.
     * {@link CacheIncreaseTtl.Error} on failure.
     */
    async increaseTtl(cacheName, key, ttlMilliseconds) {
        const client = this.getNextDataClient();
        return await client.increaseTtl(cacheName, key, ttlMilliseconds);
    }
    /**
     * Decrease the ttl of the key in the cache in milliseconds.
     * @param {string} cacheName - The cache containing the key.
     * @param {string} key - The key for which the ttl remaining is requested.
     * @param {number} ttlMilliseconds - The ttl in milliseconds that should
     * overwrite the current ttl. Should be less than the current ttl.
     * @returns {Promise<CacheDecreaseTtl.Response>}
     * {@link CacheDecreaseTtl.Set} when the ttl was successfully decreased.
     * {@link CacheDecreaseTtl.Miss} when the key does not exist.
     * {@link CacheDecreaseTtl.Error} on failure.
     */
    async decreaseTtl(cacheName, key, ttlMilliseconds) {
        const client = this.getNextDataClient();
        return await client.decreaseTtl(cacheName, key, ttlMilliseconds);
    }
    getNextDataClient() {
        const client = this.dataClients[this.nextDataClientIndex];
        this.nextDataClientIndex =
            (this.nextDataClientIndex + 1) % this.dataClients.length;
        return client;
    }
}
exports.AbstractCacheClient = AbstractCacheClient;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWJzdHJhY3RDYWNoZUNsaWVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9pbnRlcm5hbC9jbGllbnRzL2NhY2hlL0Fic3RyYWN0Q2FjaGVDbGllbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsMENBMkV3QjtBQWlDeEIsbURBQTZDO0FBRTdDLE1BQXNCLG1CQUFtQjtJQVN2QyxZQUNFLGFBQTZCLEVBQzdCLFdBQTBCLEVBQzFCLFVBQXdCO1FBRXhCLElBQUksQ0FBQyxhQUFhLEdBQUcsYUFBYSxDQUFDO1FBQ25DLElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO1FBQy9CLElBQUksQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDO1FBRTdCLDRFQUE0RTtRQUM1RSx5RUFBeUU7UUFDekUsa0JBQWtCO1FBQ2xCLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxDQUFDLENBQUM7SUFDL0IsQ0FBQztJQUVNLEtBQUssQ0FBQyxTQUFpQjtRQUM1QixPQUFPLElBQUksNEJBQVksQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQUVEOztPQUVHO0lBQ0ksS0FBSyxDQUFDLElBQUk7O1FBQ2YsT0FBTyxNQUFNLENBQUEsTUFBQSxJQUFJLENBQUMsVUFBVSwwQ0FBRSxJQUFJLEVBQUUsQ0FBQSxDQUFDO0lBQ3ZDLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNJLEtBQUssQ0FBQyxXQUFXLENBQUMsU0FBaUI7UUFDeEMsT0FBTyxNQUFNLElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3pELENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0ksS0FBSyxDQUFDLFdBQVcsQ0FBQyxTQUFpQjtRQUN4QyxPQUFPLE1BQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDekQsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLEtBQUssQ0FBQyxVQUFVO1FBQ3JCLE9BQU8sTUFBTSxJQUFJLENBQUMsYUFBYSxDQUFDLFVBQVUsRUFBRSxDQUFDO0lBQy9DLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7O09BWUc7SUFDSSxLQUFLLENBQUMsR0FBRyxDQUNkLFNBQWlCLEVBQ2pCLEdBQXdCLEVBQ3hCLE9BQW9CO1FBRXBCLE9BQU8sTUFBTSxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLEdBQUcsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNyRSxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7O09BY0c7SUFDSSxLQUFLLENBQUMsR0FBRyxDQUNkLFNBQWlCLEVBQ2pCLEdBQXdCLEVBQ3hCLEtBQTBCLEVBQzFCLE9BQW9CO1FBRXBCLG1HQUFtRztRQUNuRyxJQUFJLE9BQU8sT0FBTyxLQUFLLFFBQVEsRUFBRTtZQUMvQixNQUFNLElBQUksNEJBQW9CLENBQzVCLGdEQUFnRCxDQUNqRCxDQUFDO1NBQ0g7UUFDRCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN4QyxPQUFPLE1BQU0sTUFBTSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQztJQUMxRCxDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0ksS0FBSyxDQUFDLE1BQU0sQ0FDakIsU0FBaUIsRUFDakIsR0FBd0I7UUFFeEIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDeEMsT0FBTyxNQUFNLE1BQU0sQ0FBQyxNQUFNLENBQUMsU0FBUyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7T0FXRztJQUNJLEtBQUssQ0FBQyxRQUFRLENBQ25CLFNBQWlCLEVBQ2pCLElBQWdDLEVBQ2hDLE9BQXlCO1FBRXpCLE9BQU8sTUFBTSxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztJQUMzRSxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7T0FhRztJQUNJLEtBQUssQ0FBQyxRQUFRLENBQ25CLFNBQWlCLEVBQ2pCLEtBR3VCLEVBQ3ZCLE9BQXlCO1FBRXpCLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3hDLE9BQU8sTUFBTSxNQUFNLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDMUQsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7O09BZ0JHO0lBQ0ksS0FBSyxDQUFDLG1CQUFtQixDQUM5QixTQUFpQixFQUNqQixRQUFnQixFQUNoQixNQUErQixFQUMvQixPQUFvQztRQUVwQyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN4QyxPQUFPLE1BQU0sTUFBTSxDQUFDLG1CQUFtQixDQUNyQyxTQUFTLEVBQ1QsUUFBUSxFQUNSLE1BQU0sRUFDTixPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsbUJBQW1CLEVBQzVCLE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxHQUFHLENBQ2IsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7OztPQWdCRztJQUNJLEtBQUssQ0FBQyxvQkFBb0IsQ0FDL0IsU0FBaUIsRUFDakIsUUFBZ0IsRUFDaEIsTUFBK0IsRUFDL0IsT0FBcUM7UUFFckMsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDeEMsT0FBTyxNQUFNLE1BQU0sQ0FBQyxvQkFBb0IsQ0FDdEMsU0FBUyxFQUNULFFBQVEsRUFDUixNQUFNLEVBQ04sT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLGtCQUFrQixFQUMzQixPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsR0FBRyxDQUNiLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7OztPQVlHO0lBQ0ksS0FBSyxDQUFDLFNBQVMsQ0FDcEIsU0FBaUIsRUFDakIsUUFBZ0IsRUFDaEIsT0FBOEI7UUFFOUIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDeEMsT0FBTyxNQUFNLE1BQU0sQ0FBQyxTQUFTLENBQzNCLFNBQVMsRUFDVCxRQUFRLEVBQ1IsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLFVBQVUsRUFDbkIsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLFFBQVEsQ0FDbEIsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7Ozs7O09BU0c7SUFDSSxLQUFLLENBQUMsVUFBVSxDQUNyQixTQUFpQixFQUNqQixRQUFnQjtRQUVoQixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN4QyxPQUFPLE1BQU0sTUFBTSxDQUFDLFVBQVUsQ0FBQyxTQUFTLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDdEQsQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNJLEtBQUssQ0FBQyxXQUFXLENBQ3RCLFNBQWlCLEVBQ2pCLFFBQWdCO1FBRWhCLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3hDLE9BQU8sTUFBTSxNQUFNLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0ksS0FBSyxDQUFDLFlBQVksQ0FDdkIsU0FBaUIsRUFDakIsUUFBZ0I7UUFFaEIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDeEMsT0FBTyxNQUFNLE1BQU0sQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ3hELENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FpQkc7SUFDSSxLQUFLLENBQUMsWUFBWSxDQUN2QixTQUFpQixFQUNqQixRQUFnQixFQUNoQixLQUEwQixFQUMxQixPQUE2QjtRQUU3QixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN4QyxPQUFPLE1BQU0sTUFBTSxDQUFDLFlBQVksQ0FDOUIsU0FBUyxFQUNULFFBQVEsRUFDUixLQUFLLEVBQ0wsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLG1CQUFtQixFQUM1QixPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsR0FBRyxDQUNiLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7O09BaUJHO0lBQ0ksS0FBSyxDQUFDLGFBQWEsQ0FDeEIsU0FBaUIsRUFDakIsUUFBZ0IsRUFDaEIsS0FBMEIsRUFDMUIsT0FBOEI7UUFFOUIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDeEMsT0FBTyxNQUFNLE1BQU0sQ0FBQyxhQUFhLENBQy9CLFNBQVMsRUFDVCxRQUFRLEVBQ1IsS0FBSyxFQUNMLE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxrQkFBa0IsRUFDM0IsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLEdBQUcsQ0FDYixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7Ozs7OztPQVdHO0lBQ0ksS0FBSyxDQUFDLGVBQWUsQ0FDMUIsU0FBaUIsRUFDakIsUUFBZ0IsRUFDaEIsS0FBMEI7UUFFMUIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDeEMsT0FBTyxNQUFNLE1BQU0sQ0FBQyxlQUFlLENBQUMsU0FBUyxFQUFFLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNsRSxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7O09BaUJHO0lBQ0ksS0FBSyxDQUFDLFVBQVUsQ0FDckIsU0FBaUIsRUFDakIsUUFBZ0IsRUFDaEIsT0FBK0I7UUFFL0IsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDeEMsT0FBTyxNQUFNLE1BQU0sQ0FBQyxVQUFVLENBQzVCLFNBQVMsRUFDVCxRQUFRLEVBQ1IsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLFVBQVUsRUFDbkIsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLFFBQVEsRUFDakIsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLEdBQUcsQ0FDYixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNJLEtBQUssQ0FBQyxRQUFRLENBQ25CLFNBQWlCLEVBQ2pCLE9BQWU7UUFFZixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN4QyxPQUFPLE1BQU0sTUFBTSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDbkQsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7OztPQWlCRztJQUNJLEtBQUssQ0FBQyxhQUFhLENBQ3hCLFNBQWlCLEVBQ2pCLE9BQWUsRUFDZixPQUE0QixFQUM1QixPQUE4QjtRQUU5QixPQUFPLENBQ0wsTUFBTSxJQUFJLENBQUMsY0FBYyxDQUN2QixTQUFTLEVBQ1QsT0FBTyxFQUNQLENBQUMsT0FBTyxDQUE0QixFQUNwQyxPQUFPLENBQ1IsQ0FDRixDQUFDLGtCQUFrQixFQUFFLENBQUM7SUFDekIsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7OztPQWlCRztJQUNJLEtBQUssQ0FBQyxjQUFjLENBQ3pCLFNBQWlCLEVBQ2pCLE9BQWUsRUFDZixRQUFpQyxFQUNqQyxPQUErQjtRQUUvQixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN4QyxPQUFPLE1BQU0sTUFBTSxDQUFDLGNBQWMsQ0FDaEMsU0FBUyxFQUNULE9BQU8sRUFDUCxRQUFRLEVBQ1IsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLEdBQUcsQ0FDYixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNJLEtBQUssQ0FBQyxrQkFBa0IsQ0FDN0IsU0FBaUIsRUFDakIsT0FBZSxFQUNmLE9BQTRCO1FBRTVCLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3hDLE9BQU8sTUFBTSxNQUFNLENBQUMsa0JBQWtCLENBQUMsU0FBUyxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztJQUN0RSxDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0ksS0FBSyxDQUFDLG1CQUFtQixDQUM5QixTQUFpQixFQUNqQixPQUFlLEVBQ2YsUUFBaUM7UUFFakMsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDeEMsT0FBTyxNQUFNLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxTQUFTLEVBQUUsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ3hFLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7T0FXRztJQUNJLEtBQUssQ0FBQyxnQkFBZ0IsQ0FDM0IsU0FBaUIsRUFDakIsT0FBZSxFQUNmLE9BQTRCO1FBRTVCLE9BQU8sQ0FDTCxNQUFNLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLEVBQUUsT0FBTyxFQUFFLENBQUMsT0FBTyxDQUV6QyxDQUFDLENBQ2xCLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztJQUN6QixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7O09BV0c7SUFDSSxLQUFLLENBQUMsaUJBQWlCLENBQzVCLFNBQWlCLEVBQ2pCLE9BQWUsRUFDZixRQUFpQztRQUVqQyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN4QyxPQUFPLE1BQU0sTUFBTSxDQUFDLGlCQUFpQixDQUFDLFNBQVMsRUFBRSxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDdEUsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7T0FZRztJQUNJLEtBQUssQ0FBQyxTQUFTLENBQ3BCLFNBQWlCLEVBQ2pCLE9BQWUsRUFDZixLQUFhO1FBRWIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDeEMsT0FBTyxNQUFNLE1BQU0sQ0FBQyxTQUFTLENBQUMsU0FBUyxFQUFFLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQztJQUMzRCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7O09BV0c7SUFDSSxLQUFLLENBQUMsTUFBTSxDQUNqQixTQUFpQixFQUNqQixPQUFlLEVBQ2YsS0FBYTtRQUViLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3hDLE9BQU8sTUFBTSxNQUFNLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDeEQsQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNJLEtBQUssQ0FBQyxTQUFTLENBQ3BCLFNBQWlCLEVBQ2pCLE9BQWU7UUFFZixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN4QyxPQUFPLE1BQU0sTUFBTSxDQUFDLFNBQVMsQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDcEQsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7OztPQWNHO0lBQ0ksS0FBSyxDQUFDLGNBQWMsQ0FDekIsU0FBaUIsRUFDakIsR0FBd0IsRUFDeEIsS0FBMEIsRUFDMUIsT0FBK0I7UUFFL0IsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDeEMsT0FBTyxNQUFNLE1BQU0sQ0FBQyxjQUFjLENBQUMsU0FBUyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQzFFLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7T0FjRztJQUNJLEtBQUssQ0FBQyxXQUFXLENBQ3RCLFNBQWlCLEVBQ2pCLEdBQXdCLEVBQ3hCLEtBQTBCLEVBQzFCLE9BQTRCO1FBRTVCLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3hDLE9BQU8sTUFBTSxNQUFNLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ2xFLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7OztPQWFHO0lBQ0ksS0FBSyxDQUFDLFlBQVksQ0FDdkIsU0FBaUIsRUFDakIsR0FBd0IsRUFDeEIsS0FBMEIsRUFDMUIsT0FBNkI7UUFFN0IsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDeEMsT0FBTyxNQUFNLE1BQU0sQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3hFLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7O09BZUc7SUFDSSxLQUFLLENBQUMsVUFBVSxDQUNyQixTQUFpQixFQUNqQixHQUF3QixFQUN4QixLQUEwQixFQUMxQixLQUEwQixFQUMxQixPQUEyQjtRQUUzQixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN4QyxPQUFPLE1BQU0sTUFBTSxDQUFDLFVBQVUsQ0FBQyxTQUFTLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQzdFLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7O09BZUc7SUFDSSxLQUFLLENBQUMsYUFBYSxDQUN4QixTQUFpQixFQUNqQixHQUF3QixFQUN4QixLQUEwQixFQUMxQixRQUE2QixFQUM3QixPQUE4QjtRQUU5QixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN4QyxPQUFPLE1BQU0sTUFBTSxDQUFDLGFBQWEsQ0FDL0IsU0FBUyxFQUNULEdBQUcsRUFDSCxLQUFLLEVBQ0wsUUFBUSxFQUNSLE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxHQUFHLENBQ2IsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7O09BZUc7SUFDSSxLQUFLLENBQUMsdUJBQXVCLENBQ2xDLFNBQWlCLEVBQ2pCLEdBQXdCLEVBQ3hCLEtBQTBCLEVBQzFCLFFBQTZCLEVBQzdCLE9BQXdDO1FBRXhDLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3hDLE9BQU8sTUFBTSxNQUFNLENBQUMsdUJBQXVCLENBQ3pDLFNBQVMsRUFDVCxHQUFHLEVBQ0gsS0FBSyxFQUNMLFFBQVEsRUFDUixPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsR0FBRyxDQUNiLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7OztPQWVHO0lBQ0ksS0FBSyxDQUFDLGtCQUFrQixDQUM3QixTQUFpQixFQUNqQixHQUF3QixFQUN4QixLQUEwQixFQUMxQixLQUEwQixFQUMxQixPQUFtQztRQUVuQyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN4QyxPQUFPLE1BQU0sTUFBTSxDQUFDLGtCQUFrQixDQUNwQyxTQUFTLEVBQ1QsR0FBRyxFQUNILEtBQUssRUFDTCxLQUFLLEVBQ0wsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLEdBQUcsQ0FDYixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSSxLQUFLLENBQUMsVUFBVSxDQUFDLFNBQWlCO1FBQ3ZDLE9BQU8sTUFBTSxJQUFJLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNJLEtBQUssQ0FBQyxlQUFlLENBQzFCLFNBQWlCLEVBQ2pCLGNBQXNCO1FBRXRCLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3hDLE9BQU8sTUFBTSxNQUFNLENBQUMsZUFBZSxDQUFDLFNBQVMsRUFBRSxjQUFjLENBQUMsQ0FBQztJQUNqRSxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQWtCRztJQUNJLEtBQUssQ0FBQyxTQUFTLENBQ3BCLFNBQWlCLEVBQ2pCLEtBQTBCLEVBQzFCLE1BQU0sR0FBRyxDQUFDLEVBQ1YsT0FBMEI7UUFFMUIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDeEMsT0FBTyxNQUFNLE1BQU0sQ0FBQyxTQUFTLENBQUMsU0FBUyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3hFLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7O09BZUc7SUFDSSxLQUFLLENBQUMsa0JBQWtCLENBQzdCLFNBQWlCLEVBQ2pCLGNBQXNCLEVBQ3RCLEtBQTBCLEVBQzFCLEtBQTBCLEVBQzFCLE9BQW1DO1FBRW5DLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3hDLE9BQU8sTUFBTSxNQUFNLENBQUMsa0JBQWtCLENBQ3BDLFNBQVMsRUFDVCxjQUFjLEVBQ2QsS0FBSyxFQUNMLEtBQUssRUFDTCxPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsR0FBRyxDQUNiLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7OztPQWVHO0lBQ0ksS0FBSyxDQUFDLG1CQUFtQixDQUM5QixTQUFpQixFQUNqQixjQUFzQixFQUN0QixRQUd3QyxFQUN4QyxPQUFvQztRQUVwQyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN4QyxPQUFPLE1BQU0sTUFBTSxDQUFDLG1CQUFtQixDQUNyQyxTQUFTLEVBQ1QsY0FBYyxFQUNkLFFBQVEsRUFDUixPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsR0FBRyxDQUNiLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7O09BV0c7SUFDSSxLQUFLLENBQUMsa0JBQWtCLENBQzdCLFNBQWlCLEVBQ2pCLGNBQXNCLEVBQ3RCLEtBQTBCO1FBRTFCLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3hDLE9BQU8sTUFBTSxNQUFNLENBQUMsa0JBQWtCLENBQUMsU0FBUyxFQUFFLGNBQWMsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUMzRSxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7O09BV0c7SUFDSSxLQUFLLENBQUMsbUJBQW1CLENBQzlCLFNBQWlCLEVBQ2pCLGNBQXNCLEVBQ3RCLE1BQStCO1FBRS9CLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3hDLE9BQU8sTUFBTSxNQUFNLENBQUMsbUJBQW1CLENBQUMsU0FBUyxFQUFFLGNBQWMsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUM3RSxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7OztPQVlHO0lBQ0ksS0FBSyxDQUFDLHFCQUFxQixDQUNoQyxTQUFpQixFQUNqQixjQUFzQixFQUN0QixLQUEwQjtRQUUxQixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN4QyxPQUFPLE1BQU0sTUFBTSxDQUFDLHFCQUFxQixDQUFDLFNBQVMsRUFBRSxjQUFjLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDOUUsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7T0FZRztJQUNJLEtBQUssQ0FBQyxzQkFBc0IsQ0FDakMsU0FBaUIsRUFDakIsY0FBc0IsRUFDdEIsTUFBK0I7UUFFL0IsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDeEMsT0FBTyxNQUFNLE1BQU0sQ0FBQyxzQkFBc0IsQ0FDeEMsU0FBUyxFQUNULGNBQWMsRUFDZCxNQUFNLENBQ1AsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BcUJHO0lBQ0ksS0FBSyxDQUFDLG1CQUFtQixDQUM5QixTQUFpQixFQUNqQixjQUFzQixFQUN0QixLQUEwQixFQUMxQixNQUFNLEdBQUcsQ0FBQyxFQUNWLE9BQW9DO1FBRXBDLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3hDLE9BQU8sTUFBTSxNQUFNLENBQUMsbUJBQW1CLENBQ3JDLFNBQVMsRUFDVCxjQUFjLEVBQ2QsS0FBSyxFQUNMLE1BQU0sRUFDTixPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsR0FBRyxDQUNiLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0ksS0FBSyxDQUFDLGdCQUFnQixDQUMzQixTQUFpQixFQUNqQixjQUFzQjtRQUV0QixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN4QyxPQUFPLE1BQU0sTUFBTSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxjQUFjLENBQUMsQ0FBQztJQUNsRSxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7T0FnQkc7SUFDSSxLQUFLLENBQUMsbUJBQW1CLENBQzlCLFNBQWlCLEVBQ2pCLGFBQXFCLEVBQ3JCLEtBQTBCLEVBQzFCLEtBQWEsRUFDYixPQUFvQztRQUVwQyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN4QyxPQUFPLE1BQU0sTUFBTSxDQUFDLG1CQUFtQixDQUNyQyxTQUFTLEVBQ1QsYUFBYSxFQUNiLEtBQUssRUFDTCxLQUFLLEVBQ0wsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLEdBQUcsQ0FDYixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7T0FlRztJQUNJLEtBQUssQ0FBQyxvQkFBb0IsQ0FDL0IsU0FBaUIsRUFDakIsYUFBcUIsRUFDckIsUUFHMkIsRUFDM0IsT0FBcUM7UUFFckMsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDeEMsT0FBTyxNQUFNLE1BQU0sQ0FBQyxvQkFBb0IsQ0FDdEMsU0FBUyxFQUNULGFBQWEsRUFDYixRQUFRLEVBQ1IsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLEdBQUcsQ0FDYixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FrQkc7SUFDSSxLQUFLLENBQUMsb0JBQW9CLENBQy9CLFNBQWlCLEVBQ2pCLGFBQXFCLEVBQ3JCLE9BQXFDOztRQUVyQyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN4QyxPQUFPLE1BQU0sTUFBTSxDQUFDLG9CQUFvQixDQUN0QyxTQUFTLEVBQ1QsYUFBYSxFQUNiLE1BQUEsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLEtBQUssbUNBQUksc0JBQWMsQ0FBQyxTQUFTLEVBQzFDLE1BQUEsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLFNBQVMsbUNBQUksQ0FBQyxFQUN2QixPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsT0FBTyxDQUNqQixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bc0JHO0lBQ0ksS0FBSyxDQUFDLHFCQUFxQixDQUNoQyxTQUFpQixFQUNqQixhQUFxQixFQUNyQixPQUFzQzs7UUFFdEMsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDeEMsT0FBTyxNQUFNLE1BQU0sQ0FBQyxxQkFBcUIsQ0FDdkMsU0FBUyxFQUNULGFBQWEsRUFDYixNQUFBLE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxLQUFLLG1DQUFJLHNCQUFjLENBQUMsU0FBUyxFQUMxQyxPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsUUFBUSxFQUNqQixPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsUUFBUSxFQUNqQixPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsTUFBTSxFQUNmLE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxLQUFLLENBQ2YsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7OztPQWFHO0lBQ0ksS0FBSyxDQUFDLGdCQUFnQixDQUMzQixTQUFpQixFQUNqQixhQUFxQixFQUNyQixLQUEwQixFQUMxQixPQUFpQztRQUVqQyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN4QyxPQUFPLE1BQU0sTUFBTSxDQUFDLGdCQUFnQixDQUNsQyxTQUFTLEVBQ1QsYUFBYSxFQUNiLEtBQUssRUFDTCxPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsS0FBSyxDQUNmLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNJLEtBQUssQ0FBQyxpQkFBaUIsQ0FDNUIsU0FBaUIsRUFDakIsYUFBcUIsRUFDckIsS0FBMEI7UUFFMUIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDeEMsT0FBTyxNQUFNLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLEVBQUUsYUFBYSxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ3pFLENBQUM7SUFFRDs7Ozs7Ozs7OztPQVVHO0lBQ0ksS0FBSyxDQUFDLGtCQUFrQixDQUM3QixTQUFpQixFQUNqQixhQUFxQixFQUNyQixNQUErQjtRQUUvQixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN4QyxPQUFPLE1BQU0sTUFBTSxDQUFDLGtCQUFrQixDQUFDLFNBQVMsRUFBRSxhQUFhLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDM0UsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FrQkc7SUFDSSxLQUFLLENBQUMsdUJBQXVCLENBQ2xDLFNBQWlCLEVBQ2pCLGFBQXFCLEVBQ3JCLEtBQTBCLEVBQzFCLE1BQWUsRUFDZixPQUFtQztRQUVuQyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN4QyxPQUFPLE1BQU0sTUFBTSxDQUFDLHVCQUF1QixDQUN6QyxTQUFTLEVBQ1QsYUFBYSxFQUNiLEtBQUssRUFDTCxNQUFNLElBQUksQ0FBQyxFQUNYLE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxHQUFHLENBQ2IsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNJLEtBQUssQ0FBQyxzQkFBc0IsQ0FDakMsU0FBaUIsRUFDakIsYUFBcUIsRUFDckIsS0FBMEI7UUFFMUIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDeEMsT0FBTyxNQUFNLE1BQU0sQ0FBQyxzQkFBc0IsQ0FBQyxTQUFTLEVBQUUsYUFBYSxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQzlFLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNJLEtBQUssQ0FBQyx1QkFBdUIsQ0FDbEMsU0FBaUIsRUFDakIsYUFBcUIsRUFDckIsTUFBK0I7UUFFL0IsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDeEMsT0FBTyxNQUFNLE1BQU0sQ0FBQyx1QkFBdUIsQ0FDekMsU0FBUyxFQUNULGFBQWEsRUFDYixNQUFNLENBQ1AsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNJLEtBQUssQ0FBQyxlQUFlLENBQzFCLFNBQWlCLEVBQ2pCLGFBQXFCO1FBRXJCLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3hDLE9BQU8sTUFBTSxNQUFNLENBQUMsZUFBZSxDQUFDLFNBQVMsRUFBRSxhQUFhLENBQUMsQ0FBQztJQUNoRSxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7O09BV0c7SUFDSSxLQUFLLENBQUMsc0JBQXNCLENBQ2pDLFNBQWlCLEVBQ2pCLGFBQXFCLEVBQ3JCLE9BQXVDO1FBRXZDLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3hDLE9BQU8sTUFBTSxNQUFNLENBQUMsc0JBQXNCLENBQ3hDLFNBQVMsRUFDVCxhQUFhLEVBQ2IsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLFFBQVEsRUFDakIsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLFFBQVEsQ0FDbEIsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNJLEtBQUssQ0FBQyxXQUFXLENBQ3RCLFNBQWlCLEVBQ2pCLEdBQXdCO1FBRXhCLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3hDLE9BQU8sTUFBTSxNQUFNLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSSxLQUFLLENBQUMsVUFBVSxDQUNyQixTQUFpQixFQUNqQixHQUF3QjtRQUV4QixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN4QyxPQUFPLE1BQU0sTUFBTSxDQUFDLFVBQVUsQ0FBQyxTQUFTLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDakQsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSSxLQUFLLENBQUMsU0FBUyxDQUNwQixTQUFpQixFQUNqQixHQUF3QjtRQUV4QixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN4QyxPQUFPLE1BQU0sTUFBTSxDQUFDLFNBQVMsQ0FBQyxTQUFTLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSSxLQUFLLENBQUMsU0FBUyxDQUNwQixTQUFpQixFQUNqQixJQUE2QjtRQUU3QixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN4QyxPQUFPLE1BQU0sTUFBTSxDQUFDLFNBQVMsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDakQsQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNJLEtBQUssQ0FBQyxTQUFTLENBQ3BCLFNBQWlCLEVBQ2pCLEdBQXdCLEVBQ3hCLGVBQXVCO1FBRXZCLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3hDLE9BQU8sTUFBTSxNQUFNLENBQUMsU0FBUyxDQUFDLFNBQVMsRUFBRSxHQUFHLEVBQUUsZUFBZSxDQUFDLENBQUM7SUFDakUsQ0FBQztJQUVEOzs7Ozs7Ozs7O09BVUc7SUFDSSxLQUFLLENBQUMsV0FBVyxDQUN0QixTQUFpQixFQUNqQixHQUF3QixFQUN4QixlQUF1QjtRQUV2QixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN4QyxPQUFPLE1BQU0sTUFBTSxDQUFDLFdBQVcsQ0FBQyxTQUFTLEVBQUUsR0FBRyxFQUFFLGVBQWUsQ0FBQyxDQUFDO0lBQ25FLENBQUM7SUFFRDs7Ozs7Ozs7OztPQVVHO0lBQ0ksS0FBSyxDQUFDLFdBQVcsQ0FDdEIsU0FBaUIsRUFDakIsR0FBd0IsRUFDeEIsZUFBdUI7UUFFdkIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDeEMsT0FBTyxNQUFNLE1BQU0sQ0FBQyxXQUFXLENBQUMsU0FBUyxFQUFFLEdBQUcsRUFBRSxlQUFlLENBQUMsQ0FBQztJQUNuRSxDQUFDO0lBRU8saUJBQWlCO1FBQ3ZCLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUM7UUFDMUQsSUFBSSxDQUFDLG1CQUFtQjtZQUN0QixDQUFDLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQztRQUMzRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0NBR0Y7QUF0bERELGtEQXNsREMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDcmVhdGVDYWNoZSxcbiAgRGVsZXRlQ2FjaGUsXG4gIExpc3RDYWNoZXMsXG4gIENhY2hlRmx1c2gsXG4gIENhY2hlR2V0LFxuICBDYWNoZVNldCxcbiAgQ2FjaGVEZWxldGUsXG4gIENhY2hlSW5jcmVtZW50LFxuICBJbmNyZW1lbnRPcHRpb25zLFxuICBDYWNoZVNldElmTm90RXhpc3RzLFxuICBTZXRJZk5vdEV4aXN0c09wdGlvbnMsXG4gIFNldElmQWJzZW50T3B0aW9ucyxcbiAgU2V0SWZQcmVzZW50T3B0aW9ucyxcbiAgU2V0SWZFcXVhbE9wdGlvbnMsXG4gIFNldElmTm90RXF1YWxPcHRpb25zLFxuICBTZXRJZlByZXNlbnRBbmROb3RFcXVhbE9wdGlvbnMsXG4gIFNldElmQWJzZW50T3JFcXVhbE9wdGlvbnMsXG4gIENhY2hlU2V0RmV0Y2gsXG4gIENhY2hlU2V0QWRkRWxlbWVudCxcbiAgQ2FjaGVTZXRBZGRFbGVtZW50cyxcbiAgQ2FjaGVTZXRDb250YWluc0VsZW1lbnQsXG4gIENhY2hlU2V0Q29udGFpbnNFbGVtZW50cyxcbiAgQ2FjaGVTZXRSZW1vdmVFbGVtZW50LFxuICBDYWNoZVNldFJlbW92ZUVsZW1lbnRzLFxuICBDYWNoZUxpc3RGZXRjaCxcbiAgQ2FjaGVMaXN0TGVuZ3RoLFxuICBDYWNoZUxpc3RQdXNoRnJvbnQsXG4gIENhY2hlTGlzdFB1c2hCYWNrLFxuICBDYWNoZUxpc3RDb25jYXRlbmF0ZUJhY2ssXG4gIENhY2hlTGlzdENvbmNhdGVuYXRlRnJvbnQsXG4gIENhY2hlTGlzdFBvcEJhY2ssXG4gIENhY2hlTGlzdFBvcEZyb250LFxuICBDYWNoZUxpc3RSZW1vdmVWYWx1ZSxcbiAgQ2FjaGVMaXN0UmV0YWluLFxuICBDYWNoZURpY3Rpb25hcnlTZXRGaWVsZCxcbiAgQ2FjaGVEaWN0aW9uYXJ5U2V0RmllbGRzLFxuICBDYWNoZURpY3Rpb25hcnlHZXRGaWVsZCxcbiAgQ2FjaGVEaWN0aW9uYXJ5R2V0RmllbGRzLFxuICBDYWNoZURpY3Rpb25hcnlJbmNyZW1lbnQsXG4gIENhY2hlRGljdGlvbmFyeUZldGNoLFxuICBDYWNoZURpY3Rpb25hcnlSZW1vdmVGaWVsZCxcbiAgQ2FjaGVEaWN0aW9uYXJ5UmVtb3ZlRmllbGRzLFxuICBDYWNoZURpY3Rpb25hcnlMZW5ndGgsXG4gIENhY2hlU29ydGVkU2V0RmV0Y2gsXG4gIENhY2hlU29ydGVkU2V0UHV0RWxlbWVudCxcbiAgQ2FjaGVTb3J0ZWRTZXRQdXRFbGVtZW50cyxcbiAgQ2FjaGVTb3J0ZWRTZXRHZXRSYW5rLFxuICBDYWNoZVNvcnRlZFNldEdldFNjb3JlLFxuICBDYWNoZVNvcnRlZFNldEdldFNjb3JlcyxcbiAgQ2FjaGVTb3J0ZWRTZXRJbmNyZW1lbnRTY29yZSxcbiAgQ2FjaGVTb3J0ZWRTZXRSZW1vdmVFbGVtZW50LFxuICBDYWNoZVNvcnRlZFNldFJlbW92ZUVsZW1lbnRzLFxuICBDYWNoZVNvcnRlZFNldExlbmd0aCxcbiAgQ2FjaGVTb3J0ZWRTZXRMZW5ndGhCeVNjb3JlLFxuICBTb3J0ZWRTZXRPcmRlcixcbiAgQ2FjaGVJdGVtR2V0VHRsLFxuICBDYWNoZUl0ZW1HZXRUeXBlLFxuICBDYWNoZUtleUV4aXN0cyxcbiAgQ2FjaGVLZXlzRXhpc3QsXG4gIENhY2hlVXBkYXRlVHRsLFxuICBDYWNoZUluY3JlYXNlVHRsLFxuICBDYWNoZURlY3JlYXNlVHRsLFxuICBDYWNoZUdldEJhdGNoLFxuICBDYWNoZVNldEJhdGNoLFxuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgQ2FjaGVTZXRJZkFic2VudCxcbiAgQ2FjaGVTZXRJZlByZXNlbnQsXG4gIENhY2hlU2V0SWZFcXVhbCxcbiAgQ2FjaGVTZXRJZk5vdEVxdWFsLFxuICBDYWNoZVNldElmUHJlc2VudEFuZE5vdEVxdWFsLFxuICBDYWNoZVNldElmQWJzZW50T3JFcXVhbCxcbiAgQ2FjaGVTZXRTYW1wbGUsXG4gIENhY2hlU2V0UG9wLFxuICBDYWNoZVNldExlbmd0aCxcbn0gZnJvbSAnLi4vLi4vLi4vaW5kZXgnO1xuaW1wb3J0IHtcbiAgTGlzdEZldGNoQ2FsbE9wdGlvbnMsXG4gIExpc3RSZXRhaW5DYWxsT3B0aW9ucyxcbiAgU2V0QmF0Y2hJdGVtLFxufSBmcm9tICcuLi8uLi8uLi91dGlscyc7XG5pbXBvcnQge1xuICBJQ2FjaGVDbGllbnQsXG4gIFNldE9wdGlvbnMsXG4gIFNldEFkZEVsZW1lbnRPcHRpb25zLFxuICBTZXRBZGRFbGVtZW50c09wdGlvbnMsXG4gIExpc3RQdXNoRnJvbnRPcHRpb25zLFxuICBMaXN0UHVzaEJhY2tPcHRpb25zLFxuICBMaXN0Q29uY2F0ZW5hdGVCYWNrT3B0aW9ucyxcbiAgTGlzdENvbmNhdGVuYXRlRnJvbnRPcHRpb25zLFxuICBEaWN0aW9uYXJ5U2V0RmllbGRPcHRpb25zLFxuICBEaWN0aW9uYXJ5U2V0RmllbGRzT3B0aW9ucyxcbiAgRGljdGlvbmFyeUluY3JlbWVudE9wdGlvbnMsXG4gIFNvcnRlZFNldEZldGNoQnlSYW5rT3B0aW9ucyxcbiAgU29ydGVkU2V0UHV0RWxlbWVudE9wdGlvbnMsXG4gIFNvcnRlZFNldFB1dEVsZW1lbnRzT3B0aW9ucyxcbiAgU29ydGVkU2V0RmV0Y2hCeVNjb3JlT3B0aW9ucyxcbiAgU29ydGVkU2V0R2V0UmFua09wdGlvbnMsXG4gIFNvcnRlZFNldEluY3JlbWVudE9wdGlvbnMsXG4gIFNvcnRlZFNldExlbmd0aEJ5U2NvcmVPcHRpb25zLFxuICBTZXRCYXRjaE9wdGlvbnMsXG4gIEdldE9wdGlvbnMsXG4gIEdldEJhdGNoT3B0aW9ucyxcbn0gZnJvbSAnLi4vLi4vLi4vY2xpZW50cy9JQ2FjaGVDbGllbnQnO1xuaW1wb3J0IHtJQ29udHJvbENsaWVudH0gZnJvbSAnLi9JQ29udHJvbENsaWVudCc7XG5pbXBvcnQge0lEYXRhQ2xpZW50fSBmcm9tICcuL0lEYXRhQ2xpZW50JztcbmltcG9ydCB7SVBpbmdDbGllbnR9IGZyb20gJy4vSVBpbmdDbGllbnQnO1xuaW1wb3J0IHtJTW9tZW50b0NhY2hlfSBmcm9tICcuLi8uLi8uLi9jbGllbnRzL0lNb21lbnRvQ2FjaGUnO1xuaW1wb3J0IHtNb21lbnRvQ2FjaGV9IGZyb20gJy4vbW9tZW50by1jYWNoZSc7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBYnN0cmFjdENhY2hlQ2xpZW50IGltcGxlbWVudHMgSUNhY2hlQ2xpZW50IHtcbiAgLy8gbWFraW5nIHRoZXNlIHByb3RlY3RlZCB1bnRpbCB3ZSBmdWxseSBhYnN0cmFjdCBhd2F5IHRoZSBub2RlanMgY2xpZW50XG4gIHByb3RlY3RlZCByZWFkb25seSBjb250cm9sQ2xpZW50OiBJQ29udHJvbENsaWVudDtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGRhdGFDbGllbnRzOiBJRGF0YUNsaWVudFtdO1xuICAvLyBUT0RPOiBNYWtlIHBpbmdDbGllbnQgcmVxdWlyZWQgaWYgYW5kIHdoZW4gdGhlIG5vZGVqcyBzaWRlIHN0YXJ0cyBhZGRpbmdcbiAgLy8gIG9uZSBhcyB3ZWxsXG4gIHByb3RlY3RlZCByZWFkb25seSBwaW5nQ2xpZW50PzogSVBpbmdDbGllbnQ7XG4gIHByaXZhdGUgbmV4dERhdGFDbGllbnRJbmRleDogbnVtYmVyO1xuXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihcbiAgICBjb250cm9sQ2xpZW50OiBJQ29udHJvbENsaWVudCxcbiAgICBkYXRhQ2xpZW50czogSURhdGFDbGllbnRbXSxcbiAgICBwaW5nQ2xpZW50PzogSVBpbmdDbGllbnRcbiAgKSB7XG4gICAgdGhpcy5jb250cm9sQ2xpZW50ID0gY29udHJvbENsaWVudDtcbiAgICB0aGlzLmRhdGFDbGllbnRzID0gZGF0YUNsaWVudHM7XG4gICAgdGhpcy5waW5nQ2xpZW50ID0gcGluZ0NsaWVudDtcblxuICAgIC8vIFdlIHJvdW5kLXJvYmluIHRoZSByZXF1ZXN0cyB0aHJvdWdoIGFsbCBvZiBvdXIgY2xpZW50cy4gIFNpbmNlIGphdmFzY3JpcHRcbiAgICAvLyBpcyBzaW5nbGUtdGhyZWFkZWQsIHdlIGRvbid0IGhhdmUgdG8gd29ycnkgYWJvdXQgdGhyZWFkIHNhZmV0eSBvbiB0aGlzXG4gICAgLy8gaW5kZXggdmFyaWFibGUuXG4gICAgdGhpcy5uZXh0RGF0YUNsaWVudEluZGV4ID0gMDtcbiAgfVxuXG4gIHB1YmxpYyBjYWNoZShjYWNoZU5hbWU6IHN0cmluZyk6IElNb21lbnRvQ2FjaGUge1xuICAgIHJldHVybiBuZXcgTW9tZW50b0NhY2hlKHRoaXMsIGNhY2hlTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogUGluZyB0aGUgc2VydmljZSB0byB2ZXJpZnkgaXQgaXMgdXAgYW5kIHJ1bm5pbmdcbiAgICovXG4gIHB1YmxpYyBhc3luYyBwaW5nKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnBpbmdDbGllbnQ/LnBpbmcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2FjaGUgaWYgaXQgZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgdG8gYmUgY3JlYXRlZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q3JlYXRlQ2FjaGUuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDcmVhdGVDYWNoZS5TdWNjZXNzfSBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ3JlYXRlQ2FjaGUuQWxyZWFkeUV4aXN0c30gaWYgdGhlIGNhY2hlIGFscmVhZHkgZXhpc3RzLlxuICAgKiB7QGxpbmsgQ3JlYXRlQ2FjaGUuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgY3JlYXRlQ2FjaGUoY2FjaGVOYW1lOiBzdHJpbmcpOiBQcm9taXNlPENyZWF0ZUNhY2hlLlJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY29udHJvbENsaWVudC5jcmVhdGVDYWNoZShjYWNoZU5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBjYWNoZSBhbmQgYWxsIGl0ZW1zIHN0b3JlZCBpbiBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSB0byBkZWxldGUuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPERlbGV0ZUNhY2hlLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgRGVsZXRlQ2FjaGUuU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIERlbGV0ZUNhY2hlLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRlbGV0ZUNhY2hlKGNhY2hlTmFtZTogc3RyaW5nKTogUHJvbWlzZTxEZWxldGVDYWNoZS5SZXNwb25zZT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbnRyb2xDbGllbnQuZGVsZXRlQ2FjaGUoY2FjaGVOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0cyBhbGwgY2FjaGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxMaXN0Q2FjaGVzLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgTGlzdENhY2hlcy5TdWNjZXNzfSBjb250YWluaW5nIHRoZSBsaXN0IG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBMaXN0Q2FjaGVzLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGxpc3RDYWNoZXMoKTogUHJvbWlzZTxMaXN0Q2FjaGVzLlJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY29udHJvbENsaWVudC5saXN0Q2FjaGVzKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdmFsdWUgc3RvcmVkIGZvciB0aGUgZ2l2ZW4ga2V5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIHRvIHBlcmZvcm0gdGhlIGxvb2t1cCBpbi5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSBrZXkgLSBUaGUga2V5IHRvIGxvb2sgdXAuXG4gICAqIEBwYXJhbSB7R2V0T3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7ZGVjb21wcmVzc30gW29wdGlvbnMuZGVjb21wcmVzcz1mYWxzZV0gLSBXaGV0aGVyIHRvIGRlY29tcHJlc3MgdGhlIHZhbHVlLiBPdmVycmlkZXMgdGhlIGNsaWVudC13aWRlXG4gICAqIGF1dG9tYXRpYyBkZWNvbXByZXNzaW9uIHNldHRpbmcuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlR2V0LlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVHZXQuSGl0fSBjb250YWluaW5nIHRoZSB2YWx1ZSBpZiBvbmUgaXMgZm91bmQuXG4gICAqIHtAbGluayBDYWNoZUdldC5NaXNzfSBpZiB0aGUga2V5IGRvZXMgbm90IGV4aXN0LlxuICAgKiB7QGxpbmsgQ2FjaGVHZXQuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZ2V0KFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGtleTogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgICBvcHRpb25zPzogR2V0T3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlR2V0LlJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKS5nZXQoY2FjaGVOYW1lLCBrZXksIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc29jaWF0ZXMgdGhlIGdpdmVuIGtleSB3aXRoIHRoZSBnaXZlbiB2YWx1ZS4gSWYgYSB2YWx1ZSBmb3IgdGhlIGtleSBpc1xuICAgKiBhbHJlYWR5IHByZXNlbnQgaXQgaXMgcmVwbGFjZWQgd2l0aCB0aGUgbmV3IHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIHRvIHN0b3JlIHRoZSB2YWx1ZSBpbi5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSBrZXkgLSBUaGUga2V5IHRvIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBiZSBzdG9yZWQuXG4gICAqIEBwYXJhbSB7U2V0T3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50dGxdIC0gVGhlIHRpbWUgdG8gbGl2ZSBmb3IgdGhlIGl0ZW0gaW4gdGhlIGNhY2hlLlxuICAgKiBVc2VzIHRoZSBjbGllbnQncyBkZWZhdWx0IFRUTCBpZiB0aGlzIGlzIG5vdCBzdXBwbGllZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jb21wcmVzcz1mYWxzZV0gLSBXaGV0aGVyIHRvIGNvbXByZXNzIHRoZSB2YWx1ZS4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlU2V0LlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVTZXQuU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlU2V0LkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNldChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBrZXk6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgdmFsdWU6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgb3B0aW9ucz86IFNldE9wdGlvbnNcbiAgKTogUHJvbWlzZTxDYWNoZVNldC5SZXNwb25zZT4ge1xuICAgIC8vIHRoaXMgdHlwZW9mIGNoZWNrIHdvdWxkbid0IGJlIG5lY2Vzc2FyeSBpbiBUUywgYnV0IGl0IGNhbiBoZWxwIGNhdGNoIGJ1Z3MgaW4gSlMgY29kZSBhdCBydW50aW1lLlxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgICAgJ09wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3Qgd2l0aCBhIHR0bCBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5zZXQoY2FjaGVOYW1lLCBrZXksIHZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBrZXkgZnJvbSB0aGUgY2FjaGUuIFRoZSBrZXkgY2FuIHJlcHJlc2VudCBhIHNpbmdsZSB2YWx1ZVxuICAgKiBvciBhIGNvbGxlY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgdG8gZGVsZXRlIGZyb20uXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0ga2V5IC0gVGhlIGtleSB0byBkZWxldGUuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlRGVsZXRlLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVEZWxldGUuU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlRGVsZXRlLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRlbGV0ZShcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBrZXk6IHN0cmluZyB8IFVpbnQ4QXJyYXlcbiAgKTogUHJvbWlzZTxDYWNoZURlbGV0ZS5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LmRlbGV0ZShjYWNoZU5hbWUsIGtleSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdmFsdWUgc3RvcmVkIGZvciB0aGUgZ2l2ZW4ga2V5cy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSB0byBwZXJmb3JtIHRoZSBsb29rdXAgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nW10gfCBVaW50OEFycmF5W119IGtleXMgLSBUaGUgbGlzdCBvZiBrZXlzIHRvIGxvb2sgdXAuXG4gICAqIEBwYXJhbSB7R2V0QmF0Y2hPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtkZWNvbXByZXNzfSBbb3B0aW9ucy5kZWNvbXByZXNzPWZhbHNlXSAtIFdoZXRoZXIgdG8gZGVjb21wcmVzcyB0aGUgdmFsdWUuIE92ZXJyaWRlcyB0aGUgY2xpZW50LXdpZGVcbiAgICogYXV0b21hdGljIGRlY29tcHJlc3Npb24gc2V0dGluZy5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVHZXRCYXRjaC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlR2V0QmF0Y2guU3VjY2Vzc30gY29udGFpbmluZyB0aGUgdmFsdWVzIGlmIHRoZXkgd2VyZSBmb3VuZC5cbiAgICoge0BsaW5rIENhY2hlR2V0QmF0Y2guRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZ2V0QmF0Y2goXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAga2V5czogQXJyYXk8c3RyaW5nIHwgVWludDhBcnJheT4sXG4gICAgb3B0aW9ucz86IEdldEJhdGNoT3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlR2V0QmF0Y2guUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpLmdldEJhdGNoKGNhY2hlTmFtZSwga2V5cywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQXNzb2NpYXRlcyB0aGUgZ2l2ZW4ga2V5cyB3aXRoIHRoZSBnaXZlbiB2YWx1ZXMuIElmIGEgdmFsdWUgZm9yIHRoZSBrZXkgaXNcbiAgICogYWxyZWFkeSBwcmVzZW50IGl0IGlzIHJlcGxhY2VkIHdpdGggdGhlIG5ldyB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSB0byBzdG9yZSB0aGUgdmFsdWVzIGluLlxuICAgKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBTZXRCYXRjaEl0ZW0+IHwgTWFwPHN0cmluZyB8IFVpbnQ4QXJyYXksIHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBTZXRCYXRjaEl0ZW0+fSBpdGVtcyAtIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gYmUgc3RvcmVkLCB3aXRoIHRoZSBvcHRpb24gdG8gc2V0IGEgVFRMIHBlciBpdGVtLlxuICAgKiBAcGFyYW0ge1NldEJhdGNoT3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50dGxdIC0gVGhlIHRpbWUgdG8gbGl2ZSBmb3IgdGhlIGl0ZW1zIGluIHRoZSBjYWNoZS5cbiAgICogVXNlcyB0aGUgY2xpZW50J3MgZGVmYXVsdCBUVEwgaWYgdGhpcyBpcyBub3Qgc3VwcGxpZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY29tcHJlc3M9ZmFsc2VdIC0gV2hldGhlciB0byBjb21wcmVzcyB0aGUgdmFsdWUuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNldEJhdGNoLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVTZXRCYXRjaC5TdWNjZXNzfSBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVTZXRCYXRjaC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzZXRCYXRjaChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBpdGVtczpcbiAgICAgIHwgUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgVWludDhBcnJheT5cbiAgICAgIHwgTWFwPHN0cmluZyB8IFVpbnQ4QXJyYXksIHN0cmluZyB8IFVpbnQ4QXJyYXk+XG4gICAgICB8IEFycmF5PFNldEJhdGNoSXRlbT4sXG4gICAgb3B0aW9ucz86IFNldEJhdGNoT3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlU2V0QmF0Y2guUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5zZXRCYXRjaChjYWNoZU5hbWUsIGl0ZW1zLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIG11bHRpcGxlIGVsZW1lbnRzIHRvIHRoZSBiYWNrIG9mIHRoZSBnaXZlbiBsaXN0LiBDcmVhdGVzIHRoZSBsaXN0IGlmXG4gICAqIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgdG8gc3RvcmUgdGhlIGxpc3QgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsaXN0TmFtZSAtIFRoZSBsaXN0IHRvIGFkZCB0by5cbiAgICogQHBhcmFtIHtzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXX0gdmFsdWVzIC0gVGhlIGVsZW1lbnRzIHRvIGFkZCB0byB0aGUgbGlzdC5cbiAgICogQHBhcmFtIHtMaXN0Q29uY2F0ZW5hdGVCYWNrT3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50cnVuY2F0ZUZyb250VG9TaXplXSAtIElmIHRoZSBsaXN0IGV4Y2VlZHMgdGhpc1xuICAgKiBsZW5ndGgsIHJlbW92ZSBleGNlc3MgZnJvbSB0aGUgZnJvbnQgb2YgdGhlIGxpc3QuIE11c3QgYmUgcG9zaXRpdmUuXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvblR0bH0gW29wdGlvbnMudHRsXSAtIEhvdyB0aGUgVFRMIHNob3VsZCBiZSBtYW5hZ2VkLlxuICAgKiBSZWZyZXNoZXMgdGhlIGxpc3QncyBUVEwgdXNpbmcgdGhlIGNsaWVudCdzIGRlZmF1bHQgaWYgdGhpcyBpcyBub3RcbiAgICogc3VwcGxpZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlTGlzdENvbmNhdGVuYXRlQmFjay5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlTGlzdENvbmNhdGVuYXRlQmFjay5TdWNjZXNzfSBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVMaXN0Q29uY2F0ZW5hdGVCYWNrLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGxpc3RDb25jYXRlbmF0ZUJhY2soXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgbGlzdE5hbWU6IHN0cmluZyxcbiAgICB2YWx1ZXM6IHN0cmluZ1tdIHwgVWludDhBcnJheVtdLFxuICAgIG9wdGlvbnM/OiBMaXN0Q29uY2F0ZW5hdGVCYWNrT3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlTGlzdENvbmNhdGVuYXRlQmFjay5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50Lmxpc3RDb25jYXRlbmF0ZUJhY2soXG4gICAgICBjYWNoZU5hbWUsXG4gICAgICBsaXN0TmFtZSxcbiAgICAgIHZhbHVlcyxcbiAgICAgIG9wdGlvbnM/LnRydW5jYXRlRnJvbnRUb1NpemUsXG4gICAgICBvcHRpb25zPy50dGxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgbXVsdGlwbGUgZWxlbWVudHMgdG8gdGhlIGZyb250IG9mIHRoZSBnaXZlbiBsaXN0LiBDcmVhdGVzIHRoZSBsaXN0IGlmXG4gICAqIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgdG8gc3RvcmUgdGhlIGxpc3QgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsaXN0TmFtZSAtIFRoZSBsaXN0IHRvIGFkZCB0by5cbiAgICogQHBhcmFtIHtzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXX0gdmFsdWVzIC0gVGhlIGVsZW1lbnRzIHRvIGFkZCB0byB0aGUgbGlzdC5cbiAgICogQHBhcmFtIHtMaXN0Q29uY2F0ZW5hdGVGcm9udE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudHJ1bmNhdGVCYWNrVG9TaXplXSAtIElmIHRoZSBsaXN0IGV4Y2VlZHMgdGhpc1xuICAgKiBsZW5ndGgsIHJlbW92ZSBleGNlc3MgZnJvbSB0aGUgYmFjayBvZiB0aGUgbGlzdC4gTXVzdCBiZSBwb3NpdGl2ZS5cbiAgICogQHBhcmFtIHtDb2xsZWN0aW9uVHRsfSBbb3B0aW9ucy50dGxdIC0gSG93IHRoZSBUVEwgc2hvdWxkIGJlIG1hbmFnZWQuXG4gICAqIFJlZnJlc2hlcyB0aGUgbGlzdCdzIFRUTCB1c2luZyB0aGUgY2xpZW50J3MgZGVmYXVsdCBpZiB0aGlzIGlzIG5vdFxuICAgKiBzdXBwbGllZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVMaXN0Q29uY2F0ZW5hdGVGcm9udC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlTGlzdENvbmNhdGVuYXRlRnJvbnQuU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlTGlzdENvbmNhdGVuYXRlRnJvbnQuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgbGlzdENvbmNhdGVuYXRlRnJvbnQoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgbGlzdE5hbWU6IHN0cmluZyxcbiAgICB2YWx1ZXM6IHN0cmluZ1tdIHwgVWludDhBcnJheVtdLFxuICAgIG9wdGlvbnM/OiBMaXN0Q29uY2F0ZW5hdGVGcm9udE9wdGlvbnNcbiAgKTogUHJvbWlzZTxDYWNoZUxpc3RDb25jYXRlbmF0ZUZyb250LlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQubGlzdENvbmNhdGVuYXRlRnJvbnQoXG4gICAgICBjYWNoZU5hbWUsXG4gICAgICBsaXN0TmFtZSxcbiAgICAgIHZhbHVlcyxcbiAgICAgIG9wdGlvbnM/LnRydW5jYXRlQmFja1RvU2l6ZSxcbiAgICAgIG9wdGlvbnM/LnR0bFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2hlcyBhbGwgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGxpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgbGlzdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxpc3ROYW1lIC0gVGhlIGxpc3QgdG8gZmV0Y2guXG4gICAqIEBwYXJhbSB7TGlzdEZldGNoQ2FsbE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3RhcnRJbmRleF0gLSBTdGFydCBpbmNsdXNpdmUgaW5kZXggZm9yIGZldGNoIG9wZXJhdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmVuZEluZGV4XSAtIEVuZCBleGNsdXNpdmUgaW5kZXggZm9yIGZldGNoIG9wZXJhdGlvbi5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVMaXN0RmV0Y2guUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZUxpc3RGZXRjaC5IaXR9IGNvbnRhaW5pbmcgdGhlIGxpc3QgZWxlbWVudHMgaWYgdGhlIGxpc3QgZXhpc3RzLlxuICAgKiB7QGxpbmsgQ2FjaGVMaXN0RmV0Y2guTWlzc30gaWYgdGhlIGxpc3QgZG9lcyBub3QgZXhpc3QuXG4gICAqIHtAbGluayBDYWNoZUxpc3RGZXRjaC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBsaXN0RmV0Y2goXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgbGlzdE5hbWU6IHN0cmluZyxcbiAgICBvcHRpb25zPzogTGlzdEZldGNoQ2FsbE9wdGlvbnNcbiAgKTogUHJvbWlzZTxDYWNoZUxpc3RGZXRjaC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50Lmxpc3RGZXRjaChcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIGxpc3ROYW1lLFxuICAgICAgb3B0aW9ucz8uc3RhcnRJbmRleCxcbiAgICAgIG9wdGlvbnM/LmVuZEluZGV4XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGdpdmVuIGxpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgbGlzdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxpc3ROYW1lIC0gVGhlIGxpc3QgdG8gZ2V0IHRoZSBsZW5ndGggb2YuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlTGlzdExlbmd0aC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlTGlzdExlbmd0aC5IaXR9IGNvbnRhaW5pbmcgdGhlIGxlbmd0aCBpZiB0aGUgbGlzdCBleGlzdHMuXG4gICAqIHtAbGluayBDYWNoZUxpc3RMZW5ndGguTWlzc30gaWYgdGhlIGxpc3QgZG9lcyBub3QgZXhpc3QuXG4gICAqIHtAbGluayBDYWNoZUxpc3RMZW5ndGguRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgbGlzdExlbmd0aChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBsaXN0TmFtZTogc3RyaW5nXG4gICk6IFByb21pc2U8Q2FjaGVMaXN0TGVuZ3RoLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQubGlzdExlbmd0aChjYWNoZU5hbWUsIGxpc3ROYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuZCByZW1vdmVzIHRoZSBsYXN0IHZhbHVlIGZyb20gdGhlIGdpdmVuIGxpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgbGlzdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxpc3ROYW1lIC0gVGhlIGxpc3QgdG8gcG9wLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZUxpc3RQb3BCYWNrLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVMaXN0UG9wQmFjay5IaXR9IGNvbnRhaW5pbmcgdGhlIGVsZW1lbnQgaWYgdGhlIGxpc3QgZXhpc3RzLlxuICAgKiB7QGxpbmsgQ2FjaGVMaXN0UG9wQmFjay5NaXNzfSBpZiB0aGUgbGlzdCBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlTGlzdFBvcEJhY2suRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgbGlzdFBvcEJhY2soXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgbGlzdE5hbWU6IHN0cmluZ1xuICApOiBQcm9taXNlPENhY2hlTGlzdFBvcEJhY2suUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5saXN0UG9wQmFjayhjYWNoZU5hbWUsIGxpc3ROYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuZCByZW1vdmVzIHRoZSBmaXJzdCB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBsaXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIGxpc3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsaXN0TmFtZSAtIFRoZSBsaXN0IHRvIHBvcC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVMaXN0UG9wRnJvbnQuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZUxpc3RQb3BGcm9udC5IaXR9IGNvbnRhaW5pbmcgdGhlIGVsZW1lbnQgaWYgdGhlIGxpc3QgZXhpc3RzLlxuICAgKiB7QGxpbmsgQ2FjaGVMaXN0UG9wRnJvbnQuTWlzc30gaWYgdGhlIGxpc3QgZG9lcyBub3QgZXhpc3QuXG4gICAqIHtAbGluayBDYWNoZUxpc3RQb3BGcm9udC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBsaXN0UG9wRnJvbnQoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgbGlzdE5hbWU6IHN0cmluZ1xuICApOiBQcm9taXNlPENhY2hlTGlzdFBvcEZyb250LlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQubGlzdFBvcEZyb250KGNhY2hlTmFtZSwgbGlzdE5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gZWxlbWVudCB0byB0aGUgYmFjayBvZiB0aGUgZ2l2ZW4gbGlzdC4gQ3JlYXRlcyB0aGUgbGlzdCBpZlxuICAgKiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIHRvIHN0b3JlIHRoZSBsaXN0IGluLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGlzdE5hbWUgLSBUaGUgbGlzdCB0byBwdXNoIHRvLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHB1c2guXG4gICAqIEBwYXJhbSB7TGlzdFB1c2hCYWNrT3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50cnVuY2F0ZUZyb250VG9TaXplXSAtIElmIHRoZSBsaXN0IGV4Y2VlZHMgdGhpc1xuICAgKiBsZW5ndGgsIHJlbW92ZSBleGNlc3MgZnJvbSB0aGUgZnJvbnQgb2YgdGhlIGxpc3QuIE11c3QgYmUgcG9zaXRpdmUuXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvblR0bH0gW29wdGlvbnMudHRsXSAtIEhvdyB0aGUgVFRMIHNob3VsZCBiZSBtYW5hZ2VkLlxuICAgKiBSZWZyZXNoZXMgdGhlIGxpc3QncyBUVEwgdXNpbmcgdGhlIGNsaWVudCdzIGRlZmF1bHQgaWYgdGhpcyBpcyBub3RcbiAgICogc3VwcGxpZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlTGlzdFB1c2hCYWNrLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVMaXN0UHVzaEJhY2suU3VjY2Vzc30gY29udGFpbmluZyB0aGUgbGlzdCdzIG5ldyBsZW5ndGggb25cbiAgICogc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlTGlzdFB1c2hCYWNrLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGxpc3RQdXNoQmFjayhcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBsaXN0TmFtZTogc3RyaW5nLFxuICAgIHZhbHVlOiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIG9wdGlvbnM/OiBMaXN0UHVzaEJhY2tPcHRpb25zXG4gICk6IFByb21pc2U8Q2FjaGVMaXN0UHVzaEJhY2suUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5saXN0UHVzaEJhY2soXG4gICAgICBjYWNoZU5hbWUsXG4gICAgICBsaXN0TmFtZSxcbiAgICAgIHZhbHVlLFxuICAgICAgb3B0aW9ucz8udHJ1bmNhdGVGcm9udFRvU2l6ZSxcbiAgICAgIG9wdGlvbnM/LnR0bFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBlbGVtZW50IHRvIHRoZSBmcm9udCBvZiB0aGUgZ2l2ZW4gbGlzdC4gQ3JlYXRlcyB0aGUgbGlzdCBpZlxuICAgKiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIHRvIHN0b3JlIHRoZSBsaXN0IGluLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGlzdE5hbWUgLSBUaGUgbGlzdCB0byBwdXNoIHRvLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHB1c2guXG4gICAqIEBwYXJhbSB7TGlzdFB1c2hGcm9udE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudHJ1bmNhdGVCYWNrVG9TaXplXSAtIElmIHRoZSBsaXN0IGV4Y2VlZHMgdGhpc1xuICAgKiBsZW5ndGgsIHJlbW92ZSBleGNlc3MgZnJvbSB0aGUgZW5kIG9mIHRoZSBsaXN0LiBNdXN0IGJlIHBvc2l0aXZlLlxuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25UdGx9IFtvcHRpb25zLnR0bF0gLSBIb3cgdGhlIFRUTCBzaG91bGQgYmUgbWFuYWdlZC5cbiAgICogUmVmcmVzaGVzIHRoZSBsaXN0J3MgVFRMIHVzaW5nIHRoZSBjbGllbnQncyBkZWZhdWx0IGlmIHRoaXMgaXMgbm90XG4gICAqIHN1cHBsaWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZUxpc3RQdXNoRnJvbnQuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZUxpc3RQdXNoRnJvbnQuU3VjY2Vzc30gY29udGFpbmluZyB0aGUgbGlzdCdzIG5ldyBsZW5ndGggb25cbiAgICogc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlTGlzdFB1c2hGcm9udC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBsaXN0UHVzaEZyb250KFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGxpc3ROYW1lOiBzdHJpbmcsXG4gICAgdmFsdWU6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgb3B0aW9ucz86IExpc3RQdXNoRnJvbnRPcHRpb25zXG4gICk6IFByb21pc2U8Q2FjaGVMaXN0UHVzaEZyb250LlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQubGlzdFB1c2hGcm9udChcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIGxpc3ROYW1lLFxuICAgICAgdmFsdWUsXG4gICAgICBvcHRpb25zPy50cnVuY2F0ZUJhY2tUb1NpemUsXG4gICAgICBvcHRpb25zPy50dGxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gdGhlIGdpdmVuIGxpc3QgZXF1YWwgdG8gdGhlIGdpdmVuIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIGxpc3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsaXN0TmFtZSAtIFRoZSBsaXN0IHRvIHJlbW92ZSBmcm9tLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVMaXN0UmVtb3ZlVmFsdWUuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZUxpc3RSZW1vdmVWYWx1ZS5TdWNjZXNzfSBvbiBzdWNjZXNzLiBSZW1vdmluZyBhbiBlbGVtZW50IHRoYXRcbiAgICogZG9lcyBub3Qgb2NjdXIgaW4gdGhlIGxpc3Qgb3IgcmVtb3ZpbmcgZnJvbSBhIG5vbi1leGlzdGVudCBsaXN0IGNvdW50cyBhcyBhXG4gICAqIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBDYWNoZUxpc3RSZW1vdmVWYWx1ZS5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBsaXN0UmVtb3ZlVmFsdWUoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgbGlzdE5hbWU6IHN0cmluZyxcbiAgICB2YWx1ZTogc3RyaW5nIHwgVWludDhBcnJheVxuICApOiBQcm9taXNlPENhY2hlTGlzdFJlbW92ZVZhbHVlLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQubGlzdFJlbW92ZVZhbHVlKGNhY2hlTmFtZSwgbGlzdE5hbWUsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRhaW5zIHNsaWNlIG9mIGVsZW1lbnRzIG9mIGEgZ2l2ZW4gbGlzdCwgZGVsZXRlcyB0aGUgcmVzdCBvZiB0aGUgbGlzdFxuICAgKiB0aGF0IGlzbid0IGJlaW5nIHJldGFpbmVkLiBSZXR1cm5zIGEgU3VjY2VzcyBvciBFcnJvci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBsaXN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGlzdE5hbWUgLSBUaGUgbGlzdCB0byByZXRhaW4gYSBzbGljZSBvZi5cbiAgICogQHBhcmFtIHtMaXN0UmV0YWluQ2FsbE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3RhcnRJbmRleF0gLSBTdGFydCBpbmNsdXNpdmUgaW5kZXggZm9yIGZldGNoXG4gICAqIG9wZXJhdGlvbi4gRGVmYXVsdHMgdG8gc3RhcnQgb2YgYXJyYXkgaWYgbm90IGdpdmVuLCAwLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZW5kSW5kZXhdIC0gRW5kIGV4Y2x1c2l2ZSBpbmRleCBmb3IgZmV0Y2hcbiAgICogb3BlcmF0aW9uLiBEZWZhdWx0cyB0byBlbmQgb2YgYXJyYXkgaWYgbm90IGdpdmVuLlxuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25UdGx9IFtvcHRpb25zLnR0bF0gLSBIb3cgdGhlIFRUTCBzaG91bGQgYmUgbWFuYWdlZC5cbiAgICogUmVmcmVzaGVzIHRoZSBsaXN0J3MgVFRMIHVzaW5nIHRoZSBjbGllbnQncyBkZWZhdWx0IGlmIHRoaXMgaXMgbm90XG4gICAqIHN1cHBsaWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZUxpc3RSZXRhaW4uUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZUxpc3RSZXRhaW4uU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlTGlzdFJldGFpbi5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBsaXN0UmV0YWluKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGxpc3ROYW1lOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IExpc3RSZXRhaW5DYWxsT3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlTGlzdFJldGFpbi5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50Lmxpc3RSZXRhaW4oXG4gICAgICBjYWNoZU5hbWUsXG4gICAgICBsaXN0TmFtZSxcbiAgICAgIG9wdGlvbnM/LnN0YXJ0SW5kZXgsXG4gICAgICBvcHRpb25zPy5lbmRJbmRleCxcbiAgICAgIG9wdGlvbnM/LnR0bFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2hlcyBhbGwgZWxlbWVudHMgb2YgdGhlIGdpdmVuIHNldFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNldE5hbWUgLSBUaGUgc2V0IHRvIGZldGNoLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNldEZldGNoLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVTZXRGZXRjaC5IaXR9IGNvbnRhaW5pbmcgdGhlIHNldCBlbGVtZW50cyBpZiB0aGUgc2V0IGV4aXN0cy5cbiAgICoge0BsaW5rIENhY2hlU2V0RmV0Y2guTWlzc30gaWYgdGhlIHNldCBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlU2V0RmV0Y2guRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc2V0RmV0Y2goXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgc2V0TmFtZTogc3RyaW5nXG4gICk6IFByb21pc2U8Q2FjaGVTZXRGZXRjaC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNldEZldGNoKGNhY2hlTmFtZSwgc2V0TmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBlbGVtZW50IHRvIHRoZSBnaXZlbiBzZXQuIENyZWF0ZXMgdGhlIHNldCBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5XG4gICAqIGV4aXN0LlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBBZnRlciB0aGlzIG9wZXJhdGlvbiB0aGUgc2V0IHdpbGwgY29udGFpbiB0aGUgdW5pb24gb2YgdGhlIGVsZW1lbnQgcGFzc2VkXG4gICAqIGluIGFuZCB0aGUgb3JpZ2luYWwgZWxlbWVudHMgb2YgdGhlIHNldC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSB0byBzdG9yZSB0aGUgc2V0IGluLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2V0TmFtZSAtIFRoZSBzZXQgdG8gYWRkIHRvLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byBhZGQuXG4gICAqIEBwYXJhbSB7U2V0QWRkRWxlbWVudE9wdGlvbnN9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtDb2xsZWN0aW9uVHRsfSBbb3B0aW9ucy50dGxdIC0gSG93IHRoZSBUVEwgc2hvdWxkIGJlIG1hbmFnZWQuXG4gICAqIFJlZnJlc2hlcyB0aGUgc2V0J3MgVFRMIHVzaW5nIHRoZSBjbGllbnQncyBkZWZhdWx0IGlmIHRoaXMgaXMgbm90IHN1cHBsaWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNldEFkZEVsZW1lbnQuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZVNldEFkZEVsZW1lbnQuU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlU2V0QWRkRWxlbWVudC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzZXRBZGRFbGVtZW50KFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIHNldE5hbWU6IHN0cmluZyxcbiAgICBlbGVtZW50OiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIG9wdGlvbnM/OiBTZXRBZGRFbGVtZW50T3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlU2V0QWRkRWxlbWVudC5SZXNwb25zZT4ge1xuICAgIHJldHVybiAoXG4gICAgICBhd2FpdCB0aGlzLnNldEFkZEVsZW1lbnRzKFxuICAgICAgICBjYWNoZU5hbWUsXG4gICAgICAgIHNldE5hbWUsXG4gICAgICAgIFtlbGVtZW50XSBhcyBzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKVxuICAgICkudG9TaW5ndWxhclJlc3BvbnNlKCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBtdWx0aXBsZSBlbGVtZW50cyB0byB0aGUgZ2l2ZW4gc2V0LiBDcmVhdGVzIHRoZSBzZXQgaWYgaXQgZG9lcyBub3RcbiAgICogYWxyZWFkeSBleGlzdC5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogQWZ0ZXIgdGhpcyBvcGVyYXRpb24sIHRoZSBzZXQgd2lsbCBjb250YWluIHRoZSB1bmlvbiBvZiB0aGUgZWxlbWVudHMgcGFzc2VkXG4gICAqIGluIGFuZCB0aGUgb3JpZ2luYWwgZWxlbWVudHMgb2YgdGhlIHNldC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSB0byBzdG9yZSB0aGUgc2V0IGluLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2V0TmFtZSAtIFRoZSBzZXQgdG8gYWRkIHRvLlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdIHwgVWludDhBcnJheVtdfSBlbGVtZW50cyAtIFRoZSBlbGVtZW50cyB0byBhZGQuXG4gICAqIEBwYXJhbSB7U2V0QWRkRWxlbWVudHNPcHRpb25zfSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvblR0bH0gW29wdGlvbnMudHRsXSAtIEhvdyB0aGUgVFRMIHNob3VsZCBiZSBtYW5hZ2VkLlxuICAgKiBSZWZyZXNoZXMgdGhlIHNldCdzIFRUTCB1c2luZyB0aGUgY2xpZW50J3MgZGVmYXVsdCBpZiB0aGlzIGlzIG5vdCBzdXBwbGllZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVTZXRBZGRFbGVtZW50cy5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlU2V0QWRkRWxlbWVudHMuU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlU2V0QWRkRWxlbWVudHMuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc2V0QWRkRWxlbWVudHMoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgc2V0TmFtZTogc3RyaW5nLFxuICAgIGVsZW1lbnRzOiBzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXSxcbiAgICBvcHRpb25zPzogU2V0QWRkRWxlbWVudHNPcHRpb25zXG4gICk6IFByb21pc2U8Q2FjaGVTZXRBZGRFbGVtZW50cy5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNldEFkZEVsZW1lbnRzKFxuICAgICAgY2FjaGVOYW1lLFxuICAgICAgc2V0TmFtZSxcbiAgICAgIGVsZW1lbnRzLFxuICAgICAgb3B0aW9ucz8udHRsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGUgZ2l2ZW4gc2V0IGNvbnRhaW5zIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKiBAcGFyYW0gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIHNldC5cbiAgICogQHBhcmFtIHNldE5hbWUgLSBUaGUgc2V0IHRvIGNoZWNrLlxuICAgKiBAcGFyYW0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIGNoZWNrIGZvci5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVTZXRDb250YWluc0VsZW1lbnQuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZVNldENvbnRhaW5zRWxlbWVudC5IaXR9IGlmIHRoZSBzZXQgZXhpc3RzIGFuZCBjb250YWlucyB0aGUgZWxlbWVudC5cbiAgICoge0BsaW5rIENhY2hlU2V0Q29udGFpbnNFbGVtZW50Lk1pc3N9IGlmIHRoZSBzZXQgZG9lcyBub3QgY29udGFpbiB0aGUgZWxlbWVudC5cbiAgICoge0BsaW5rIENhY2hlU2V0Q29udGFpbnNFbGVtZW50LkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNldENvbnRhaW5zRWxlbWVudChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBzZXROYW1lOiBzdHJpbmcsXG4gICAgZWxlbWVudDogc3RyaW5nIHwgVWludDhBcnJheVxuICApOiBQcm9taXNlPENhY2hlU2V0Q29udGFpbnNFbGVtZW50LlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc2V0Q29udGFpbnNFbGVtZW50KGNhY2hlTmFtZSwgc2V0TmFtZSwgZWxlbWVudCk7XG4gIH1cblxuICAvKipcbiAgICogVGVzdHMgaWYgdGhlIGdpdmVuIHNldCBjb250YWlucyB0aGUgZ2l2ZW4gZWxlbWVudHMuXG4gICAqIEBwYXJhbSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgc2V0LlxuICAgKiBAcGFyYW0gc2V0TmFtZSAtIFRoZSBzZXQgdG8gY2hlY2suXG4gICAqIEBwYXJhbSBlbGVtZW50cyAtIFRoZSBlbGVtZW50cyB0byBjaGVjayBmb3IuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlU2V0Q29udGFpbnNFbGVtZW50cy5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlU2V0Q29udGFpbnNFbGVtZW50cy5IaXR9IGNvbnRhaW5pbmcgdGhlIGVsZW1lbnRzIHRvIHRoZWlyIHByZXNlbmNlIGluIHRoZSBjYWNoZS5cbiAgICoge0BsaW5rIENhY2hlU2V0Q29udGFpbnNFbGVtZW50cy5NaXNzfSBpZiB0aGUgc2V0IGRvZXMgbm90IGNvbnRhaW4gdGhlIGVsZW1lbnRzLlxuICAgKiB7QGxpbmsgQ2FjaGVTZXRDb250YWluc0VsZW1lbnRzLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNldENvbnRhaW5zRWxlbWVudHMoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgc2V0TmFtZTogc3RyaW5nLFxuICAgIGVsZW1lbnRzOiBzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXVxuICApOiBQcm9taXNlPENhY2hlU2V0Q29udGFpbnNFbGVtZW50cy5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNldENvbnRhaW5zRWxlbWVudHMoY2FjaGVOYW1lLCBzZXROYW1lLCBlbGVtZW50cyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBlbGVtZW50IGZyb20gdGhlIGdpdmVuIHNldC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZXROYW1lIC0gVGhlIHNldCB0byByZW1vdmUgZnJvbS5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNldFJlbW92ZUVsZW1lbnQuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZVNldFJlbW92ZUVsZW1lbnQuU3VjY2Vzc30gb24gc3VjY2Vzcy4gUmVtb3ZpbmcgYW4gZWxlbWVudCB0aGF0XG4gICAqIGRvZXMgbm90IG9jY3VyIGluIHRoZSBzZXQgb3IgcmVtb3ZpbmcgZnJvbSBhIG5vbi1leGlzdGVudCBzZXQgY291bnRzIGFzIGFcbiAgICogc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlU2V0UmVtb3ZlRWxlbWVudC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzZXRSZW1vdmVFbGVtZW50KFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIHNldE5hbWU6IHN0cmluZyxcbiAgICBlbGVtZW50OiBzdHJpbmcgfCBVaW50OEFycmF5XG4gICk6IFByb21pc2U8Q2FjaGVTZXRSZW1vdmVFbGVtZW50LlJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIChcbiAgICAgIGF3YWl0IHRoaXMuc2V0UmVtb3ZlRWxlbWVudHMoY2FjaGVOYW1lLCBzZXROYW1lLCBbZWxlbWVudF0gYXNcbiAgICAgICAgfCBzdHJpbmdbXVxuICAgICAgICB8IFVpbnQ4QXJyYXlbXSlcbiAgICApLnRvU2luZ3VsYXJSZXNwb25zZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgbXVsdGlwbGUgZWxlbWVudHMgZnJvbSB0aGUgZ2l2ZW4gc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNldE5hbWUgLSBUaGUgc2V0IHRvIHJlbW92ZSBmcm9tLlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdIHwgVWludDhBcnJheVtdfSBlbGVtZW50cyAtIFRoZSBlbGVtZW50cyB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlU2V0UmVtb3ZlRWxlbWVudHMuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZVNldFJlbW92ZUVsZW1lbnRzLlN1Y2Nlc3N9IG9uIHN1Y2Nlc3MuIFJlbW92aW5nIGVsZW1lbnRzIHRoYXRcbiAgICogZG8gbm90IG9jY3VyIGluIHRoZSBzZXQgb3IgcmVtb3ZpbmcgZnJvbSBhIG5vbi1leGlzdGVudCBzZXQgY291bnRzIGFzIGFcbiAgICogc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlU2V0UmVtb3ZlRWxlbWVudHMuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc2V0UmVtb3ZlRWxlbWVudHMoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgc2V0TmFtZTogc3RyaW5nLFxuICAgIGVsZW1lbnRzOiBzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXVxuICApOiBQcm9taXNlPENhY2hlU2V0UmVtb3ZlRWxlbWVudHMuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5zZXRSZW1vdmVFbGVtZW50cyhjYWNoZU5hbWUsIHNldE5hbWUsIGVsZW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHJhbmRvbSBzYW1wbGUgb2YgZWxlbWVudHMgZnJvbSB0aGUgc2V0LlxuICAgKiBSZXR1cm5zIGEgZGlmZmVyZW50IHJhbmRvbSBzYW1wbGUgZm9yIGVhY2ggY2FsbC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZXROYW1lIC0gVGhlIHNldCB0byByZW1vdmUgZnJvbS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJldHVybi5cbiAgICogSWYgdGhlIHNldCBjb250YWlucyBmZXdlciB0aGFuICdsaW1pdCcgZWxlbWVudHMsIHRoZSBlbnRpcmUgc2V0IHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlU2V0U2FtcGxlLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVTZXRTYW1wbGUuSGl0fSBjb250YWluaW5nIHRoZSBzZXQgZWxlbWVudHMgaWYgdGhlIHNldCBleGlzdHMuXG4gICAqIHtAbGluayBDYWNoZVNldFNhbXBsZS5NaXNzfSBpZiB0aGUgc2V0IGRvZXMgbm90IGV4aXN0LlxuICAgKiB7QGxpbmsgQ2FjaGVTZXRTYW1wbGUuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc2V0U2FtcGxlKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIHNldE5hbWU6IHN0cmluZyxcbiAgICBsaW1pdDogbnVtYmVyXG4gICk6IFByb21pc2U8Q2FjaGVTZXRTYW1wbGUuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5zZXRTYW1wbGUoY2FjaGVOYW1lLCBzZXROYW1lLCBsaW1pdCk7XG4gIH1cblxuICAvKipcbiAgICogUG9wcyBhIHJhbmRvbSBzYW1wbGUgb2YgZWxlbWVudHMgZnJvbSB0aGUgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNldE5hbWUgLSBUaGUgc2V0IHRvIHJlbW92ZSBmcm9tLlxuICAgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmV0dXJuLlxuICAgKiBJZiB0aGUgc2V0IGNvbnRhaW5zIGZld2VyIHRoYW4gJ2xpbWl0JyBlbGVtZW50cywgdGhlIGVudGlyZSBzZXQgd2lsbCBiZSByZXR1cm5lZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVTZXRQb3AuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZVNldFBvcC5IaXR9IGNvbnRhaW5pbmcgdGhlIHNldCBlbGVtZW50cyBpZiB0aGUgc2V0IGV4aXN0cy5cbiAgICoge0BsaW5rIENhY2hlU2V0UG9wLk1pc3N9IGlmIHRoZSBzZXQgZG9lcyBub3QgZXhpc3QuXG4gICAqIHtAbGluayBDYWNoZVNldFBvcC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzZXRQb3AoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgc2V0TmFtZTogc3RyaW5nLFxuICAgIGNvdW50OiBudW1iZXJcbiAgKTogUHJvbWlzZTxDYWNoZVNldFBvcC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNldFBvcChjYWNoZU5hbWUsIHNldE5hbWUsIGNvdW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNldE5hbWUgLSBUaGUgc2V0IHRvIHJlbW92ZSBmcm9tLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNldExlbmd0aC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlU2V0TGVuZ3RoLkhpdH0gY29udGFpbmluZyB0aGUgc2V0IGVsZW1lbnRzIGlmIHRoZSBzZXQgZXhpc3RzLlxuICAgKiB7QGxpbmsgQ2FjaGVTZXRMZW5ndGguTWlzc30gaWYgdGhlIHNldCBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlU2V0TGVuZ3RoLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNldExlbmd0aChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBzZXROYW1lOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxDYWNoZVNldExlbmd0aC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNldExlbmd0aChjYWNoZU5hbWUsIHNldE5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc29jaWF0ZXMgdGhlIGdpdmVuIGtleSB3aXRoIHRoZSBnaXZlbiB2YWx1ZSBpZiBrZXkgaXMgbm90IGFscmVhZHkgcHJlc2VudCBpbiB0aGUgY2FjaGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzZXRJZkFic2VudCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIHRvIHN0b3JlIHRoZSB2YWx1ZSBpbi5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSBrZXkgLSBUaGUga2V5IHRvIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSBmaWVsZCAtIFRoZSB2YWx1ZSB0byBiZSBzdG9yZWQuXG4gICAqIEBwYXJhbSB7U2V0SWZOb3RFeGlzdHNPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnR0bF0gLSBUaGUgdGltZSB0byBsaXZlIGZvciB0aGUgaXRlbSBpbiB0aGUgY2FjaGUuXG4gICAqIFVzZXMgdGhlIGNsaWVudCdzIGRlZmF1bHQgVFRMIGlmIHRoaXMgaXMgbm90IHN1cHBsaWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNldElmTm90RXhpc3RzLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVTZXRJZk5vdEV4aXN0cy5TdG9yZWR9IG9uIHN0b3JpbmcgdGhlIG5ldyB2YWx1ZS5cbiAgICoge0BsaW5rIENhY2hlU2V0SWZOb3RFeGlzdHMuTm90U3RvcmVkfSBvbiBub3Qgc3RvcmluZyB0aGUgbmV3IHZhbHVlLlxuICAgKiB7QGxpbmsgQ2FjaGVTZXRJZk5vdEV4aXN0cy5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzZXRJZk5vdEV4aXN0cyhcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBrZXk6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgZmllbGQ6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgb3B0aW9ucz86IFNldElmTm90RXhpc3RzT3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlU2V0SWZOb3RFeGlzdHMuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5zZXRJZk5vdEV4aXN0cyhjYWNoZU5hbWUsIGtleSwgZmllbGQsIG9wdGlvbnM/LnR0bCk7XG4gIH1cblxuICAvKipcbiAgICogQXNzb2NpYXRlcyB0aGUgZ2l2ZW4ga2V5IHdpdGggdGhlIGdpdmVuIHZhbHVlIGlmIGtleSBpcyBub3QgYWxyZWFkeSBwcmVzZW50IGluIHRoZSBjYWNoZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSB0byBzdG9yZSB0aGUgdmFsdWUgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0ga2V5IC0gVGhlIGtleSB0byBzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gZmllbGQgLSBUaGUgdmFsdWUgdG8gYmUgc3RvcmVkLlxuICAgKiBAcGFyYW0ge1NldElmQWJzZW50T3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50dGxdIC0gVGhlIHRpbWUgdG8gbGl2ZSBmb3IgdGhlIGl0ZW0gaW4gdGhlIGNhY2hlLlxuICAgKiBVc2VzIHRoZSBjbGllbnQncyBkZWZhdWx0IFRUTCBpZiB0aGlzIGlzIG5vdCBzdXBwbGllZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jb21wcmVzcz1mYWxzZV0gLSBXaGV0aGVyIHRvIGNvbXByZXNzIHRoZSB2YWx1ZS4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlU2V0SWZBYnNlbnQuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZVNldElmQWJzZW50LlN0b3JlZH0gb24gc3RvcmluZyB0aGUgbmV3IHZhbHVlLlxuICAgKiB7QGxpbmsgQ2FjaGVTZXRJZkFic2VudC5Ob3RTdG9yZWR9IG9uIG5vdCBzdG9yaW5nIHRoZSBuZXcgdmFsdWUuXG4gICAqIHtAbGluayBDYWNoZVNldElmQWJzZW50LkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNldElmQWJzZW50KFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGtleTogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgICBmaWVsZDogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgICBvcHRpb25zPzogU2V0SWZBYnNlbnRPcHRpb25zXG4gICk6IFByb21pc2U8Q2FjaGVTZXRJZkFic2VudC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNldElmQWJzZW50KGNhY2hlTmFtZSwga2V5LCBmaWVsZCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQXNzb2NpYXRlcyB0aGUgZ2l2ZW4ga2V5IHdpdGggdGhlIGdpdmVuIHZhbHVlIGlmIHRoZSBrZXkgaXMgcHJlc2VudCBpbiB0aGUgY2FjaGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgdG8gc3RvcmUgdGhlIHZhbHVlIGluLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IGtleSAtIFRoZSBrZXkgdG8gc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IGZpZWxkIC0gVGhlIHZhbHVlIHRvIGJlIHN0b3JlZC5cbiAgICogQHBhcmFtIHtTZXRJZlByZXNlbnRPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnR0bF0gLSBUaGUgdGltZSB0byBsaXZlIGZvciB0aGUgaXRlbSBpbiB0aGUgY2FjaGUuXG4gICAqIFVzZXMgdGhlIGNsaWVudCdzIGRlZmF1bHQgVFRMIGlmIHRoaXMgaXMgbm90IHN1cHBsaWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNldElmUHJlc2VudC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlU2V0SWZQcmVzZW50LlN0b3JlZH0gb24gc3RvcmluZyB0aGUgbmV3IHZhbHVlLlxuICAgKiB7QGxpbmsgQ2FjaGVTZXRJZlByZXNlbnQuTm90U3RvcmVkfSBvbiBub3Qgc3RvcmluZyB0aGUgbmV3IHZhbHVlLlxuICAgKiB7QGxpbmsgQ2FjaGVTZXRJZlByZXNlbnQuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc2V0SWZQcmVzZW50KFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGtleTogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgICBmaWVsZDogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgICBvcHRpb25zPzogU2V0SWZQcmVzZW50T3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlU2V0SWZQcmVzZW50LlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc2V0SWZQcmVzZW50KGNhY2hlTmFtZSwga2V5LCBmaWVsZCwgb3B0aW9ucz8udHRsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NvY2lhdGVzIHRoZSBnaXZlbiBrZXkgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUgaWYgdGhlIGtleSBpcyBwcmVzZW50IGluIHRoZSBjYWNoZVxuICAgKiBhbmQgaXRzIHZhbHVlIGlzIGVxdWFsIHRvIHRoZSBzdXBwbGllZCBgZXF1YWxgIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIHRvIHN0b3JlIHRoZSB2YWx1ZSBpbi5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSBrZXkgLSBUaGUga2V5IHRvIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSBmaWVsZCAtIFRoZSB2YWx1ZSB0byBiZSBzdG9yZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gZXF1YWwgLSBUaGUgdmFsdWUgdG8gY29tcGFyZSB0byB0aGUgY2FjaGVkIHZhbHVlLlxuICAgKiBAcGFyYW0ge1NldElmRXF1YWxPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnR0bF0gLSBUaGUgdGltZSB0byBsaXZlIGZvciB0aGUgaXRlbSBpbiB0aGUgY2FjaGUuXG4gICAqIFVzZXMgdGhlIGNsaWVudCdzIGRlZmF1bHQgVFRMIGlmIHRoaXMgaXMgbm90IHN1cHBsaWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNldElmRXF1YWwuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZVNldElmRXF1YWwuU3RvcmVkfSBvbiBzdG9yaW5nIHRoZSBuZXcgdmFsdWUuXG4gICAqIHtAbGluayBDYWNoZVNldElmRXF1YWwuTm90U3RvcmVkfSBvbiBub3Qgc3RvcmluZyB0aGUgbmV3IHZhbHVlLlxuICAgKiB7QGxpbmsgQ2FjaGVTZXRJZkVxdWFsLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNldElmRXF1YWwoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAga2V5OiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIGZpZWxkOiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIGVxdWFsOiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIG9wdGlvbnM/OiBTZXRJZkVxdWFsT3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlU2V0SWZFcXVhbC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNldElmRXF1YWwoY2FjaGVOYW1lLCBrZXksIGZpZWxkLCBlcXVhbCwgb3B0aW9ucz8udHRsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NvY2lhdGVzIHRoZSBnaXZlbiBrZXkgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUgaWYgdGhlIGtleSBkb2VzIG5vdCBleGlzdCBpbiB0aGUgY2FjaGUgb3JcbiAgICogaWYgdGhlIHZhbHVlIGZvciB0aGUga2V5IGlzIG5vdCBlcXVhbCB0byB0aGUgc3VwcGxpZWQgYG5vdEVxdWFsYCBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgdG8gc3RvcmUgdGhlIHZhbHVlIGluLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IGtleSAtIFRoZSBrZXkgdG8gc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IGZpZWxkIC0gVGhlIHZhbHVlIHRvIGJlIHN0b3JlZC5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSBub3RFcXVhbCAtIFRoZSB2YWx1ZSB0byBjb21wYXJlIHRvIHRoZSBjYWNoZWQgdmFsdWUuXG4gICAqIEBwYXJhbSB7U2V0SWZOb3RFcXVhbE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudHRsXSAtIFRoZSB0aW1lIHRvIGxpdmUgZm9yIHRoZSBpdGVtIGluIHRoZSBjYWNoZS5cbiAgICogVXNlcyB0aGUgY2xpZW50J3MgZGVmYXVsdCBUVEwgaWYgdGhpcyBpcyBub3Qgc3VwcGxpZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlU2V0SWZOb3RFcXVhbC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlU2V0SWZOb3RFcXVhbC5TdG9yZWR9IG9uIHN0b3JpbmcgdGhlIG5ldyB2YWx1ZS5cbiAgICoge0BsaW5rIENhY2hlU2V0SWZOb3RFcXVhbC5Ob3RTdG9yZWR9IG9uIG5vdCBzdG9yaW5nIHRoZSBuZXcgdmFsdWUuXG4gICAqIHtAbGluayBDYWNoZVNldElmTm90RXF1YWwuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc2V0SWZOb3RFcXVhbChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBrZXk6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgZmllbGQ6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgbm90RXF1YWw6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgb3B0aW9ucz86IFNldElmTm90RXF1YWxPcHRpb25zXG4gICk6IFByb21pc2U8Q2FjaGVTZXRJZk5vdEVxdWFsLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc2V0SWZOb3RFcXVhbChcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIGtleSxcbiAgICAgIGZpZWxkLFxuICAgICAgbm90RXF1YWwsXG4gICAgICBvcHRpb25zPy50dGxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc29jaWF0ZXMgdGhlIGdpdmVuIGtleSB3aXRoIHRoZSBnaXZlbiB2YWx1ZSBpZiBrZXkgaXMgcHJlc2VudCBpbiB0aGUgY2FjaGVcbiAgICogYW5kIGl0cyB2YWx1ZSBpcyBub3QgZXF1YWwgdG8gdGhlIHN1cHBsaWVkIGBub3RFcXVhbGAgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgdG8gc3RvcmUgdGhlIHZhbHVlIGluLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IGtleSAtIFRoZSBrZXkgdG8gc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IGZpZWxkIC0gVGhlIHZhbHVlIHRvIGJlIHN0b3JlZC5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSBub3RFcXVhbCAtIFRoZSB2YWx1ZSB0byBjb21wYXJlIHRvIHRoZSBjYWNoZWQgdmFsdWUuXG4gICAqIEBwYXJhbSB7U2V0SWZBYnNlbnRPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnR0bF0gLSBUaGUgdGltZSB0byBsaXZlIGZvciB0aGUgaXRlbSBpbiB0aGUgY2FjaGUuXG4gICAqIFVzZXMgdGhlIGNsaWVudCdzIGRlZmF1bHQgVFRMIGlmIHRoaXMgaXMgbm90IHN1cHBsaWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNldElmUHJlc2VudEFuZE5vdEVxdWFsLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVTZXRJZlByZXNlbnRBbmROb3RFcXVhbC5TdG9yZWR9IG9uIHN0b3JpbmcgdGhlIG5ldyB2YWx1ZS5cbiAgICoge0BsaW5rIENhY2hlU2V0SWZQcmVzZW50QW5kTm90RXF1YWwuTm90U3RvcmVkfSBvbiBub3Qgc3RvcmluZyB0aGUgbmV3IHZhbHVlLlxuICAgKiB7QGxpbmsgQ2FjaGVTZXRJZlByZXNlbnRBbmROb3RFcXVhbC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzZXRJZlByZXNlbnRBbmROb3RFcXVhbChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBrZXk6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgZmllbGQ6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgbm90RXF1YWw6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgb3B0aW9ucz86IFNldElmUHJlc2VudEFuZE5vdEVxdWFsT3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlU2V0SWZQcmVzZW50QW5kTm90RXF1YWwuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5zZXRJZlByZXNlbnRBbmROb3RFcXVhbChcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIGtleSxcbiAgICAgIGZpZWxkLFxuICAgICAgbm90RXF1YWwsXG4gICAgICBvcHRpb25zPy50dGxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc29jaWF0ZXMgdGhlIGdpdmVuIGtleSB3aXRoIHRoZSBnaXZlbiB2YWx1ZSBpZiBrZXkgaXMgYWJzZW50IG9yIGlmIHRoZSBrZXkgaXNcbiAgICogcHJlc2VudCBhbmQgaXRzIHZhbHVlIGlzIGVxdWFsIHRvIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSB0byBzdG9yZSB0aGUgdmFsdWUgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0ga2V5IC0gVGhlIGtleSB0byBzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gZmllbGQgLSBUaGUgdmFsdWUgdG8gYmUgc3RvcmVkLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IGVxdWFsIC0gVGhlIHZhbHVlIHRvIGNvbXBhcmUgdG8gdGhlIGNhY2hlZCB2YWx1ZS5cbiAgICogQHBhcmFtIHtTZXRJZkFic2VudE9yRXF1YWxPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnR0bF0gLSBUaGUgdGltZSB0byBsaXZlIGZvciB0aGUgaXRlbSBpbiB0aGUgY2FjaGUuXG4gICAqIFVzZXMgdGhlIGNsaWVudCdzIGRlZmF1bHQgVFRMIGlmIHRoaXMgaXMgbm90IHN1cHBsaWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNldElmQWJzZW50T3JFcXVhbC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlU2V0SWZBYnNlbnRPckVxdWFsLlN0b3JlZH0gb24gc3RvcmluZyB0aGUgbmV3IHZhbHVlLlxuICAgKiB7QGxpbmsgQ2FjaGVTZXRJZkFic2VudE9yRXF1YWwuTm90U3RvcmVkfSBvbiBub3Qgc3RvcmluZyB0aGUgbmV3IHZhbHVlLlxuICAgKiB7QGxpbmsgQ2FjaGVTZXRJZkFic2VudE9yRXF1YWwuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc2V0SWZBYnNlbnRPckVxdWFsKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGtleTogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgICBmaWVsZDogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgICBlcXVhbDogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgICBvcHRpb25zPzogU2V0SWZBYnNlbnRPckVxdWFsT3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlU2V0SWZBYnNlbnRPckVxdWFsLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc2V0SWZBYnNlbnRPckVxdWFsKFxuICAgICAgY2FjaGVOYW1lLFxuICAgICAga2V5LFxuICAgICAgZmllbGQsXG4gICAgICBlcXVhbCxcbiAgICAgIG9wdGlvbnM/LnR0bFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRmx1c2hlcyAvIGNsZWFycyBhbGwgdGhlIGl0ZW1zIG9mIHRoZSBnaXZlbiBjYWNoZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIHRvIGJlIGZsdXNoZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlRmx1c2guUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZUZsdXNoLlN1Y2Nlc3N9IG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBDYWNoZUZsdXNoLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGZsdXNoQ2FjaGUoY2FjaGVOYW1lOiBzdHJpbmcpOiBQcm9taXNlPENhY2hlRmx1c2guUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jb250cm9sQ2xpZW50LmZsdXNoQ2FjaGUoY2FjaGVOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaGVzIGFsbCBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gZGljdGlvbmFyeS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSB0byBwZXJmb3JtIHRoZSBsb29rdXAgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaWN0aW9uYXJ5TmFtZSAtIFRoZSBkaWN0aW9uYXJ5IHRvIGZldGNoLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZURpY3Rpb25hcnlGZXRjaC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlRGljdGlvbmFyeUZldGNoLkhpdH0gY29udGFpbmluZyB0aGUgZGljdGlvbmFyeSBlbGVtZW50cyBpZiB0aGVcbiAgICogZGljdGlvbmFyeSBleGlzdHMuXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlGZXRjaC5NaXNzfSBpZiB0aGUgZGljdGlvbmFyeSBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlRGljdGlvbmFyeUZldGNoLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRpY3Rpb25hcnlGZXRjaChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBkaWN0aW9uYXJ5TmFtZTogc3RyaW5nXG4gICk6IFByb21pc2U8Q2FjaGVEaWN0aW9uYXJ5RmV0Y2guUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5kaWN0aW9uYXJ5RmV0Y2goY2FjaGVOYW1lLCBkaWN0aW9uYXJ5TmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBpbnRlZ2VyIHF1YW50aXR5IHRvIGEgZmllbGQgdmFsdWUuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIEluY3JlbWVudGluZyB0aGUgdmFsdWUgb2YgYSBtaXNzaW5nIGZpZWxkIHNldHMgdGhlIHZhbHVlIHRvIGFtb3VudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBmaWVsZC5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSBmaWVsZCAtIFRoZSBmaWVsZCB0byBpbmNyZW1lbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgLSBUaGUgcXVhbnRpdHkgdG8gYWRkIHRvIHRoZSB2YWx1ZS4gTWF5IGJlIHBvc2l0aXZlLFxuICAgKiBuZWdhdGl2ZSwgb3IgemVyby4gRGVmYXVsdHMgdG8gMS5cbiAgICogQHBhcmFtIHtJbmNyZW1lbnRPcHRpb25zfSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvblR0bH0gW29wdGlvbnMudHRsXSAtIEhvdyB0aGUgVFRMIHNob3VsZCBiZSBtYW5hZ2VkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZUluY3JlbWVudD59IC1cbiAgICoge0BsaW5rIENhY2hlSW5jcmVtZW50LlN1Y2Nlc3N9IGNvbnRhaW5pbmcgdGhlIGluY3JlbWVudGVkIHZhbHVlXG4gICAqIG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBDYWNoZUluY3JlbWVudC5FcnJvcn0gb24gZmFpbHVyZS4gSW5jcmVtZW50aW5nIGEgdmFsdWVcbiAgICogdGhhdCB3YXMgbm90IHNldCB1c2luZyB0aGlzIG1ldGhvZCBvciBpcyBub3QgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZlxuICAgKiBhbiBpbnRlZ2VyIHJlc3VsdHMgaW4gYSBmYWlsdXJlIHdpdGggYSBGYWlsZWRQcmVjb25kaXRpb25FeGNlcHRpb24gZXJyb3IuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgaW5jcmVtZW50KFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGZpZWxkOiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIGFtb3VudCA9IDEsXG4gICAgb3B0aW9ucz86IEluY3JlbWVudE9wdGlvbnNcbiAgKTogUHJvbWlzZTxDYWNoZUluY3JlbWVudC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LmluY3JlbWVudChjYWNoZU5hbWUsIGZpZWxkLCBhbW91bnQsIG9wdGlvbnM/LnR0bCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBlbGVtZW50IHRvIHRoZSBnaXZlbiBkaWN0aW9uYXJ5LiBDcmVhdGVzIHRoZSBkaWN0aW9uYXJ5IGlmIGl0IGRvZXNcbiAgICogbm90IGFscmVhZHkgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgdG8gc3RvcmUgdGhlIGRpY3Rpb25hcnkgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaWN0aW9uYXJ5TmFtZSAtIFRoZSBkaWN0aW9uYXJ5IHRvIGFkZCB0by5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSBmaWVsZCAtIFRoZSBmaWVsZCB0byBzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc3RvcmUuXG4gICAqIEBwYXJhbSB7RGljdGlvbmFyeVNldEZpZWxkT3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25UdGx9IFtvcHRpb25zLnR0bF0gLSBIb3cgdGhlIFRUTCBzaG91bGQgYmUgbWFuYWdlZC5cbiAgICogUmVmcmVzaGVzIHRoZSBkaWN0aW9uYXJ5J3MgVFRMIHVzaW5nIHRoZSBjbGllbnQncyBkZWZhdWx0IGlmIHRoaXMgaXMgbm90XG4gICAqIHN1cHBsaWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZURpY3Rpb25hcnlTZXRGaWVsZC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlRGljdGlvbmFyeVNldEZpZWxkLlN1Y2Nlc3N9IG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlTZXRGaWVsZC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBkaWN0aW9uYXJ5U2V0RmllbGQoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgZGljdGlvbmFyeU5hbWU6IHN0cmluZyxcbiAgICBmaWVsZDogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgICB2YWx1ZTogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgICBvcHRpb25zPzogRGljdGlvbmFyeVNldEZpZWxkT3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlRGljdGlvbmFyeVNldEZpZWxkLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuZGljdGlvbmFyeVNldEZpZWxkKFxuICAgICAgY2FjaGVOYW1lLFxuICAgICAgZGljdGlvbmFyeU5hbWUsXG4gICAgICBmaWVsZCxcbiAgICAgIHZhbHVlLFxuICAgICAgb3B0aW9ucz8udHRsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIG11bHRpcGxlIGVsZW1lbnRzIHRvIHRoZSBnaXZlbiBkaWN0aW9uYXJ5LiBDcmVhdGVzIHRoZSBkaWN0aW9uYXJ5IGlmXG4gICAqIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgdG8gc3RvcmUgdGhlIGRpY3Rpb25hcnkgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaWN0aW9uYXJ5TmFtZSAtIFRoZSBkaWN0aW9uYXJ5IHRvIGFkZCB0by5cbiAgICogQHBhcmFtIHtNYXA8c3RyaW5nIHwgVWludDhBcnJheSwgc3RyaW5nIHwgVWludDhBcnJheT59IGVsZW1lbnRzIC0gVGhlXG4gICAqIGVsZW1lbnRzIHRvIHNldC5cbiAgICogQHBhcmFtIHtEaWN0aW9uYXJ5U2V0RmllbGRzT3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25UdGx9IFtvcHRpb25zLnR0bF0gLSBIb3cgdGhlIFRUTCBzaG91bGQgYmUgbWFuYWdlZC5cbiAgICogUmVmcmVzaGVzIHRoZSBkaWN0aW9uYXJ5J3MgVFRMIHVzaW5nIHRoZSBjbGllbnQncyBkZWZhdWx0IGlmIHRoaXMgaXMgbm90XG4gICAqIHN1cHBsaWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZURpY3Rpb25hcnlTZXRGaWVsZHMuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlTZXRGaWVsZHMuU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlRGljdGlvbmFyeVNldEZpZWxkcy5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBkaWN0aW9uYXJ5U2V0RmllbGRzKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGRpY3Rpb25hcnlOYW1lOiBzdHJpbmcsXG4gICAgZWxlbWVudHM6XG4gICAgICB8IE1hcDxzdHJpbmcgfCBVaW50OEFycmF5LCBzdHJpbmcgfCBVaW50OEFycmF5PlxuICAgICAgfCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBVaW50OEFycmF5PlxuICAgICAgfCBBcnJheTxbc3RyaW5nLCBzdHJpbmcgfCBVaW50OEFycmF5XT4sXG4gICAgb3B0aW9ucz86IERpY3Rpb25hcnlTZXRGaWVsZHNPcHRpb25zXG4gICk6IFByb21pc2U8Q2FjaGVEaWN0aW9uYXJ5U2V0RmllbGRzLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuZGljdGlvbmFyeVNldEZpZWxkcyhcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIGRpY3Rpb25hcnlOYW1lLFxuICAgICAgZWxlbWVudHMsXG4gICAgICBvcHRpb25zPy50dGxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIHN0b3JlZCBmb3IgdGhlIGdpdmVuIGRpY3Rpb25hcnkgYW5kIGZpZWxkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIGRpY3Rpb25hcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaWN0aW9uYXJ5TmFtZSAtIFRoZSBkaWN0aW9uYXJ5IHRvIGxvb2sgdXAuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gZmllbGQgLSBUaGUgZmllbGQgdG8gbG9vayB1cC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVEaWN0aW9uYXJ5R2V0RmllbGQuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlHZXRGaWVsZC5IaXR9IGNvbnRhaW5pbmcgdGhlIGRpY3Rpb25hcnkgZWxlbWVudCBpZlxuICAgKiBvbmUgaXMgZm91bmQuXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlHZXRGaWVsZC5NaXNzfSBpZiB0aGUgZGljdGlvbmFyeSBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlRGljdGlvbmFyeUdldEZpZWxkLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRpY3Rpb25hcnlHZXRGaWVsZChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBkaWN0aW9uYXJ5TmFtZTogc3RyaW5nLFxuICAgIGZpZWxkOiBzdHJpbmcgfCBVaW50OEFycmF5XG4gICk6IFByb21pc2U8Q2FjaGVEaWN0aW9uYXJ5R2V0RmllbGQuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5kaWN0aW9uYXJ5R2V0RmllbGQoY2FjaGVOYW1lLCBkaWN0aW9uYXJ5TmFtZSwgZmllbGQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgbXVsdGlwbGUgdmFsdWVzIGZyb20gdGhlIGdpdmVuIGRpY3Rpb25hcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgZGljdGlvbmFyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRpY3Rpb25hcnlOYW1lIC0gVGhlIGRpY3Rpb25hcnkgdG8gbG9vayB1cC5cbiAgICogQHBhcmFtIHtzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXX0gZmllbGRzIC0gVGhlIGZpZWxkcyB0byBsb29rIHVwLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZURpY3Rpb25hcnlHZXRGaWVsZHMuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlHZXRGaWVsZHMuSGl0fSBjb250YWluaW5nIHRoZSBkaWN0aW9uYXJ5IGVsZW1lbnRzIGlmXG4gICAqIHRoZSBkaWN0aW9uYXJ5IGV4aXN0cy5cbiAgICoge0BsaW5rIENhY2hlRGljdGlvbmFyeUdldEZpZWxkcy5NaXNzfSBpZiB0aGUgZGljdGlvbmFyeSBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlRGljdGlvbmFyeUdldEZpZWxkcy5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBkaWN0aW9uYXJ5R2V0RmllbGRzKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGRpY3Rpb25hcnlOYW1lOiBzdHJpbmcsXG4gICAgZmllbGRzOiBzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXVxuICApOiBQcm9taXNlPENhY2hlRGljdGlvbmFyeUdldEZpZWxkcy5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LmRpY3Rpb25hcnlHZXRGaWVsZHMoY2FjaGVOYW1lLCBkaWN0aW9uYXJ5TmFtZSwgZmllbGRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGVsZW1lbnQgZnJvbSB0aGUgZ2l2ZW4gZGljdGlvbmFyeS5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogUGVyZm9ybXMgYSBuby1vcCBpZiB0aGUgZGljdGlvbmFyeSBvciBmaWVsZCBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBkaWN0aW9uYXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGljdGlvbmFyeU5hbWUgLSBUaGUgZGljdGlvbmFyeSB0byByZW1vdmUgZnJvbS5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSBmaWVsZCAtIFRoZSBmaWVsZCB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlRGljdGlvbmFyeVJlbW92ZUZpZWxkLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVEaWN0aW9uYXJ5UmVtb3ZlRmllbGQuU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlRGljdGlvbmFyeVJlbW92ZUZpZWxkLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRpY3Rpb25hcnlSZW1vdmVGaWVsZChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBkaWN0aW9uYXJ5TmFtZTogc3RyaW5nLFxuICAgIGZpZWxkOiBzdHJpbmcgfCBVaW50OEFycmF5XG4gICk6IFByb21pc2U8Q2FjaGVEaWN0aW9uYXJ5UmVtb3ZlRmllbGQuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5kaWN0aW9uYXJ5UmVtb3ZlRmllbGQoY2FjaGVOYW1lLCBkaWN0aW9uYXJ5TmFtZSwgZmllbGQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgbXVsdGlwbGUgZmllbGRzIGZyb20gdGhlIGdpdmVuIGRpY3Rpb25hcnkuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFBlcmZvcm1zIGEgbm8tb3AgaWYgdGhlIGRpY3Rpb25hcnkgb3IgZmllbGRzIGRvIG5vdCBleGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBkaWN0aW9uYXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGljdGlvbmFyeU5hbWUgLSBUaGUgZGljdGlvbmFyeSB0byByZW1vdmUgZnJvbS5cbiAgICogQHBhcmFtIHtzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXX0gZmllbGRzIC0gVGhlIGZpZWxkcyB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlRGljdGlvbmFyeVJlbW92ZUZpZWxkcy5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlRGljdGlvbmFyeVJlbW92ZUZpZWxkcy5TdWNjZXNzfSBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVEaWN0aW9uYXJ5UmVtb3ZlRmllbGRzLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRpY3Rpb25hcnlSZW1vdmVGaWVsZHMoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgZGljdGlvbmFyeU5hbWU6IHN0cmluZyxcbiAgICBmaWVsZHM6IHN0cmluZ1tdIHwgVWludDhBcnJheVtdXG4gICk6IFByb21pc2U8Q2FjaGVEaWN0aW9uYXJ5UmVtb3ZlRmllbGRzLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuZGljdGlvbmFyeVJlbW92ZUZpZWxkcyhcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIGRpY3Rpb25hcnlOYW1lLFxuICAgICAgZmllbGRzXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGludGVnZXIgcXVhbnRpdHkgdG8gYSBkaWN0aW9uYXJ5IHZhbHVlLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBJbmNyZW1lbnRpbmcgdGhlIHZhbHVlIG9mIGEgbWlzc2luZyBmaWVsZCBzZXRzIHRoZSB2YWx1ZSB0byBhbW91bnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgZGljdGlvbmFyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRpY3Rpb25hcnlOYW1lIC0gVGhlIGRpY3Rpb25hcnkgdG8gc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IGZpZWxkIC0gVGhlIGZpZWxkIHRvIGluY3JlbWVudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCAtIFRoZSBxdWFudGl0eSB0byBhZGQgdG8gdGhlIHZhbHVlLiBNYXkgYmUgcG9zaXRpdmUsXG4gICAqIG5lZ2F0aXZlLCBvciB6ZXJvLiBEZWZhdWx0cyB0byAxLlxuICAgKiBAcGFyYW0ge0RpY3Rpb25hcnlJbmNyZW1lbnRPcHRpb25zfSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvblR0bH0gW29wdGlvbnMudHRsXSAtIEhvdyB0aGUgVFRMIHNob3VsZCBiZSBtYW5hZ2VkLlxuICAgKiBSZWZyZXNoZXMgdGhlIGRpY3Rpb25hcnkncyBUVEwgdXNpbmcgdGhlIGNsaWVudCdzIGRlZmF1bHQgaWYgdGhpcyBpcyBub3RcbiAgICogc3VwcGxpZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlRGljdGlvbmFyeUluY3JlbWVudC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlRGljdGlvbmFyeUluY3JlbWVudC5TdWNjZXNzfSBjb250YWluaW5nIHRoZSBpbmNyZW1lbnRlZCB2YWx1ZVxuICAgKiBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVEaWN0aW9uYXJ5SW5jcmVtZW50LkVycm9yfSBvbiBmYWlsdXJlLiBJbmNyZW1lbnRpbmcgYSB2YWx1ZVxuICAgKiB0aGF0IHdhcyBub3Qgc2V0IHVzaW5nIHRoaXMgbWV0aG9kIG9yIGlzIG5vdCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mXG4gICAqIGFuIGludGVnZXIgcmVzdWx0cyBpbiBhIGZhaWx1cmUgd2l0aCBhIEZhaWxlZFByZWNvbmRpdGlvbkV4Y2VwdGlvbiBlcnJvci5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBkaWN0aW9uYXJ5SW5jcmVtZW50KFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGRpY3Rpb25hcnlOYW1lOiBzdHJpbmcsXG4gICAgZmllbGQ6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgYW1vdW50ID0gMSxcbiAgICBvcHRpb25zPzogRGljdGlvbmFyeUluY3JlbWVudE9wdGlvbnNcbiAgKTogUHJvbWlzZTxDYWNoZURpY3Rpb25hcnlJbmNyZW1lbnQuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5kaWN0aW9uYXJ5SW5jcmVtZW50KFxuICAgICAgY2FjaGVOYW1lLFxuICAgICAgZGljdGlvbmFyeU5hbWUsXG4gICAgICBmaWVsZCxcbiAgICAgIGFtb3VudCxcbiAgICAgIG9wdGlvbnM/LnR0bFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBnaXZlbiBkaWN0aW9uYXJ5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIGRpY3Rpb25hcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaWN0aW9uYXJ5TmFtZSAtIFRoZSBkaWN0aW9uYXJ5IHRvIGdldCB0aGUgbGVuZ3RoIG9mLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZURpY3Rpb25hcnlMZW5ndGguUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlMZW5ndGguSGl0fSBjb250YWluaW5nIHRoZSBsZW5ndGggaWYgdGhlIGRpY3Rpb25hcnkgZXhpc3RzLlxuICAgKiB7QGxpbmsgQ2FjaGVEaWN0aW9uYXJ5TGVuZ3RoLk1pc3N9IGlmIHRoZSBkaWN0aW9uYXJ5IGRvZXMgbm90IGV4aXN0LlxuICAgKiB7QGxpbmsgQ2FjaGVEaWN0aW9uYXJ5TGVuZ3RoLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRpY3Rpb25hcnlMZW5ndGgoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgZGljdGlvbmFyeU5hbWU6IHN0cmluZ1xuICApOiBQcm9taXNlPENhY2hlRGljdGlvbmFyeUxlbmd0aC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LmRpY3Rpb25hcnlMZW5ndGgoY2FjaGVOYW1lLCBkaWN0aW9uYXJ5TmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBlbGVtZW50IHRvIHRoZSBnaXZlbiBzb3J0ZWQgc2V0LiBJZiB0aGUgZWxlbWVudCBhbHJlYWR5IGV4aXN0cywgaXRzXG4gICAqIHNjb3JlIGlzIHVwZGF0ZWQuIENyZWF0ZXMgdGhlIHNvcnRlZCBzZXQgaWYgaXQgZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgc29ydGVkIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNvcnRlZFNldE5hbWUgLSBUaGUgc29ydGVkIHNldCB0byBhZGQgdG8uXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYWRkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2NvcmUgLSBUaGUgc2NvcmUgdG8gYXNzaWduIHRvIHRoZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtTb3J0ZWRTZXRQdXRFbGVtZW50T3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25UdGx9IFtvcHRpb25zLnR0bF0gLSBIb3cgdGhlIFRUTCBzaG91bGQgYmUgbWFuYWdlZC5cbiAgICogUmVmcmVzaGVzIHRoZSBzb3J0ZWQgc2V0J3MgVFRMIHVzaW5nIHRoZSBjbGllbnQncyBkZWZhdWx0IGlmIHRoaXMgaXMgbm90XG4gICAqIHN1cHBsaWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNvcnRlZFNldFB1dEVsZW1lbnQuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldFB1dEVsZW1lbnQuU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0UHV0RWxlbWVudC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICogQHJldHVybnNcbiAgICovXG4gIHB1YmxpYyBhc3luYyBzb3J0ZWRTZXRQdXRFbGVtZW50KFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIHNvcnRlZFNldE5hbWU6IHN0cmluZyxcbiAgICB2YWx1ZTogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgICBzY29yZTogbnVtYmVyLFxuICAgIG9wdGlvbnM/OiBTb3J0ZWRTZXRQdXRFbGVtZW50T3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlU29ydGVkU2V0UHV0RWxlbWVudC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNvcnRlZFNldFB1dEVsZW1lbnQoXG4gICAgICBjYWNoZU5hbWUsXG4gICAgICBzb3J0ZWRTZXROYW1lLFxuICAgICAgdmFsdWUsXG4gICAgICBzY29yZSxcbiAgICAgIG9wdGlvbnM/LnR0bFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBlbGVtZW50cyB0byB0aGUgZ2l2ZW4gc29ydGVkIHNldC4gRm9yIGFueSB2YWx1ZXMgdGhhdCBhbHJlYWR5IGV4aXN0LCBpdFxuICAgKiB0aGUgc2NvcmUgaXMgdXBkYXRlZC4gQ3JlYXRlcyB0aGUgc29ydGVkIHNldCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBzb3J0ZWQgc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc29ydGVkU2V0TmFtZSAtIFRoZSBzb3J0ZWQgc2V0IHRvIGFkZCB0by5cbiAgICogQHBhcmFtIHtNYXA8c3RyaW5nIHwgVWludDhBcnJheSwgbnVtYmVyPnwgUmVjb3JkPHN0cmluZywgbnVtYmVyPn0gZWxlbWVudHMgLSBUaGUgdmFsdWUtPnNjb3JlIHBhaXJzIHRvIGFkZCB0byB0aGUgc29ydGVkIHNldC5cbiAgICogQHBhcmFtIHtTb3J0ZWRTZXRQdXRFbGVtZW50T3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25UdGx9IFtvcHRpb25zLnR0bF0gLSBIb3cgdGhlIFRUTCBzaG91bGQgYmUgbWFuYWdlZC5cbiAgICogUmVmcmVzaGVzIHRoZSBzb3J0ZWQgc2V0J3MgVFRMIHVzaW5nIHRoZSBjbGllbnQncyBkZWZhdWx0IGlmIHRoaXMgaXMgbm90XG4gICAqIHN1cHBsaWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNvcnRlZFNldFB1dEVsZW1lbnRzLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRQdXRFbGVtZW50cy5TdWNjZXNzfSBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRQdXRFbGVtZW50cy5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICogQHJldHVybnNcbiAgICovXG4gIHB1YmxpYyBhc3luYyBzb3J0ZWRTZXRQdXRFbGVtZW50cyhcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBzb3J0ZWRTZXROYW1lOiBzdHJpbmcsXG4gICAgZWxlbWVudHM6XG4gICAgICB8IE1hcDxzdHJpbmcgfCBVaW50OEFycmF5LCBudW1iZXI+XG4gICAgICB8IFJlY29yZDxzdHJpbmcsIG51bWJlcj5cbiAgICAgIHwgQXJyYXk8W3N0cmluZywgbnVtYmVyXT4sXG4gICAgb3B0aW9ucz86IFNvcnRlZFNldFB1dEVsZW1lbnRzT3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlU29ydGVkU2V0UHV0RWxlbWVudHMuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5zb3J0ZWRTZXRQdXRFbGVtZW50cyhcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIHNvcnRlZFNldE5hbWUsXG4gICAgICBlbGVtZW50cyxcbiAgICAgIG9wdGlvbnM/LnR0bFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGVsZW1lbnRzIGluIHRoZSBnaXZlbiBzb3J0ZWQgc2V0IGJ5IGluZGV4IChyYW5rKS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBzb3J0ZWQgc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc29ydGVkU2V0TmFtZSAtIFRoZSBzb3J0ZWQgc2V0IHRvIGZldGNoIGZyb20uXG4gICAqIEBwYXJhbSB7U29ydGVkU2V0RmV0Y2hCeVJhbmtPcHRpb25zfSBvcHRpb25zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdGFydFJhbmtdIC0gVGhlIHJhbmsgb2YgdGhlIGZpcnN0IGVsZW1lbnQgdG9cbiAgICogZmV0Y2guIERlZmF1bHRzIHRvIDAuIFRoaXMgcmFuayBpcyBpbmNsdXNpdmUsIGllIHRoZSBlbGVtZW50IGF0IHRoaXMgcmFua1xuICAgKiB3aWxsIGJlIGZldGNoZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5lbmRSYW5rXSAtIFRoZSByYW5rIG9mIHRoZSBsYXN0IGVsZW1lbnQgdG8gZmV0Y2guXG4gICAqIFRoaXMgcmFuayBpcyBleGNsdXNpdmUsIGllIHRoZSBlbGVtZW50IGF0IHRoaXMgcmFuayB3aWxsIG5vdCBiZSBmZXRjaGVkLlxuICAgKiBEZWZhdWx0cyB0byBudWxsLCB3aGljaCBmZXRjaGVzIHVwIHVudGlsIGFuZCBpbmNsdWRpbmcgdGhlIGxhc3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHtTb3J0ZWRTZXRPcmRlcn0gW29wdGlvbnMub3JkZXJdIC0gVGhlIG9yZGVyIHRvIGZldGNoIHRoZSBlbGVtZW50cyBpbi5cbiAgICogRGVmYXVsdHMgdG8gYXNjZW5kaW5nLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNvcnRlZFNldEZldGNoLlJlc3BvbnNlPn1cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0RmV0Y2guSGl0fSBjb250YWluaW5nIHRoZSByZXF1ZXN0ZWQgZWxlbWVudHMgd2hlbiBmb3VuZC5cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0RmV0Y2guTWlzc30gd2hlbiB0aGUgc29ydGVkIHNldCBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0RmV0Y2guRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc29ydGVkU2V0RmV0Y2hCeVJhbmsoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgc29ydGVkU2V0TmFtZTogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBTb3J0ZWRTZXRGZXRjaEJ5UmFua09wdGlvbnNcbiAgKTogUHJvbWlzZTxDYWNoZVNvcnRlZFNldEZldGNoLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc29ydGVkU2V0RmV0Y2hCeVJhbmsoXG4gICAgICBjYWNoZU5hbWUsXG4gICAgICBzb3J0ZWRTZXROYW1lLFxuICAgICAgb3B0aW9ucz8ub3JkZXIgPz8gU29ydGVkU2V0T3JkZXIuQXNjZW5kaW5nLFxuICAgICAgb3B0aW9ucz8uc3RhcnRSYW5rID8/IDAsXG4gICAgICBvcHRpb25zPy5lbmRSYW5rXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgZWxlbWVudHMgaW4gdGhlIGdpdmVuIHNvcnRlZCBzZXQgYnkgc2NvcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgc29ydGVkIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNvcnRlZFNldE5hbWUgLSBUaGUgc29ydGVkIHNldCB0byBmZXRjaCBmcm9tLlxuICAgKiBAcGFyYW0ge1NvcnRlZFNldEZldGNoQnlTY29yZU9wdGlvbnN9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1pblNjb3JlXSAtIFRoZSBtaW5pbXVtIHNjb3JlIChpbmNsdXNpdmUpIG9mIHRoZVxuICAgKiBlbGVtZW50cyB0byBmZXRjaC4gRGVmYXVsdHMgdG8gbmVnYXRpdmUgaW5maW5pdHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhTY29yZV0gLSBUaGUgbWF4aW11bSBzY29yZSAoaW5jbHVzaXZlKSBvZiB0aGVcbiAgICogZWxlbWVudHMgdG8gZmV0Y2guIERlZmF1bHRzIHRvIHBvc2l0aXZlIGluZmluaXR5LlxuICAgKiBAcGFyYW0ge1NvcnRlZFNldE9yZGVyfSBbb3B0aW9ucy5vcmRlcl0gLSBUaGUgb3JkZXIgdG8gZmV0Y2ggdGhlIGVsZW1lbnRzIGluLlxuICAgKiBEZWZhdWx0cyB0byBhc2NlbmRpbmcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5vZmZzZXRdIC0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGJlZm9yZVxuICAgKiByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnQuIERlZmF1bHRzIHRvIDAuIE5vdGU6IHRoaXMgaXMgbm90IHRoZSByYW5rIG9mXG4gICAqIHRoZSBmaXJzdCBlbGVtZW50IHRvIHJldHVybiwgYnV0IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgdGhlIHJlc3VsdCBzZXRcbiAgICogdG8gc2tpcCBiZWZvcmUgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY291bnRdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJldHVybi5cbiAgICogRGVmYXVsdHMgdG8gdW5kZWZpbmVkLCB3aGljaCByZXR1cm5zIGFsbCBlbGVtZW50cy5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVTb3J0ZWRTZXRGZXRjaC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0RmV0Y2guSGl0fSBjb250YWluaW5nIHRoZSByZXF1ZXN0ZWQgZWxlbWVudHMgd2hlbiBmb3VuZC5cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0RmV0Y2guTWlzc30gd2hlbiB0aGUgc29ydGVkIHNldCBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0RmV0Y2guRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc29ydGVkU2V0RmV0Y2hCeVNjb3JlKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIHNvcnRlZFNldE5hbWU6IHN0cmluZyxcbiAgICBvcHRpb25zPzogU29ydGVkU2V0RmV0Y2hCeVNjb3JlT3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlU29ydGVkU2V0RmV0Y2guUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5zb3J0ZWRTZXRGZXRjaEJ5U2NvcmUoXG4gICAgICBjYWNoZU5hbWUsXG4gICAgICBzb3J0ZWRTZXROYW1lLFxuICAgICAgb3B0aW9ucz8ub3JkZXIgPz8gU29ydGVkU2V0T3JkZXIuQXNjZW5kaW5nLFxuICAgICAgb3B0aW9ucz8ubWluU2NvcmUsXG4gICAgICBvcHRpb25zPy5tYXhTY29yZSxcbiAgICAgIG9wdGlvbnM/Lm9mZnNldCxcbiAgICAgIG9wdGlvbnM/LmNvdW50XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb29rIHVwIHRoZSByYW5rIG9mIGFuIGVsZW1lbnQgaW4gdGhlIHNvcnRlZCBzZXQsIGJ5IHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBzb3J0ZWQgc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc29ydGVkU2V0TmFtZSAtIFRoZSBzb3J0ZWQgc2V0IHRvIGZldGNoIGZyb20uXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgd2hvc2UgcmFuayB3ZSBhcmUgcmV0cmlldmluZy5cbiAgICogQHBhcmFtIHtTb3J0ZWRTZXRHZXRSYW5rT3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1NvcnRlZFNldE9yZGVyfSBbb3B0aW9ucy5vcmRlcl0gLSBUaGUgb3JkZXIgaW4gd2hpY2ggc29ydGVkIHNldCB3aWxsIGJlIHNvcnRlZCB0byBkZXRlcm1pbmUgdGhlIHJhbmsuXG4gICAqIERlZmF1bHRzIHRvIGFzY2VuZGluZy5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVTb3J0ZWRTZXRHZXRSYW5rLlJlc3BvbnNlPn1cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0R2V0UmFuay5IaXR9IGNvbnRhaW5pbmcgdGhlIHJhbmsgb2YgdGhlIHJlcXVlc3RlZCBlbGVtZW50cyB3aGVuIGZvdW5kLlxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRHZXRSYW5rLk1pc3N9IHdoZW4gdGhlIGVsZW1lbnQgZG9lcyBub3QgZXhpc3QuXG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldEdldFJhbmsuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc29ydGVkU2V0R2V0UmFuayhcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBzb3J0ZWRTZXROYW1lOiBzdHJpbmcsXG4gICAgdmFsdWU6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgb3B0aW9ucz86IFNvcnRlZFNldEdldFJhbmtPcHRpb25zXG4gICk6IFByb21pc2U8Q2FjaGVTb3J0ZWRTZXRHZXRSYW5rLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc29ydGVkU2V0R2V0UmFuayhcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIHNvcnRlZFNldE5hbWUsXG4gICAgICB2YWx1ZSxcbiAgICAgIG9wdGlvbnM/Lm9yZGVyXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb29rIHVwIHRoZSBzY29yZSBvZiBhbiBlbGVtZW50IGluIHRoZSBzb3J0ZWQgc2V0LCBieSB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgc29ydGVkIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNvcnRlZFNldE5hbWUgLSBUaGUgc29ydGVkIHNldCB0byBmZXRjaCBmcm9tLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IHZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IHdob3NlIHNjb3JlIHdlIGFyZSByZXRyaWV2aW5nLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNvcnRlZFNldEdldFNjb3JlLlJlc3BvbnNlPn1cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0R2V0U2NvcmUuSGl0fSBjb250YWluaW5nIHRoZSBzY29yZSBvZiB0aGUgcmVxdWVzdGVkIGVsZW1lbnQgd2hlbiBmb3VuZC5cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0R2V0U2NvcmUuTWlzc30gd2hlbiB0aGUgZWxlbWVudCBvciBjb2xsZWN0aW9uIGRvZXMgbm90IGV4aXN0LlxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRHZXRTY29yZS5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzb3J0ZWRTZXRHZXRTY29yZShcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBzb3J0ZWRTZXROYW1lOiBzdHJpbmcsXG4gICAgdmFsdWU6IHN0cmluZyB8IFVpbnQ4QXJyYXlcbiAgKTogUHJvbWlzZTxDYWNoZVNvcnRlZFNldEdldFNjb3JlLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc29ydGVkU2V0R2V0U2NvcmUoY2FjaGVOYW1lLCBzb3J0ZWRTZXROYW1lLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogTG9vayB1cCB0aGUgc2NvcmVzIG9mIG11bHRpcGxlIGVsZW1lbnRzIGluIHRoZSBzb3J0ZWQgc2V0LCBieSB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIHNvcnRlZCBzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3J0ZWRTZXROYW1lIC0gVGhlIHNvcnRlZCBzZXQgdG8gZmV0Y2ggZnJvbS5cbiAgICogQHBhcmFtIHtzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXX0gdmFsdWVzIC0gVGhlIHZhbHVlcyBvZiB0aGUgZWxlbWVudHMgd2hvc2Ugc2NvcmVzIHdlIGFyZSByZXRyaWV2aW5nLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNvcnRlZFNldEdldFNjb3Jlcy5SZXNwb25zZT59XG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldEdldFNjb3Jlcy5IaXR9IGNvbnRhaW5pbmcgdGhlIHNjb3JlcyBvZiB0aGUgcmVxdWVzdGVkIGVsZW1lbnRzIHdoZW4gZm91bmQuXG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldEdldFNjb3Jlcy5NaXNzfSB3aGVuIHRoZSBlbGVtZW50IG9yIGNvbGxlY3Rpb24gZG9lcyBub3QgZXhpc3QuXG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldEdldFNjb3Jlcy5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzb3J0ZWRTZXRHZXRTY29yZXMoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgc29ydGVkU2V0TmFtZTogc3RyaW5nLFxuICAgIHZhbHVlczogc3RyaW5nW10gfCBVaW50OEFycmF5W11cbiAgKTogUHJvbWlzZTxDYWNoZVNvcnRlZFNldEdldFNjb3Jlcy5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNvcnRlZFNldEdldFNjb3JlcyhjYWNoZU5hbWUsIHNvcnRlZFNldE5hbWUsIHZhbHVlcyk7XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVtZW50IHRoZSBzY29yZSBvZiBhbiBlbGVtZW50IGluIHRoZSBzb3J0ZWQgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIHNvcnRlZCBzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3J0ZWRTZXROYW1lIC0gVGhlIHNvcnRlZCBzZXQgdG8gZmV0Y2ggZnJvbS5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCB3aG9zZSBzY29yZSB3ZSBhcmUgaW5jcmVtZW50aW5nLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gVGhlIHF1YW50aXR5IHRvIGFkZCB0byB0aGUgc2NvcmUuIE1heSBiZSBwb3NpdGl2ZSxcbiAgICogbmVnYXRpdmUsIG9yIHplcm8uIERlZmF1bHRzIHRvIDEuXG4gICAqIEBwYXJhbSB7U29ydGVkU2V0SW5jcmVtZW50T3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25UdGx9IFtvcHRpb25zLnR0bF0gLSBIb3cgdGhlIFRUTCBzaG91bGQgYmUgbWFuYWdlZC5cbiAgICogUmVmcmVzaGVzIHRoZSBzb3J0ZWQgc2V0J3MgVFRMIHVzaW5nIHRoZSBjbGllbnQncyBkZWZhdWx0IGlmIHRoaXMgaXMgbm90XG4gICAqIHN1cHBsaWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNvcnRlZFNldEluY3JlbWVudFNjb3JlLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRJbmNyZW1lbnRTY29yZS5TdWNjZXNzfSBjb250YWluaW5nIHRoZSBpbmNyZW1lbnRlZCBzY29yZVxuICAgKiBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRJbmNyZW1lbnRTY29yZS5FcnJvcn0gb24gZmFpbHVyZS4gSW5jcmVtZW50aW5nIGEgc2NvcmVcbiAgICogdGhhdCB3YXMgbm90IHNldCB1c2luZyB0aGlzIG1ldGhvZCBvciBpcyBub3QgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZlxuICAgKiBhbiBpbnRlZ2VyIHJlc3VsdHMgaW4gYSBmYWlsdXJlIHdpdGggYSBGYWlsZWRQcmVjb25kaXRpb25FeGNlcHRpb24gZXJyb3IuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc29ydGVkU2V0SW5jcmVtZW50U2NvcmUoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgc29ydGVkU2V0TmFtZTogc3RyaW5nLFxuICAgIHZhbHVlOiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIGFtb3VudD86IG51bWJlcixcbiAgICBvcHRpb25zPzogU29ydGVkU2V0SW5jcmVtZW50T3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlU29ydGVkU2V0SW5jcmVtZW50U2NvcmUuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5zb3J0ZWRTZXRJbmNyZW1lbnRTY29yZShcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIHNvcnRlZFNldE5hbWUsXG4gICAgICB2YWx1ZSxcbiAgICAgIGFtb3VudCB8fCAxLFxuICAgICAgb3B0aW9ucz8udHRsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZWxlbWVudCBmcm9tIHRoZSBzb3J0ZWQgc2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgc29ydGVkIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNvcnRlZFNldE5hbWUgLSBUaGUgc29ydGVkIHNldCB0byByZW1vdmUgZnJvbS5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCB0byByZW1vdmUgZnJvbSB0aGUgc2V0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNvcnRlZFNldFJlbW92ZUVsZW1lbnQuUmVzcG9uc2U+fVxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRSZW1vdmVFbGVtZW50LlN1Y2Nlc3N9IGlmIHRoZSBlbGVtZW50IHdhcyBzdWNjZXNzZnVsbHkgcmVtb3ZlZFxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRJbmNyZW1lbnRTY29yZS5FcnJvcn0gb24gZmFpbHVyZVxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNvcnRlZFNldFJlbW92ZUVsZW1lbnQoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgc29ydGVkU2V0TmFtZTogc3RyaW5nLFxuICAgIHZhbHVlOiBzdHJpbmcgfCBVaW50OEFycmF5XG4gICk6IFByb21pc2U8Q2FjaGVTb3J0ZWRTZXRSZW1vdmVFbGVtZW50LlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc29ydGVkU2V0UmVtb3ZlRWxlbWVudChjYWNoZU5hbWUsIHNvcnRlZFNldE5hbWUsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgbXVsdGlwbGUgZWxlbWVudHMgZnJvbSB0aGUgc29ydGVkIHNldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIHNvcnRlZCBzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3J0ZWRTZXROYW1lIC0gVGhlIHNvcnRlZCBzZXQgdG8gcmVtb3ZlIGZyb20uXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gdmFsdWVzIC0gVGhlIHZhbHVlcyBvZiB0aGUgZWxlbWVudHMgdG8gcmVtb3ZlIGZyb20gdGhlIHNldC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVTb3J0ZWRTZXRSZW1vdmVFbGVtZW50LlJlc3BvbnNlPn1cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0UmVtb3ZlRWxlbWVudC5TdWNjZXNzfSBpZiB0aGUgZWxlbWVudHMgd2VyZSBzdWNjZXNzZnVsbHkgcmVtb3ZlZFxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRJbmNyZW1lbnRTY29yZS5FcnJvcn0gb24gZmFpbHVyZVxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNvcnRlZFNldFJlbW92ZUVsZW1lbnRzKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIHNvcnRlZFNldE5hbWU6IHN0cmluZyxcbiAgICB2YWx1ZXM6IHN0cmluZ1tdIHwgVWludDhBcnJheVtdXG4gICk6IFByb21pc2U8Q2FjaGVTb3J0ZWRTZXRSZW1vdmVFbGVtZW50cy5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNvcnRlZFNldFJlbW92ZUVsZW1lbnRzKFxuICAgICAgY2FjaGVOYW1lLFxuICAgICAgc29ydGVkU2V0TmFtZSxcbiAgICAgIHZhbHVlc1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggbGVuZ3RoIChudW1iZXIgb2YgaXRlbXMpIG9mIHNvcnRlZCBzZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBzb3J0ZWQgc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc29ydGVkU2V0TmFtZSAtIFRoZSBzb3J0ZWQgc2V0IG5hbWUuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlU29ydGVkU2V0TGVuZ3RoLlJlc3BvbnNlPn1cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0TGVuZ3RoLkhpdH0gY29udGFpbmluZyB0aGUgbGVuZ3RoIGlmIHRoZSBzb3J0ZWQgc2V0IGV4aXN0cy5cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0TGVuZ3RoLk1pc3N9IGlmIHRoZSBzb3J0ZWQgc2V0IGRvZXMgbm90IGV4aXN0LlxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRMZW5ndGguRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc29ydGVkU2V0TGVuZ3RoKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIHNvcnRlZFNldE5hbWU6IHN0cmluZ1xuICApOiBQcm9taXNlPENhY2hlU29ydGVkU2V0TGVuZ3RoLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc29ydGVkU2V0TGVuZ3RoKGNhY2hlTmFtZSwgc29ydGVkU2V0TmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggbGVuZ3RoIChudW1iZXIgb2YgaXRlbXMpIG9mIHNvcnRlZCBzZXQgd2l0aGluIHRoZSBwcm92aWRlZCBzY29yZSByYW5nZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIHNvcnRlZCBzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3J0ZWRTZXROYW1lIC0gVGhlIHNvcnRlZCBzZXQgbmFtZS5cbiAgICogQHBhcmFtIHtTb3J0ZWRTZXRMZW5ndGhCeVNjb3JlT3B0aW9uc30gb3B0aW9ucyAtIE9wdGlvbmFsIHBhcmFtZXRlciBmb3Igc3BlY2lmeWluZyB0aGUgc2NvcmUgcmFuZ2UgdG8gc2VhcmNoIGluLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWluU2NvcmVdIC0gVGhlIGxvd2VyIGJvdW5kIG9uIHRoZSBzY29yZSByYW5nZSB0byBzZWFyY2ggaW4uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhTY29yZV0gLSBUaGUgdXBwZXIgYm91bmQgb24gdGhlIHNjb3JlIHJhbmdlIHRvIHNlYXJjaCBpbi5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVTb3J0ZWRTZXRMZW5ndGhCeVNjb3JlLlJlc3BvbnNlPn1cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0TGVuZ3RoQnlTY29yZS5IaXR9IGNvbnRhaW5pbmcgdGhlIGxlbmd0aCBpZiB0aGUgc29ydGVkIHNldCBleGlzdHMuXG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldExlbmd0aEJ5U2NvcmUuTWlzc30gaWYgdGhlIHNvcnRlZCBzZXQgZG9lcyBub3QgZXhpc3QuXG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldExlbmd0aEJ5U2NvcmUuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc29ydGVkU2V0TGVuZ3RoQnlTY29yZShcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBzb3J0ZWRTZXROYW1lOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IFNvcnRlZFNldExlbmd0aEJ5U2NvcmVPcHRpb25zXG4gICk6IFByb21pc2U8Q2FjaGVTb3J0ZWRTZXRMZW5ndGhCeVNjb3JlLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc29ydGVkU2V0TGVuZ3RoQnlTY29yZShcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIHNvcnRlZFNldE5hbWUsXG4gICAgICBvcHRpb25zPy5taW5TY29yZSxcbiAgICAgIG9wdGlvbnM/Lm1heFNjb3JlXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHR5cGUgb2YgdGhlIGtleSBpbiB0aGUgY2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBrZXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IGZvciB3aGljaCB0eXBlIGlzIHJlcXVlc3RlZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVJdGVtR2V0VHlwZS5SZXNwb25zZT59XG4gICAqIHtAbGluayBDYWNoZUl0ZW1HZXRUeXBlLkhpdH0gY29udGFpbmluZyB0eXBlIG9mIGtleSB3aGVuIGZvdW5kLlxuICAgKiB7QGxpbmsgQ2FjaGVJdGVtR2V0VHlwZS5NaXNzfSB3aGVuIHRoZSBrZXkgZG9lcyBub3QgZXhpc3QuXG4gICAqIHtAbGluayBDYWNoZUl0ZW1HZXRUeXBlLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGl0ZW1HZXRUeXBlKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGtleTogc3RyaW5nIHwgVWludDhBcnJheVxuICApOiBQcm9taXNlPENhY2hlSXRlbUdldFR5cGUuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5pdGVtR2V0VHlwZShjYWNoZU5hbWUsIGtleSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSByZW1haW5pbmcgdHRsIG9mIHRoZSBrZXkgaW4gdGhlIGNhY2hlIGluIG1pbGxpc2Vjb25kcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBrZXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IGZvciB3aGljaCB0aGUgdHRsIHJlbWFpbmluZyBpcyByZXF1ZXN0ZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlSXRlbUdldFR0bC5SZXNwb25zZT59XG4gICAqIHtAbGluayBDYWNoZUl0ZW1HZXRUdGwuSGl0fSBjb250YWluaW5nIHR0bCByZW1haW5pbmcgb2Yga2V5IHdoZW4gZm91bmQuXG4gICAqIHtAbGluayBDYWNoZUl0ZW1HZXRUdGwuTWlzc30gd2hlbiB0aGUga2V5IGRvZXMgbm90IGV4aXN0LlxuICAgKiB7QGxpbmsgQ2FjaGVJdGVtR2V0VHRsLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGl0ZW1HZXRUdGwoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAga2V5OiBzdHJpbmcgfCBVaW50OEFycmF5XG4gICk6IFByb21pc2U8Q2FjaGVJdGVtR2V0VHRsLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuaXRlbUdldFR0bChjYWNoZU5hbWUsIGtleSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHByb3ZpZGVkIGtleSBleGlzdHMgaW4gdGhlIGNhY2hlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgdG8gbG9vayBpbi5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSBrZXkgLSBUaGUga2V5IHRvIGxvb2sgdXAuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlS2V5RXhpc3RzLlJlc3BvbnNlPn1cbiAgICoge0BsaW5rIENhY2hlS2V5RXhpc3RzLlN1Y2Nlc3N9IHJldHVybnMgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGtleSB3YXMgZm91bmQuXG4gICAqIHtAbGluayBDYWNoZUtleUV4aXN0cy5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBrZXlFeGlzdHMoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAga2V5OiBzdHJpbmcgfCBVaW50OEFycmF5XG4gICk6IFByb21pc2U8Q2FjaGVLZXlFeGlzdHMuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5rZXlFeGlzdHMoY2FjaGVOYW1lLCBrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBwcm92aWRlZCBrZXlzIGV4aXN0IGluIHRoZSBjYWNoZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIHRvIGxvb2sgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nW10gfCBVaW50OEFycmF5W119IGtleXMgLSBUaGUga2V5cyB0byBsb29rIHVwLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZUtleXNFeGlzdC5SZXNwb25zZT59XG4gICAqIHtAbGluayBDYWNoZUtleXNFeGlzdC5TdWNjZXNzfSByZXR1cm5zIGxpc3Qgb2YgYm9vbGVhbnMgaW5kaWNhdGluZyB3aGV0aGVyIGVhY2gga2V5IHdhcyBmb3VuZC5cbiAgICoge0BsaW5rIENhY2hlS2V5c0V4aXN0LkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGtleXNFeGlzdChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBrZXlzOiBzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXVxuICApOiBQcm9taXNlPENhY2hlS2V5c0V4aXN0LlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQua2V5c0V4aXN0KGNhY2hlTmFtZSwga2V5cyk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSB0dGwgb2YgdGhlIGtleSBpbiB0aGUgY2FjaGUgaW4gbWlsbGlzZWNvbmRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIGtleS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgZm9yIHdoaWNoIHRoZSB0dGwgcmVtYWluaW5nIGlzIHJlcXVlc3RlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHR0bE1pbGxpc2Vjb25kcyAtIFRoZSB0dGwgaW4gbWlsbGlzZWNvbmRzIHRoYXQgc2hvdWxkIG92ZXJ3cml0ZSB0aGUgY3VycmVudCB0dGwuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlVXBkYXRlVHRsLlJlc3BvbnNlPn1cbiAgICoge0BsaW5rIENhY2hlVXBkYXRlVHRsLlNldH0gd2hlbiB0aGUgdHRsIHdhcyBzdWNjZXNzZnVsbHkgb3ZlcndyaXR0ZW4uXG4gICAqIHtAbGluayBDYWNoZVVwZGF0ZVR0bC5NaXNzfSB3aGVuIHRoZSBrZXkgZG9lcyBub3QgZXhpc3QuXG4gICAqIHtAbGluayBDYWNoZVVwZGF0ZVR0bC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyB1cGRhdGVUdGwoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAga2V5OiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIHR0bE1pbGxpc2Vjb25kczogbnVtYmVyXG4gICk6IFByb21pc2U8Q2FjaGVVcGRhdGVUdGwuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC51cGRhdGVUdGwoY2FjaGVOYW1lLCBrZXksIHR0bE1pbGxpc2Vjb25kcyk7XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVhc2UgdGhlIHR0bCBvZiB0aGUga2V5IGluIHRoZSBjYWNoZSBpbiBtaWxsaXNlY29uZHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUga2V5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBmb3Igd2hpY2ggdGhlIHR0bCByZW1haW5pbmcgaXMgcmVxdWVzdGVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdHRsTWlsbGlzZWNvbmRzIC0gVGhlIHR0bCBpbiBtaWxsaXNlY29uZHMgdGhhdCBzaG91bGRcbiAgICogb3ZlcndyaXRlIHRoZSBjdXJyZW50IHR0bC4gU2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiB0aGUgY3VycmVudCB0dGwuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlSW5jcmVhc2VUdGwuUmVzcG9uc2U+fVxuICAgKiB7QGxpbmsgQ2FjaGVJbmNyZWFzZVR0bC5TZXR9IHdoZW4gdGhlIHR0bCB3YXMgc3VjY2Vzc2Z1bGx5IGluY3JlYXNlZC5cbiAgICoge0BsaW5rIENhY2hlSW5jcmVhc2VUdGwuTWlzc30gd2hlbiB0aGUga2V5IGRvZXMgbm90IGV4aXN0LlxuICAgKiB7QGxpbmsgQ2FjaGVJbmNyZWFzZVR0bC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBpbmNyZWFzZVR0bChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBrZXk6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgdHRsTWlsbGlzZWNvbmRzOiBudW1iZXJcbiAgKTogUHJvbWlzZTxDYWNoZUluY3JlYXNlVHRsLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuaW5jcmVhc2VUdGwoY2FjaGVOYW1lLCBrZXksIHR0bE1pbGxpc2Vjb25kcyk7XG4gIH1cblxuICAvKipcbiAgICogRGVjcmVhc2UgdGhlIHR0bCBvZiB0aGUga2V5IGluIHRoZSBjYWNoZSBpbiBtaWxsaXNlY29uZHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUga2V5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBmb3Igd2hpY2ggdGhlIHR0bCByZW1haW5pbmcgaXMgcmVxdWVzdGVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdHRsTWlsbGlzZWNvbmRzIC0gVGhlIHR0bCBpbiBtaWxsaXNlY29uZHMgdGhhdCBzaG91bGRcbiAgICogb3ZlcndyaXRlIHRoZSBjdXJyZW50IHR0bC4gU2hvdWxkIGJlIGxlc3MgdGhhbiB0aGUgY3VycmVudCB0dGwuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlRGVjcmVhc2VUdGwuUmVzcG9uc2U+fVxuICAgKiB7QGxpbmsgQ2FjaGVEZWNyZWFzZVR0bC5TZXR9IHdoZW4gdGhlIHR0bCB3YXMgc3VjY2Vzc2Z1bGx5IGRlY3JlYXNlZC5cbiAgICoge0BsaW5rIENhY2hlRGVjcmVhc2VUdGwuTWlzc30gd2hlbiB0aGUga2V5IGRvZXMgbm90IGV4aXN0LlxuICAgKiB7QGxpbmsgQ2FjaGVEZWNyZWFzZVR0bC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBkZWNyZWFzZVR0bChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBrZXk6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgdHRsTWlsbGlzZWNvbmRzOiBudW1iZXJcbiAgKTogUHJvbWlzZTxDYWNoZURlY3JlYXNlVHRsLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuZGVjcmVhc2VUdGwoY2FjaGVOYW1lLCBrZXksIHR0bE1pbGxpc2Vjb25kcyk7XG4gIH1cblxuICBwcml2YXRlIGdldE5leHREYXRhQ2xpZW50KCk6IElEYXRhQ2xpZW50IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmRhdGFDbGllbnRzW3RoaXMubmV4dERhdGFDbGllbnRJbmRleF07XG4gICAgdGhpcy5uZXh0RGF0YUNsaWVudEluZGV4ID1cbiAgICAgICh0aGlzLm5leHREYXRhQ2xpZW50SW5kZXggKyAxKSAlIHRoaXMuZGF0YUNsaWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBjbGllbnQ7XG4gIH1cblxuICBhYnN0cmFjdCBjbG9zZSgpOiB2b2lkO1xufVxuIl19