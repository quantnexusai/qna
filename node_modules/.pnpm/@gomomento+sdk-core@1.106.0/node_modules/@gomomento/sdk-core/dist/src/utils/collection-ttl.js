"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CollectionTtl = void 0;
const utils_1 = require("../internal/utils");
const time_1 = require("./time");
/** Represents the desired behavior for managing the TTL on collection
 *  objects (dictionaries, lists, sets) in your cache.
 *
 *  For cache operations that modify a collection, there are a few things
 *  to consider.  The first time the collection is created, we need to
 *  set a TTL on it.  For subsequent operations that modify the collection
 *  you may choose to update the TTL in order to prolong the life of the
 *  cached collection object, or you may choose to leave the TTL unmodified
 *  in order to ensure that the collection expires at the original TTL.
 *
 *  The default behavior is to refresh the TTL (to prolong the life of the
 *  collection) each time it is written.  This behavior can be modified
 *  by calling CollectionTtl.withNoRefreshTtlOnUpdates().
 *
 *  A null TTL means to use the client's TTL.
 */
class CollectionTtl {
    /**
     * If refreshTtl is true, the client must update the collection's TTL
     * when it modifies a collection.
     * A null ttl means to use the client's TTL.
     * @param {number | null} [ttlSeconds=null]
     * @param {boolean} [refreshTtl=true]
     */
    constructor(ttlSeconds = null, refreshTtl = true) {
        if (ttlSeconds !== null) {
            (0, utils_1.validateTtlSeconds)(ttlSeconds);
        }
        this._refreshTtl = refreshTtl;
        this._ttlSeconds = ttlSeconds;
    }
    /** Time-to-live, in seconds.
     * @returns {number | null}
     */
    ttlSeconds() {
        return this._ttlSeconds;
    }
    /** Time-to-live, in milliseconds.
     * @returns {number | null}
     */
    ttlMilliseconds() {
        return this._ttlSeconds === null
            ? null
            : (0, time_1.secondsToMilliseconds)(this._ttlSeconds);
    }
    /** Whether or not to refresh a collection's TTL when it's modified.
     * @returns {boolean}
     */
    refreshTtl() {
        return this._refreshTtl;
    }
    /** The default way to handle TTLs for collections. The client's default TTL
     *  will be used, and the TTL for the collection will be refreshed any
     *  time the collection is modified.
     * @constructor
     * @returns {CollectionTtl}
     */
    static fromCacheTtl() {
        return new CollectionTtl(null, true);
    }
    /** Constructs a CollectionTtl with the specified TTL. The TTL
     *  for the collection will be refreshed any time the collection is
     *  modified.
     * @constructor
     * @param {number} [ttlSeconds]
     * @returns {CollectionTtl}
     */
    static of(ttlSeconds) {
        return new CollectionTtl(ttlSeconds, true);
    }
    /** Constructs a CollectionTtl with the specified TTL.
     *  Will only refresh if the TTL is provided.
     * @constructor
     * @param {number | null} [ttlSeconds=null]
     * @returns {CollectionTtl}
     */
    static refreshTtlIfProvided(ttlSeconds = null) {
        return new CollectionTtl(ttlSeconds, ttlSeconds !== null);
    }
    /** Copies the CollectionTtl, but it will refresh the TTL when
     *  the collection is modified.
     * @returns {CollectionTtl}
     */
    withRefreshTtlOnUpdates() {
        return new CollectionTtl(this._ttlSeconds, true);
    }
    /** Copies the CollectionTTL, but the TTL will not be refreshed
     *  when the collection is modified. Use this if you want to ensure
     *  that your collection expires at the originally specified time, even
     *  if you make modifications to the value of the collection.
     * @returns {CollectionTtl}
     */
    withNoRefreshTtlOnUpdates() {
        return new CollectionTtl(this._ttlSeconds, false);
    }
    /** A string represenation of the CollectionTtl for debugging purposes.
     * @return {CollectionTtl}
     */
    toString() {
        return `ttl: ${this._ttlSeconds || 'null'}, refreshTtl: ${this._refreshTtl ? 'true' : 'false'}`;
    }
}
exports.CollectionTtl = CollectionTtl;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sbGVjdGlvbi10dGwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdXRpbHMvY29sbGVjdGlvbi10dGwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsNkNBQXFEO0FBQ3JELGlDQUE2QztBQUU3Qzs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFDSCxNQUFhLGFBQWE7SUFJeEI7Ozs7OztPQU1HO0lBQ0gsWUFBWSxhQUE0QixJQUFJLEVBQUUsVUFBVSxHQUFHLElBQUk7UUFDN0QsSUFBSSxVQUFVLEtBQUssSUFBSSxFQUFFO1lBQ3ZCLElBQUEsMEJBQWtCLEVBQUMsVUFBVSxDQUFDLENBQUM7U0FDaEM7UUFDRCxJQUFJLENBQUMsV0FBVyxHQUFHLFVBQVUsQ0FBQztRQUM5QixJQUFJLENBQUMsV0FBVyxHQUFHLFVBQVUsQ0FBQztJQUNoQyxDQUFDO0lBRUQ7O09BRUc7SUFDSSxVQUFVO1FBQ2YsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDO0lBQzFCLENBQUM7SUFFRDs7T0FFRztJQUNJLGVBQWU7UUFDcEIsT0FBTyxJQUFJLENBQUMsV0FBVyxLQUFLLElBQUk7WUFDOUIsQ0FBQyxDQUFDLElBQUk7WUFDTixDQUFDLENBQUMsSUFBQSw0QkFBcUIsRUFBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDOUMsQ0FBQztJQUVEOztPQUVHO0lBQ0ksVUFBVTtRQUNmLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQztJQUMxQixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxNQUFNLENBQUMsWUFBWTtRQUN4QixPQUFPLElBQUksYUFBYSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztJQUN2QyxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFrQjtRQUNqQyxPQUFPLElBQUksYUFBYSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxNQUFNLENBQUMsb0JBQW9CLENBQ2hDLGFBQTRCLElBQUk7UUFFaEMsT0FBTyxJQUFJLGFBQWEsQ0FBQyxVQUFVLEVBQUUsVUFBVSxLQUFLLElBQUksQ0FBQyxDQUFDO0lBQzVELENBQUM7SUFFRDs7O09BR0c7SUFDSSx1QkFBdUI7UUFDNUIsT0FBTyxJQUFJLGFBQWEsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ25ELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLHlCQUF5QjtRQUM5QixPQUFPLElBQUksYUFBYSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDcEQsQ0FBQztJQUVEOztPQUVHO0lBQ0ksUUFBUTtRQUNiLE9BQU8sUUFBUSxJQUFJLENBQUMsV0FBVyxJQUFJLE1BQU0saUJBQ3ZDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsT0FDOUIsRUFBRSxDQUFDO0lBQ0wsQ0FBQztDQUNGO0FBckdELHNDQXFHQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dmFsaWRhdGVUdGxTZWNvbmRzfSBmcm9tICcuLi9pbnRlcm5hbC91dGlscyc7XG5pbXBvcnQge3NlY29uZHNUb01pbGxpc2Vjb25kc30gZnJvbSAnLi90aW1lJztcblxuLyoqIFJlcHJlc2VudHMgdGhlIGRlc2lyZWQgYmVoYXZpb3IgZm9yIG1hbmFnaW5nIHRoZSBUVEwgb24gY29sbGVjdGlvblxuICogIG9iamVjdHMgKGRpY3Rpb25hcmllcywgbGlzdHMsIHNldHMpIGluIHlvdXIgY2FjaGUuXG4gKlxuICogIEZvciBjYWNoZSBvcGVyYXRpb25zIHRoYXQgbW9kaWZ5IGEgY29sbGVjdGlvbiwgdGhlcmUgYXJlIGEgZmV3IHRoaW5nc1xuICogIHRvIGNvbnNpZGVyLiAgVGhlIGZpcnN0IHRpbWUgdGhlIGNvbGxlY3Rpb24gaXMgY3JlYXRlZCwgd2UgbmVlZCB0b1xuICogIHNldCBhIFRUTCBvbiBpdC4gIEZvciBzdWJzZXF1ZW50IG9wZXJhdGlvbnMgdGhhdCBtb2RpZnkgdGhlIGNvbGxlY3Rpb25cbiAqICB5b3UgbWF5IGNob29zZSB0byB1cGRhdGUgdGhlIFRUTCBpbiBvcmRlciB0byBwcm9sb25nIHRoZSBsaWZlIG9mIHRoZVxuICogIGNhY2hlZCBjb2xsZWN0aW9uIG9iamVjdCwgb3IgeW91IG1heSBjaG9vc2UgdG8gbGVhdmUgdGhlIFRUTCB1bm1vZGlmaWVkXG4gKiAgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgdGhlIGNvbGxlY3Rpb24gZXhwaXJlcyBhdCB0aGUgb3JpZ2luYWwgVFRMLlxuICpcbiAqICBUaGUgZGVmYXVsdCBiZWhhdmlvciBpcyB0byByZWZyZXNoIHRoZSBUVEwgKHRvIHByb2xvbmcgdGhlIGxpZmUgb2YgdGhlXG4gKiAgY29sbGVjdGlvbikgZWFjaCB0aW1lIGl0IGlzIHdyaXR0ZW4uICBUaGlzIGJlaGF2aW9yIGNhbiBiZSBtb2RpZmllZFxuICogIGJ5IGNhbGxpbmcgQ29sbGVjdGlvblR0bC53aXRoTm9SZWZyZXNoVHRsT25VcGRhdGVzKCkuXG4gKlxuICogIEEgbnVsbCBUVEwgbWVhbnMgdG8gdXNlIHRoZSBjbGllbnQncyBUVEwuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb2xsZWN0aW9uVHRsIHtcbiAgcHJpdmF0ZSByZWFkb25seSBfdHRsU2Vjb25kczogbnVtYmVyIHwgbnVsbDtcbiAgcHJpdmF0ZSByZWFkb25seSBfcmVmcmVzaFR0bDogYm9vbGVhbjtcblxuICAvKipcbiAgICogSWYgcmVmcmVzaFR0bCBpcyB0cnVlLCB0aGUgY2xpZW50IG11c3QgdXBkYXRlIHRoZSBjb2xsZWN0aW9uJ3MgVFRMXG4gICAqIHdoZW4gaXQgbW9kaWZpZXMgYSBjb2xsZWN0aW9uLlxuICAgKiBBIG51bGwgdHRsIG1lYW5zIHRvIHVzZSB0aGUgY2xpZW50J3MgVFRMLlxuICAgKiBAcGFyYW0ge251bWJlciB8IG51bGx9IFt0dGxTZWNvbmRzPW51bGxdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlZnJlc2hUdGw9dHJ1ZV1cbiAgICovXG4gIGNvbnN0cnVjdG9yKHR0bFNlY29uZHM6IG51bWJlciB8IG51bGwgPSBudWxsLCByZWZyZXNoVHRsID0gdHJ1ZSkge1xuICAgIGlmICh0dGxTZWNvbmRzICE9PSBudWxsKSB7XG4gICAgICB2YWxpZGF0ZVR0bFNlY29uZHModHRsU2Vjb25kcyk7XG4gICAgfVxuICAgIHRoaXMuX3JlZnJlc2hUdGwgPSByZWZyZXNoVHRsO1xuICAgIHRoaXMuX3R0bFNlY29uZHMgPSB0dGxTZWNvbmRzO1xuICB9XG5cbiAgLyoqIFRpbWUtdG8tbGl2ZSwgaW4gc2Vjb25kcy5cbiAgICogQHJldHVybnMge251bWJlciB8IG51bGx9XG4gICAqL1xuICBwdWJsaWMgdHRsU2Vjb25kcygpOiBudW1iZXIgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5fdHRsU2Vjb25kcztcbiAgfVxuXG4gIC8qKiBUaW1lLXRvLWxpdmUsIGluIG1pbGxpc2Vjb25kcy5cbiAgICogQHJldHVybnMge251bWJlciB8IG51bGx9XG4gICAqL1xuICBwdWJsaWMgdHRsTWlsbGlzZWNvbmRzKCk6IG51bWJlciB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLl90dGxTZWNvbmRzID09PSBudWxsXG4gICAgICA/IG51bGxcbiAgICAgIDogc2Vjb25kc1RvTWlsbGlzZWNvbmRzKHRoaXMuX3R0bFNlY29uZHMpO1xuICB9XG5cbiAgLyoqIFdoZXRoZXIgb3Igbm90IHRvIHJlZnJlc2ggYSBjb2xsZWN0aW9uJ3MgVFRMIHdoZW4gaXQncyBtb2RpZmllZC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBwdWJsaWMgcmVmcmVzaFR0bCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fcmVmcmVzaFR0bDtcbiAgfVxuXG4gIC8qKiBUaGUgZGVmYXVsdCB3YXkgdG8gaGFuZGxlIFRUTHMgZm9yIGNvbGxlY3Rpb25zLiBUaGUgY2xpZW50J3MgZGVmYXVsdCBUVExcbiAgICogIHdpbGwgYmUgdXNlZCwgYW5kIHRoZSBUVEwgZm9yIHRoZSBjb2xsZWN0aW9uIHdpbGwgYmUgcmVmcmVzaGVkIGFueVxuICAgKiAgdGltZSB0aGUgY29sbGVjdGlvbiBpcyBtb2RpZmllZC5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEByZXR1cm5zIHtDb2xsZWN0aW9uVHRsfVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tQ2FjaGVUdGwoKTogQ29sbGVjdGlvblR0bCB7XG4gICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uVHRsKG51bGwsIHRydWUpO1xuICB9XG5cbiAgLyoqIENvbnN0cnVjdHMgYSBDb2xsZWN0aW9uVHRsIHdpdGggdGhlIHNwZWNpZmllZCBUVEwuIFRoZSBUVExcbiAgICogIGZvciB0aGUgY29sbGVjdGlvbiB3aWxsIGJlIHJlZnJlc2hlZCBhbnkgdGltZSB0aGUgY29sbGVjdGlvbiBpc1xuICAgKiAgbW9kaWZpZWQuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge251bWJlcn0gW3R0bFNlY29uZHNdXG4gICAqIEByZXR1cm5zIHtDb2xsZWN0aW9uVHRsfVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBvZih0dGxTZWNvbmRzOiBudW1iZXIpOiBDb2xsZWN0aW9uVHRsIHtcbiAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25UdGwodHRsU2Vjb25kcywgdHJ1ZSk7XG4gIH1cblxuICAvKiogQ29uc3RydWN0cyBhIENvbGxlY3Rpb25UdGwgd2l0aCB0aGUgc3BlY2lmaWVkIFRUTC5cbiAgICogIFdpbGwgb25seSByZWZyZXNoIGlmIHRoZSBUVEwgaXMgcHJvdmlkZWQuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge251bWJlciB8IG51bGx9IFt0dGxTZWNvbmRzPW51bGxdXG4gICAqIEByZXR1cm5zIHtDb2xsZWN0aW9uVHRsfVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWZyZXNoVHRsSWZQcm92aWRlZChcbiAgICB0dGxTZWNvbmRzOiBudW1iZXIgfCBudWxsID0gbnVsbFxuICApOiBDb2xsZWN0aW9uVHRsIHtcbiAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25UdGwodHRsU2Vjb25kcywgdHRsU2Vjb25kcyAhPT0gbnVsbCk7XG4gIH1cblxuICAvKiogQ29waWVzIHRoZSBDb2xsZWN0aW9uVHRsLCBidXQgaXQgd2lsbCByZWZyZXNoIHRoZSBUVEwgd2hlblxuICAgKiAgdGhlIGNvbGxlY3Rpb24gaXMgbW9kaWZpZWQuXG4gICAqIEByZXR1cm5zIHtDb2xsZWN0aW9uVHRsfVxuICAgKi9cbiAgcHVibGljIHdpdGhSZWZyZXNoVHRsT25VcGRhdGVzKCk6IENvbGxlY3Rpb25UdGwge1xuICAgIHJldHVybiBuZXcgQ29sbGVjdGlvblR0bCh0aGlzLl90dGxTZWNvbmRzLCB0cnVlKTtcbiAgfVxuXG4gIC8qKiBDb3BpZXMgdGhlIENvbGxlY3Rpb25UVEwsIGJ1dCB0aGUgVFRMIHdpbGwgbm90IGJlIHJlZnJlc2hlZFxuICAgKiAgd2hlbiB0aGUgY29sbGVjdGlvbiBpcyBtb2RpZmllZC4gVXNlIHRoaXMgaWYgeW91IHdhbnQgdG8gZW5zdXJlXG4gICAqICB0aGF0IHlvdXIgY29sbGVjdGlvbiBleHBpcmVzIGF0IHRoZSBvcmlnaW5hbGx5IHNwZWNpZmllZCB0aW1lLCBldmVuXG4gICAqICBpZiB5b3UgbWFrZSBtb2RpZmljYXRpb25zIHRvIHRoZSB2YWx1ZSBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICogQHJldHVybnMge0NvbGxlY3Rpb25UdGx9XG4gICAqL1xuICBwdWJsaWMgd2l0aE5vUmVmcmVzaFR0bE9uVXBkYXRlcygpOiBDb2xsZWN0aW9uVHRsIHtcbiAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25UdGwodGhpcy5fdHRsU2Vjb25kcywgZmFsc2UpO1xuICB9XG5cbiAgLyoqIEEgc3RyaW5nIHJlcHJlc2VuYXRpb24gb2YgdGhlIENvbGxlY3Rpb25UdGwgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cbiAgICogQHJldHVybiB7Q29sbGVjdGlvblR0bH1cbiAgICovXG4gIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiBgdHRsOiAke3RoaXMuX3R0bFNlY29uZHMgfHwgJ251bGwnfSwgcmVmcmVzaFR0bDogJHtcbiAgICAgIHRoaXMuX3JlZnJlc2hUdGwgPyAndHJ1ZScgOiAnZmFsc2UnXG4gICAgfWA7XG4gIH1cbn1cbiJdfQ==