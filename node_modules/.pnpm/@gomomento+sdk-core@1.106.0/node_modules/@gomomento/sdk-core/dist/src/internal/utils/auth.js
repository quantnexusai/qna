"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InternalSuperUserPermissions = exports.decodeAuthToken = exports.populateAllEndpointsFromBaseEndpoint = void 0;
const errors_1 = require("../../errors");
const jwt_decode_1 = require("jwt-decode");
const validators_1 = require("./validators");
const string_1 = require("./string");
const permission_scope_1 = require("../../auth/tokens/permission-scope");
function decodeAuthTokenClaims(authToken) {
    return (0, jwt_decode_1.default)(authToken);
}
function populateAllEndpointsFromBaseEndpoint(endpointOverride) {
    let prefix = '';
    if (endpointOverride.endpointPrefix) {
        prefix = `${endpointOverride.endpointPrefix}.`;
    }
    return {
        controlEndpoint: {
            endpoint: `${prefix}control.${endpointOverride.baseEndpoint}`,
            secureConnection: endpointOverride.secureConnection,
        },
        cacheEndpoint: {
            endpoint: `${prefix}cache.${endpointOverride.baseEndpoint}`,
            secureConnection: endpointOverride.secureConnection,
        },
        tokenEndpoint: {
            endpoint: `${prefix}token.${endpointOverride.baseEndpoint}`,
            secureConnection: endpointOverride.secureConnection,
        },
        storageEndpoint: {
            endpoint: `${prefix}storage.${endpointOverride.baseEndpoint}`,
            secureConnection: endpointOverride.secureConnection,
        },
    };
}
exports.populateAllEndpointsFromBaseEndpoint = populateAllEndpointsFromBaseEndpoint;
/**
 * @param {string} token
 * @returns TokenAndEndpoints
 */
const decodeAuthToken = (token) => {
    if (!token) {
        throw new errors_1.InvalidArgumentError('malformed auth token');
    }
    try {
        // v1 api tokens don't have an endpoint as part of their claims. Instead, when the SDK returns tokens, we
        // give it to them as a base64 encoded string of '{ "api_key": "<the key>", "endpoint": "prod.momentohq.com" }'.
        // Since in the near future, most customers are going to be using these newer tokens, we are first checking to see if
        // they are base64 encoded, which will tell us that they are our v1 api tokens. If its not, we will fall back to decoding
        // it as one of our legacy jwts.
        if ((0, validators_1.isBase64)(token)) {
            const base64DecodedToken = JSON.parse((0, string_1.decodeFromBase64)(token));
            if (!base64DecodedToken.endpoint || !base64DecodedToken.api_key) {
                throw new errors_1.InvalidArgumentError('failed to parse token');
            }
            const endpoints = populateAllEndpointsFromBaseEndpoint({
                baseEndpoint: base64DecodedToken.endpoint,
            });
            return {
                controlEndpoint: endpoints.controlEndpoint.endpoint,
                cacheEndpoint: endpoints.cacheEndpoint.endpoint,
                tokenEndpoint: endpoints.tokenEndpoint.endpoint,
                storageEndpoint: endpoints.storageEndpoint.endpoint,
                authToken: base64DecodedToken.api_key,
            };
        }
        else {
            // This decode function uses generics to advertise that we will usually expect to find the LegacyClaims.  However,
            // if the token is a valid JWT but not actually one of our legacy tokens, the endpoint claims will be undefined,
            // which is why the return type for this function specifies that the controlEndpoint/cacheEndpoint may be undefined.
            const decodedLegacyToken = decodeAuthTokenClaims(token);
            return {
                controlEndpoint: decodedLegacyToken.cp,
                cacheEndpoint: decodedLegacyToken.c,
                tokenEndpoint: decodedLegacyToken.c,
                storageEndpoint: decodedLegacyToken.c,
                authToken: token,
            };
        }
    }
    catch (e) {
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        throw new errors_1.InvalidArgumentError(`failed to parse token: ${e}`);
    }
};
exports.decodeAuthToken = decodeAuthToken;
class InternalSuperUserPermissions extends permission_scope_1.PredefinedScope {
}
exports.InternalSuperUserPermissions = InternalSuperUserPermissions;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9pbnRlcm5hbC91dGlscy9hdXRoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHlDQUFrRDtBQUNsRCwyQ0FBbUM7QUFDbkMsNkNBQXNDO0FBQ3RDLHFDQUEwQztBQUMxQyx5RUFBbUU7QUFtQm5FLFNBQVMscUJBQXFCLENBQUksU0FBaUI7SUFDakQsT0FBTyxJQUFBLG9CQUFTLEVBQUksU0FBUyxDQUFDLENBQUM7QUFDakMsQ0FBQztBQXdCRCxTQUFnQixvQ0FBb0MsQ0FDbEQsZ0JBQXNDO0lBRXRDLElBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQztJQUNoQixJQUFJLGdCQUFnQixDQUFDLGNBQWMsRUFBRTtRQUNuQyxNQUFNLEdBQUcsR0FBRyxnQkFBZ0IsQ0FBQyxjQUFjLEdBQUcsQ0FBQztLQUNoRDtJQUNELE9BQU87UUFDTCxlQUFlLEVBQUU7WUFDZixRQUFRLEVBQUUsR0FBRyxNQUFNLFdBQVcsZ0JBQWdCLENBQUMsWUFBWSxFQUFFO1lBQzdELGdCQUFnQixFQUFFLGdCQUFnQixDQUFDLGdCQUFnQjtTQUNwRDtRQUNELGFBQWEsRUFBRTtZQUNiLFFBQVEsRUFBRSxHQUFHLE1BQU0sU0FBUyxnQkFBZ0IsQ0FBQyxZQUFZLEVBQUU7WUFDM0QsZ0JBQWdCLEVBQUUsZ0JBQWdCLENBQUMsZ0JBQWdCO1NBQ3BEO1FBQ0QsYUFBYSxFQUFFO1lBQ2IsUUFBUSxFQUFFLEdBQUcsTUFBTSxTQUFTLGdCQUFnQixDQUFDLFlBQVksRUFBRTtZQUMzRCxnQkFBZ0IsRUFBRSxnQkFBZ0IsQ0FBQyxnQkFBZ0I7U0FDcEQ7UUFDRCxlQUFlLEVBQUU7WUFDZixRQUFRLEVBQUUsR0FBRyxNQUFNLFdBQVcsZ0JBQWdCLENBQUMsWUFBWSxFQUFFO1lBQzdELGdCQUFnQixFQUFFLGdCQUFnQixDQUFDLGdCQUFnQjtTQUNwRDtLQUNGLENBQUM7QUFDSixDQUFDO0FBekJELG9GQXlCQztBQUVEOzs7R0FHRztBQUNJLE1BQU0sZUFBZSxHQUFHLENBQUMsS0FBYyxFQUFxQixFQUFFO0lBQ25FLElBQUksQ0FBQyxLQUFLLEVBQUU7UUFDVixNQUFNLElBQUksNkJBQW9CLENBQUMsc0JBQXNCLENBQUMsQ0FBQztLQUN4RDtJQUVELElBQUk7UUFDRix5R0FBeUc7UUFDekcsZ0hBQWdIO1FBQ2hILHFIQUFxSDtRQUNySCx5SEFBeUg7UUFDekgsZ0NBQWdDO1FBQ2hDLElBQUksSUFBQSxxQkFBUSxFQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ25CLE1BQU0sa0JBQWtCLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FDbkMsSUFBQSx5QkFBZ0IsRUFBQyxLQUFLLENBQUMsQ0FDQSxDQUFDO1lBQzFCLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLEVBQUU7Z0JBQy9ELE1BQU0sSUFBSSw2QkFBb0IsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO2FBQ3pEO1lBQ0QsTUFBTSxTQUFTLEdBQUcsb0NBQW9DLENBQUM7Z0JBQ3JELFlBQVksRUFBRSxrQkFBa0IsQ0FBQyxRQUFRO2FBQzFDLENBQUMsQ0FBQztZQUNILE9BQU87Z0JBQ0wsZUFBZSxFQUFFLFNBQVMsQ0FBQyxlQUFlLENBQUMsUUFBUTtnQkFDbkQsYUFBYSxFQUFFLFNBQVMsQ0FBQyxhQUFhLENBQUMsUUFBUTtnQkFDL0MsYUFBYSxFQUFFLFNBQVMsQ0FBQyxhQUFhLENBQUMsUUFBUTtnQkFDL0MsZUFBZSxFQUFFLFNBQVMsQ0FBQyxlQUFlLENBQUMsUUFBUTtnQkFDbkQsU0FBUyxFQUFFLGtCQUFrQixDQUFDLE9BQU87YUFDdEMsQ0FBQztTQUNIO2FBQU07WUFDTCxrSEFBa0g7WUFDbEgsZ0hBQWdIO1lBQ2hILG9IQUFvSDtZQUNwSCxNQUFNLGtCQUFrQixHQUFHLHFCQUFxQixDQUFlLEtBQUssQ0FBQyxDQUFDO1lBQ3RFLE9BQU87Z0JBQ0wsZUFBZSxFQUFFLGtCQUFrQixDQUFDLEVBQUU7Z0JBQ3RDLGFBQWEsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO2dCQUNuQyxhQUFhLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztnQkFDbkMsZUFBZSxFQUFFLGtCQUFrQixDQUFDLENBQUM7Z0JBQ3JDLFNBQVMsRUFBRSxLQUFLO2FBQ2pCLENBQUM7U0FDSDtLQUNGO0lBQUMsT0FBTyxDQUFDLEVBQUU7UUFDViw0RUFBNEU7UUFDNUUsTUFBTSxJQUFJLDZCQUFvQixDQUFDLDBCQUEwQixDQUFDLEVBQUUsQ0FBQyxDQUFDO0tBQy9EO0FBQ0gsQ0FBQyxDQUFDO0FBN0NXLFFBQUEsZUFBZSxtQkE2QzFCO0FBRUYsTUFBYSw0QkFBNkIsU0FBUSxrQ0FBZTtDQUFHO0FBQXBFLG9FQUFvRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7SW52YWxpZEFyZ3VtZW50RXJyb3J9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5pbXBvcnQgand0RGVjb2RlIGZyb20gJ2p3dC1kZWNvZGUnO1xuaW1wb3J0IHtpc0Jhc2U2NH0gZnJvbSAnLi92YWxpZGF0b3JzJztcbmltcG9ydCB7ZGVjb2RlRnJvbUJhc2U2NH0gZnJvbSAnLi9zdHJpbmcnO1xuaW1wb3J0IHtQcmVkZWZpbmVkU2NvcGV9IGZyb20gJy4uLy4uL2F1dGgvdG9rZW5zL3Blcm1pc3Npb24tc2NvcGUnO1xuaW1wb3J0IHtCYXNlRW5kcG9pbnRPdmVycmlkZX0gZnJvbSAnLi4vLi4vYXV0aCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGVnYWN5Q2xhaW1zIHtcbiAgLyoqXG4gICAqIGNvbnRyb2wgcGxhbmUgZW5kcG9pbnRcbiAgICovXG4gIGNwOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBjYWNoZSBlbmRwb2ludFxuICAgKi9cbiAgYzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhc2U2NERlY29kZWRWMVRva2VuIHtcbiAgYXBpX2tleTogc3RyaW5nO1xuICBlbmRwb2ludDogc3RyaW5nO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVBdXRoVG9rZW5DbGFpbXM8VD4oYXV0aFRva2VuOiBzdHJpbmcpOiBUIHtcbiAgcmV0dXJuIGp3dERlY29kZTxUPihhdXRoVG9rZW4pO1xufVxuXG5pbnRlcmZhY2UgVG9rZW5BbmRFbmRwb2ludHMge1xuICAvLyBJZiB3ZSBkZWNvZGUgYSBKV1QgdGhhdCBkb2Vzbid0IGFjdHVhbGx5IGhhdmUgdGhlIGNvbnRyb2xFbmRwb2ludC9jYWNoZUVuZHBvaW50IGNsYWltcywgdGhlbiB0aGV5IHdpbGwgY29tZSBiYWNrXG4gIC8vIGFzIHVuZGVmaW5lZDsgdGh1cyB3ZSBuZWVkIHRoZSB0eXBlcyBoZXJlIHRvIGJlIGBzdHJpbmcgfCB1bmRlZmluZWRgLlxuICBjb250cm9sRW5kcG9pbnQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgY2FjaGVFbmRwb2ludDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICB0b2tlbkVuZHBvaW50OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIHN0b3JhZ2VFbmRwb2ludDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBhdXRoVG9rZW46IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFbmRwb2ludCB7XG4gIGVuZHBvaW50OiBzdHJpbmc7XG4gIHNlY3VyZUNvbm5lY3Rpb24/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFsbEVuZHBvaW50cyB7XG4gIGNvbnRyb2xFbmRwb2ludDogRW5kcG9pbnQ7XG4gIGNhY2hlRW5kcG9pbnQ6IEVuZHBvaW50O1xuICB0b2tlbkVuZHBvaW50OiBFbmRwb2ludDtcbiAgc3RvcmFnZUVuZHBvaW50OiBFbmRwb2ludDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvcHVsYXRlQWxsRW5kcG9pbnRzRnJvbUJhc2VFbmRwb2ludChcbiAgZW5kcG9pbnRPdmVycmlkZTogQmFzZUVuZHBvaW50T3ZlcnJpZGVcbik6IEFsbEVuZHBvaW50cyB7XG4gIGxldCBwcmVmaXggPSAnJztcbiAgaWYgKGVuZHBvaW50T3ZlcnJpZGUuZW5kcG9pbnRQcmVmaXgpIHtcbiAgICBwcmVmaXggPSBgJHtlbmRwb2ludE92ZXJyaWRlLmVuZHBvaW50UHJlZml4fS5gO1xuICB9XG4gIHJldHVybiB7XG4gICAgY29udHJvbEVuZHBvaW50OiB7XG4gICAgICBlbmRwb2ludDogYCR7cHJlZml4fWNvbnRyb2wuJHtlbmRwb2ludE92ZXJyaWRlLmJhc2VFbmRwb2ludH1gLFxuICAgICAgc2VjdXJlQ29ubmVjdGlvbjogZW5kcG9pbnRPdmVycmlkZS5zZWN1cmVDb25uZWN0aW9uLFxuICAgIH0sXG4gICAgY2FjaGVFbmRwb2ludDoge1xuICAgICAgZW5kcG9pbnQ6IGAke3ByZWZpeH1jYWNoZS4ke2VuZHBvaW50T3ZlcnJpZGUuYmFzZUVuZHBvaW50fWAsXG4gICAgICBzZWN1cmVDb25uZWN0aW9uOiBlbmRwb2ludE92ZXJyaWRlLnNlY3VyZUNvbm5lY3Rpb24sXG4gICAgfSxcbiAgICB0b2tlbkVuZHBvaW50OiB7XG4gICAgICBlbmRwb2ludDogYCR7cHJlZml4fXRva2VuLiR7ZW5kcG9pbnRPdmVycmlkZS5iYXNlRW5kcG9pbnR9YCxcbiAgICAgIHNlY3VyZUNvbm5lY3Rpb246IGVuZHBvaW50T3ZlcnJpZGUuc2VjdXJlQ29ubmVjdGlvbixcbiAgICB9LFxuICAgIHN0b3JhZ2VFbmRwb2ludDoge1xuICAgICAgZW5kcG9pbnQ6IGAke3ByZWZpeH1zdG9yYWdlLiR7ZW5kcG9pbnRPdmVycmlkZS5iYXNlRW5kcG9pbnR9YCxcbiAgICAgIHNlY3VyZUNvbm5lY3Rpb246IGVuZHBvaW50T3ZlcnJpZGUuc2VjdXJlQ29ubmVjdGlvbixcbiAgICB9LFxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlblxuICogQHJldHVybnMgVG9rZW5BbmRFbmRwb2ludHNcbiAqL1xuZXhwb3J0IGNvbnN0IGRlY29kZUF1dGhUb2tlbiA9ICh0b2tlbj86IHN0cmluZyk6IFRva2VuQW5kRW5kcG9pbnRzID0+IHtcbiAgaWYgKCF0b2tlbikge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignbWFsZm9ybWVkIGF1dGggdG9rZW4nKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gdjEgYXBpIHRva2VucyBkb24ndCBoYXZlIGFuIGVuZHBvaW50IGFzIHBhcnQgb2YgdGhlaXIgY2xhaW1zLiBJbnN0ZWFkLCB3aGVuIHRoZSBTREsgcmV0dXJucyB0b2tlbnMsIHdlXG4gICAgLy8gZ2l2ZSBpdCB0byB0aGVtIGFzIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIG9mICd7IFwiYXBpX2tleVwiOiBcIjx0aGUga2V5PlwiLCBcImVuZHBvaW50XCI6IFwicHJvZC5tb21lbnRvaHEuY29tXCIgfScuXG4gICAgLy8gU2luY2UgaW4gdGhlIG5lYXIgZnV0dXJlLCBtb3N0IGN1c3RvbWVycyBhcmUgZ29pbmcgdG8gYmUgdXNpbmcgdGhlc2UgbmV3ZXIgdG9rZW5zLCB3ZSBhcmUgZmlyc3QgY2hlY2tpbmcgdG8gc2VlIGlmXG4gICAgLy8gdGhleSBhcmUgYmFzZTY0IGVuY29kZWQsIHdoaWNoIHdpbGwgdGVsbCB1cyB0aGF0IHRoZXkgYXJlIG91ciB2MSBhcGkgdG9rZW5zLiBJZiBpdHMgbm90LCB3ZSB3aWxsIGZhbGwgYmFjayB0byBkZWNvZGluZ1xuICAgIC8vIGl0IGFzIG9uZSBvZiBvdXIgbGVnYWN5IGp3dHMuXG4gICAgaWYgKGlzQmFzZTY0KHRva2VuKSkge1xuICAgICAgY29uc3QgYmFzZTY0RGVjb2RlZFRva2VuID0gSlNPTi5wYXJzZShcbiAgICAgICAgZGVjb2RlRnJvbUJhc2U2NCh0b2tlbilcbiAgICAgICkgYXMgQmFzZTY0RGVjb2RlZFYxVG9rZW47XG4gICAgICBpZiAoIWJhc2U2NERlY29kZWRUb2tlbi5lbmRwb2ludCB8fCAhYmFzZTY0RGVjb2RlZFRva2VuLmFwaV9rZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdmYWlsZWQgdG8gcGFyc2UgdG9rZW4nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVuZHBvaW50cyA9IHBvcHVsYXRlQWxsRW5kcG9pbnRzRnJvbUJhc2VFbmRwb2ludCh7XG4gICAgICAgIGJhc2VFbmRwb2ludDogYmFzZTY0RGVjb2RlZFRva2VuLmVuZHBvaW50LFxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250cm9sRW5kcG9pbnQ6IGVuZHBvaW50cy5jb250cm9sRW5kcG9pbnQuZW5kcG9pbnQsXG4gICAgICAgIGNhY2hlRW5kcG9pbnQ6IGVuZHBvaW50cy5jYWNoZUVuZHBvaW50LmVuZHBvaW50LFxuICAgICAgICB0b2tlbkVuZHBvaW50OiBlbmRwb2ludHMudG9rZW5FbmRwb2ludC5lbmRwb2ludCxcbiAgICAgICAgc3RvcmFnZUVuZHBvaW50OiBlbmRwb2ludHMuc3RvcmFnZUVuZHBvaW50LmVuZHBvaW50LFxuICAgICAgICBhdXRoVG9rZW46IGJhc2U2NERlY29kZWRUb2tlbi5hcGlfa2V5LFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBkZWNvZGUgZnVuY3Rpb24gdXNlcyBnZW5lcmljcyB0byBhZHZlcnRpc2UgdGhhdCB3ZSB3aWxsIHVzdWFsbHkgZXhwZWN0IHRvIGZpbmQgdGhlIExlZ2FjeUNsYWltcy4gIEhvd2V2ZXIsXG4gICAgICAvLyBpZiB0aGUgdG9rZW4gaXMgYSB2YWxpZCBKV1QgYnV0IG5vdCBhY3R1YWxseSBvbmUgb2Ygb3VyIGxlZ2FjeSB0b2tlbnMsIHRoZSBlbmRwb2ludCBjbGFpbXMgd2lsbCBiZSB1bmRlZmluZWQsXG4gICAgICAvLyB3aGljaCBpcyB3aHkgdGhlIHJldHVybiB0eXBlIGZvciB0aGlzIGZ1bmN0aW9uIHNwZWNpZmllcyB0aGF0IHRoZSBjb250cm9sRW5kcG9pbnQvY2FjaGVFbmRwb2ludCBtYXkgYmUgdW5kZWZpbmVkLlxuICAgICAgY29uc3QgZGVjb2RlZExlZ2FjeVRva2VuID0gZGVjb2RlQXV0aFRva2VuQ2xhaW1zPExlZ2FjeUNsYWltcz4odG9rZW4pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udHJvbEVuZHBvaW50OiBkZWNvZGVkTGVnYWN5VG9rZW4uY3AsXG4gICAgICAgIGNhY2hlRW5kcG9pbnQ6IGRlY29kZWRMZWdhY3lUb2tlbi5jLFxuICAgICAgICB0b2tlbkVuZHBvaW50OiBkZWNvZGVkTGVnYWN5VG9rZW4uYyxcbiAgICAgICAgc3RvcmFnZUVuZHBvaW50OiBkZWNvZGVkTGVnYWN5VG9rZW4uYyxcbiAgICAgICAgYXV0aFRva2VuOiB0b2tlbixcbiAgICAgIH07XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9uc1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgZmFpbGVkIHRvIHBhcnNlIHRva2VuOiAke2V9YCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjbGFzcyBJbnRlcm5hbFN1cGVyVXNlclBlcm1pc3Npb25zIGV4dGVuZHMgUHJlZGVmaW5lZFNjb3BlIHt9XG4iXX0=