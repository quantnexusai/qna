"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Error = exports.Miss = exports.Hit = void 0;
const response_base_1 = require("./response-base");
const enums_1 = require("./enums");
const TEXT_DECODER = new TextDecoder();
/**
 * Indicates that the requested data was successfully retrieved from the cache.  Provides
 * `value*` accessors to retrieve the data in the appropriate format.
 */
class Hit extends response_base_1.ResponseBase {
    constructor(items) {
        super();
        this._displayListSizeLimit = 5;
        this.type = enums_1.CacheDictionaryFetchResponse.Hit;
        this.items = items;
    }
    /**
     * Returns the data as a Map whose keys and values are utf-8 strings, decoded from the underlying byte arrays.
     * This is a convenience alias for {valueMapStringString}.
     * @returns {Map<string, string>}
     */
    valueMap() {
        return this.valueMapStringString();
    }
    /**
     * Returns the data as a Map whose keys and values are utf-8 strings, decoded from the underlying byte arrays.
     * @returns {Map<string, string>}
     */
    valueMapStringString() {
        return this.items.reduce((acc, item) => {
            acc.set(TEXT_DECODER.decode(item.field), TEXT_DECODER.decode(item.value));
            return acc;
        }, new Map());
    }
    /**
     * Returns the data as a Map whose keys are utf-8 strings, decoded from the underlying byte array, and whose values
     * are byte arrays.
     * @returns {Map<string, Uint8Array>}
     */
    valueMapStringUint8Array() {
        return this.items.reduce((acc, item) => {
            acc.set(TEXT_DECODER.decode(item.field), item.value);
            return acc;
        }, new Map());
    }
    /**
     * Returns the data as a Record whose keys and values are utf-8 strings, decoded from the underlying byte arrays.
     * This can be used in most places where an Object is desired.  This is a convenience alias for
     * {valueRecordStringString}.
     * @returns {Record<string, string>}
     */
    value() {
        return this.valueRecordStringString();
    }
    /**
     * Returns the data as a Record whose keys and values are utf-8 strings, decoded from the underlying byte arrays.
     * This can be used in most places where an Object is desired.  This is a convenience alias for
     * {valueRecordStringString}.
     * @returns {Record<string, string>}
     */
    valueRecord() {
        return this.valueRecordStringString();
    }
    /**
     * Returns the data as a Record whose keys and values are utf-8 strings, decoded from the underlying byte arrays.
     * This can be used in most places where an Object is desired.
     * @returns {Record<string, string>}
     */
    valueRecordStringString() {
        return this.items.reduce((acc, item) => {
            acc[TEXT_DECODER.decode(item.field)] = TEXT_DECODER.decode(item.value);
            return acc;
        }, {});
    }
    /**
     * Returns the data as a Record whose keys are utf-8 strings, decoded from the underlying byte array, and whose
     * values are byte arrays.  This can be used in most places where an Object is desired.
     * @returns {Record<string, Uint8Array>}
     */
    valueRecordStringUint8Array() {
        return this.items.reduce((acc, item) => {
            acc[TEXT_DECODER.decode(item.field)] = item.value;
            return acc;
        }, {});
    }
    truncateValueStrings() {
        const keyValueIterable = this.valueMapStringString().entries();
        const keyValueArray = Array.from(keyValueIterable);
        if (keyValueArray.length <= this._displayListSizeLimit) {
            const pairs = [];
            keyValueArray.forEach(pair => {
                pairs.push(`${pair[0]}: ${pair[1]}`);
            });
            return pairs.join(',');
        }
        else {
            const slicedArray = keyValueArray.slice(0, this._displayListSizeLimit);
            const pairs = [];
            slicedArray.forEach(pair => {
                pairs.push(`${pair[0]}: ${pair[1]}`);
            });
            return pairs.join(',');
        }
    }
    toString() {
        return `${super.toString()}: valueDictionaryStringString: ${this.truncateValueStrings()}`;
    }
}
exports.Hit = Hit;
/**
 * Indicates that the requested data was not available in the cache.
 */
class Miss extends response_base_1.BaseResponseMiss {
    constructor() {
        super(...arguments);
        this.type = enums_1.CacheDictionaryFetchResponse.Miss;
    }
    value() {
        return undefined;
    }
}
exports.Miss = Miss;
/**
 * Indicates that an error occurred during the dictionary fetch request.
 *
 * This response object includes the following fields that you can use to determine
 * how you would like to handle the error:
 *
 * - `errorCode()` - a unique Momento error code indicating the type of error that occurred.
 * - `message()` - a human-readable description of the error
 * - `innerException()` - the original error that caused the failure; can be re-thrown.
 */
class Error extends response_base_1.BaseResponseError {
    constructor(_innerException) {
        super(_innerException);
        this.type = enums_1.CacheDictionaryFetchResponse.Error;
    }
    value() {
        return undefined;
    }
}
exports.Error = Error;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FjaGUtZGljdGlvbmFyeS1mZXRjaC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9tZXNzYWdlcy9yZXNwb25zZXMvY2FjaGUtZGljdGlvbmFyeS1mZXRjaC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxtREFJeUI7QUFHekIsbUNBQXFEO0FBRXJELE1BQU0sWUFBWSxHQUFHLElBQUksV0FBVyxFQUFFLENBQUM7QUFPdkM7OztHQUdHO0FBQ0gsTUFBYSxHQUFJLFNBQVEsNEJBQVk7SUFNbkMsWUFBWSxLQUFrQztRQUM1QyxLQUFLLEVBQUUsQ0FBQztRQUxPLDBCQUFxQixHQUFHLENBQUMsQ0FBQztRQUNsQyxTQUFJLEdBQ1gsb0NBQTRCLENBQUMsR0FBRyxDQUFDO1FBSWpDLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0lBQ3JCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksUUFBUTtRQUNiLE9BQU8sSUFBSSxDQUFDLG9CQUFvQixFQUFFLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7T0FHRztJQUNJLG9CQUFvQjtRQUN6QixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxFQUFFO1lBQ3JDLEdBQUcsQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsWUFBWSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUMxRSxPQUFPLEdBQUcsQ0FBQztRQUNiLENBQUMsRUFBRSxJQUFJLEdBQUcsRUFBa0IsQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksd0JBQXdCO1FBQzdCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLEVBQUU7WUFDckMsR0FBRyxDQUFDLEdBQUcsQ0FB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QUM7Q0FDRjtBQVBELG9CQU9DO0FBRUQ7Ozs7Ozs7OztHQVNHO0FBQ0gsTUFBYSxLQUFNLFNBQVEsaUNBQWlCO0lBRzFDLFlBQVksZUFBeUI7UUFDbkMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBSGhCLFNBQUksR0FDWCxvQ0FBNEIsQ0FBQyxLQUFLLENBQUM7SUFHckMsQ0FBQztJQUVELEtBQUs7UUFDSCxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0NBQ0Y7QUFWRCxzQkFVQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIFJlc3BvbnNlQmFzZSxcbiAgQmFzZVJlc3BvbnNlTWlzcyxcbiAgQmFzZVJlc3BvbnNlRXJyb3IsXG59IGZyb20gJy4vcmVzcG9uc2UtYmFzZSc7XG5pbXBvcnQge1Nka0Vycm9yfSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuaW1wb3J0IHtfRGljdGlvbmFyeUZpZWxkVmFsdWVQYWlyfSBmcm9tICcuL2dycGMtcmVzcG9uc2UtdHlwZXMnO1xuaW1wb3J0IHtDYWNoZURpY3Rpb25hcnlGZXRjaFJlc3BvbnNlfSBmcm9tICcuL2VudW1zJztcblxuY29uc3QgVEVYVF9ERUNPREVSID0gbmV3IFRleHREZWNvZGVyKCk7XG5cbmludGVyZmFjZSBJUmVzcG9uc2Uge1xuICB2YWx1ZSgpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgdW5kZWZpbmVkO1xuICByZWFkb25seSB0eXBlOiBDYWNoZURpY3Rpb25hcnlGZXRjaFJlc3BvbnNlO1xufVxuXG4vKipcbiAqIEluZGljYXRlcyB0aGF0IHRoZSByZXF1ZXN0ZWQgZGF0YSB3YXMgc3VjY2Vzc2Z1bGx5IHJldHJpZXZlZCBmcm9tIHRoZSBjYWNoZS4gIFByb3ZpZGVzXG4gKiBgdmFsdWUqYCBhY2Nlc3NvcnMgdG8gcmV0cmlldmUgdGhlIGRhdGEgaW4gdGhlIGFwcHJvcHJpYXRlIGZvcm1hdC5cbiAqL1xuZXhwb3J0IGNsYXNzIEhpdCBleHRlbmRzIFJlc3BvbnNlQmFzZSBpbXBsZW1lbnRzIElSZXNwb25zZSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgaXRlbXM6IF9EaWN0aW9uYXJ5RmllbGRWYWx1ZVBhaXJbXTtcbiAgcHJpdmF0ZSByZWFkb25seSBfZGlzcGxheUxpc3RTaXplTGltaXQgPSA1O1xuICByZWFkb25seSB0eXBlOiBDYWNoZURpY3Rpb25hcnlGZXRjaFJlc3BvbnNlLkhpdCA9XG4gICAgQ2FjaGVEaWN0aW9uYXJ5RmV0Y2hSZXNwb25zZS5IaXQ7XG5cbiAgY29uc3RydWN0b3IoaXRlbXM6IF9EaWN0aW9uYXJ5RmllbGRWYWx1ZVBhaXJbXSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRhdGEgYXMgYSBNYXAgd2hvc2Uga2V5cyBhbmQgdmFsdWVzIGFyZSB1dGYtOCBzdHJpbmdzLCBkZWNvZGVkIGZyb20gdGhlIHVuZGVybHlpbmcgYnl0ZSBhcnJheXMuXG4gICAqIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBhbGlhcyBmb3Ige3ZhbHVlTWFwU3RyaW5nU3RyaW5nfS5cbiAgICogQHJldHVybnMge01hcDxzdHJpbmcsIHN0cmluZz59XG4gICAqL1xuICBwdWJsaWMgdmFsdWVNYXAoKTogTWFwPHN0cmluZywgc3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVNYXBTdHJpbmdTdHJpbmcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkYXRhIGFzIGEgTWFwIHdob3NlIGtleXMgYW5kIHZhbHVlcyBhcmUgdXRmLTggc3RyaW5ncywgZGVjb2RlZCBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ5dGUgYXJyYXlzLlxuICAgKiBAcmV0dXJucyB7TWFwPHN0cmluZywgc3RyaW5nPn1cbiAgICovXG4gIHB1YmxpYyB2YWx1ZU1hcFN0cmluZ1N0cmluZygpOiBNYXA8c3RyaW5nLCBzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5yZWR1Y2UoKGFjYywgaXRlbSkgPT4ge1xuICAgICAgYWNjLnNldChURVhUX0RFQ09ERVIuZGVjb2RlKGl0ZW0uZmllbGQpLCBURVhUX0RFQ09ERVIuZGVjb2RlKGl0ZW0udmFsdWUpKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGF0YSBhcyBhIE1hcCB3aG9zZSBrZXlzIGFyZSB1dGYtOCBzdHJpbmdzLCBkZWNvZGVkIGZyb20gdGhlIHVuZGVybHlpbmcgYnl0ZSBhcnJheSwgYW5kIHdob3NlIHZhbHVlc1xuICAgKiBhcmUgYnl0ZSBhcnJheXMuXG4gICAqIEByZXR1cm5zIHtNYXA8c3RyaW5nLCBVaW50OEFycmF5Pn1cbiAgICovXG4gIHB1YmxpYyB2YWx1ZU1hcFN0cmluZ1VpbnQ4QXJyYXkoKTogTWFwPHN0cmluZywgVWludDhBcnJheT4ge1xuICAgIHJldHVybiB0aGlzLml0ZW1zLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgICBhY2Muc2V0KFRFWFRfREVDT0RFUi5kZWNvZGUoaXRlbS5maWVsZCksIGl0ZW0udmFsdWUpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBuZXcgTWFwPHN0cmluZywgVWludDhBcnJheT4oKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGF0YSBhcyBhIFJlY29yZCB3aG9zZSBrZXlzIGFuZCB2YWx1ZXMgYXJlIHV0Zi04IHN0cmluZ3MsIGRlY29kZWQgZnJvbSB0aGUgdW5kZXJseWluZyBieXRlIGFycmF5cy5cbiAgICogVGhpcyBjYW4gYmUgdXNlZCBpbiBtb3N0IHBsYWNlcyB3aGVyZSBhbiBPYmplY3QgaXMgZGVzaXJlZC4gIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBhbGlhcyBmb3JcbiAgICoge3ZhbHVlUmVjb3JkU3RyaW5nU3RyaW5nfS5cbiAgICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZz59XG4gICAqL1xuICBwdWJsaWMgdmFsdWUoKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVSZWNvcmRTdHJpbmdTdHJpbmcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkYXRhIGFzIGEgUmVjb3JkIHdob3NlIGtleXMgYW5kIHZhbHVlcyBhcmUgdXRmLTggc3RyaW5ncywgZGVjb2RlZCBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ5dGUgYXJyYXlzLlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIGluIG1vc3QgcGxhY2VzIHdoZXJlIGFuIE9iamVjdCBpcyBkZXNpcmVkLiAgVGhpcyBpcyBhIGNvbnZlbmllbmNlIGFsaWFzIGZvclxuICAgKiB7dmFsdWVSZWNvcmRTdHJpbmdTdHJpbmd9LlxuICAgKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn1cbiAgICovXG4gIHB1YmxpYyB2YWx1ZVJlY29yZCgpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVJlY29yZFN0cmluZ1N0cmluZygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRhdGEgYXMgYSBSZWNvcmQgd2hvc2Uga2V5cyBhbmQgdmFsdWVzIGFyZSB1dGYtOCBzdHJpbmdzLCBkZWNvZGVkIGZyb20gdGhlIHVuZGVybHlpbmcgYnl0ZSBhcnJheXMuXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgaW4gbW9zdCBwbGFjZXMgd2hlcmUgYW4gT2JqZWN0IGlzIGRlc2lyZWQuXG4gICAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fVxuICAgKi9cbiAgcHVibGljIHZhbHVlUmVjb3JkU3RyaW5nU3RyaW5nKCk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLml0ZW1zLnJlZHVjZTxSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+PigoYWNjLCBpdGVtKSA9PiB7XG4gICAgICBhY2NbVEVYVF9ERUNPREVSLmRlY29kZShpdGVtLmZpZWxkKV0gPSBURVhUX0RFQ09ERVIuZGVjb2RlKGl0ZW0udmFsdWUpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGF0YSBhcyBhIFJlY29yZCB3aG9zZSBrZXlzIGFyZSB1dGYtOCBzdHJpbmdzLCBkZWNvZGVkIGZyb20gdGhlIHVuZGVybHlpbmcgYnl0ZSBhcnJheSwgYW5kIHdob3NlXG4gICAqIHZhbHVlcyBhcmUgYnl0ZSBhcnJheXMuICBUaGlzIGNhbiBiZSB1c2VkIGluIG1vc3QgcGxhY2VzIHdoZXJlIGFuIE9iamVjdCBpcyBkZXNpcmVkLlxuICAgKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgVWludDhBcnJheT59XG4gICAqL1xuICBwdWJsaWMgdmFsdWVSZWNvcmRTdHJpbmdVaW50OEFycmF5KCk6IFJlY29yZDxzdHJpbmcsIFVpbnQ4QXJyYXk+IHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5yZWR1Y2U8UmVjb3JkPHN0cmluZywgVWludDhBcnJheT4+KChhY2MsIGl0ZW0pID0+IHtcbiAgICAgIGFjY1tURVhUX0RFQ09ERVIuZGVjb2RlKGl0ZW0uZmllbGQpXSA9IGl0ZW0udmFsdWU7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgfVxuXG4gIHByaXZhdGUgdHJ1bmNhdGVWYWx1ZVN0cmluZ3MoKTogc3RyaW5nIHtcbiAgICBjb25zdCBrZXlWYWx1ZUl0ZXJhYmxlID0gdGhpcy52YWx1ZU1hcFN0cmluZ1N0cmluZygpLmVudHJpZXMoKTtcbiAgICBjb25zdCBrZXlWYWx1ZUFycmF5ID0gQXJyYXkuZnJvbShrZXlWYWx1ZUl0ZXJhYmxlKTtcbiAgICBpZiAoa2V5VmFsdWVBcnJheS5sZW5ndGggPD0gdGhpcy5fZGlzcGxheUxpc3RTaXplTGltaXQpIHtcbiAgICAgIGNvbnN0IHBhaXJzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAga2V5VmFsdWVBcnJheS5mb3JFYWNoKHBhaXIgPT4ge1xuICAgICAgICBwYWlycy5wdXNoKGAke3BhaXJbMF19OiAke3BhaXJbMV19YCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYWlycy5qb2luKCcsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNsaWNlZEFycmF5ID0ga2V5VmFsdWVBcnJheS5zbGljZSgwLCB0aGlzLl9kaXNwbGF5TGlzdFNpemVMaW1pdCk7XG4gICAgICBjb25zdCBwYWlyczogc3RyaW5nW10gPSBbXTtcbiAgICAgIHNsaWNlZEFycmF5LmZvckVhY2gocGFpciA9PiB7XG4gICAgICAgIHBhaXJzLnB1c2goYCR7cGFpclswXX06ICR7cGFpclsxXX1gKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBhaXJzLmpvaW4oJywnKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgb3ZlcnJpZGUgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7c3VwZXIudG9TdHJpbmcoKX06IHZhbHVlRGljdGlvbmFyeVN0cmluZ1N0cmluZzogJHt0aGlzLnRydW5jYXRlVmFsdWVTdHJpbmdzKCl9YDtcbiAgfVxufVxuXG4vKipcbiAqIEluZGljYXRlcyB0aGF0IHRoZSByZXF1ZXN0ZWQgZGF0YSB3YXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgY2FjaGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBNaXNzIGV4dGVuZHMgQmFzZVJlc3BvbnNlTWlzcyBpbXBsZW1lbnRzIElSZXNwb25zZSB7XG4gIHJlYWRvbmx5IHR5cGU6IENhY2hlRGljdGlvbmFyeUZldGNoUmVzcG9uc2UuTWlzcyA9XG4gICAgQ2FjaGVEaWN0aW9uYXJ5RmV0Y2hSZXNwb25zZS5NaXNzO1xuXG4gIHZhbHVlKCk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCBhbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdGhlIGRpY3Rpb25hcnkgZmV0Y2ggcmVxdWVzdC5cbiAqXG4gKiBUaGlzIHJlc3BvbnNlIG9iamVjdCBpbmNsdWRlcyB0aGUgZm9sbG93aW5nIGZpZWxkcyB0aGF0IHlvdSBjYW4gdXNlIHRvIGRldGVybWluZVxuICogaG93IHlvdSB3b3VsZCBsaWtlIHRvIGhhbmRsZSB0aGUgZXJyb3I6XG4gKlxuICogLSBgZXJyb3JDb2RlKClgIC0gYSB1bmlxdWUgTW9tZW50byBlcnJvciBjb2RlIGluZGljYXRpbmcgdGhlIHR5cGUgb2YgZXJyb3IgdGhhdCBvY2N1cnJlZC5cbiAqIC0gYG1lc3NhZ2UoKWAgLSBhIGh1bWFuLXJlYWRhYmxlIGRlc2NyaXB0aW9uIG9mIHRoZSBlcnJvclxuICogLSBgaW5uZXJFeGNlcHRpb24oKWAgLSB0aGUgb3JpZ2luYWwgZXJyb3IgdGhhdCBjYXVzZWQgdGhlIGZhaWx1cmU7IGNhbiBiZSByZS10aHJvd24uXG4gKi9cbmV4cG9ydCBjbGFzcyBFcnJvciBleHRlbmRzIEJhc2VSZXNwb25zZUVycm9yIGltcGxlbWVudHMgSVJlc3BvbnNlIHtcbiAgcmVhZG9ubHkgdHlwZTogQ2FjaGVEaWN0aW9uYXJ5RmV0Y2hSZXNwb25zZS5FcnJvciA9XG4gICAgQ2FjaGVEaWN0aW9uYXJ5RmV0Y2hSZXNwb25zZS5FcnJvcjtcbiAgY29uc3RydWN0b3IoX2lubmVyRXhjZXB0aW9uOiBTZGtFcnJvcikge1xuICAgIHN1cGVyKF9pbm5lckV4Y2VwdGlvbik7XG4gIH1cblxuICB2YWx1ZSgpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIFJlc3BvbnNlID0gSGl0IHwgTWlzcyB8IEVycm9yO1xuIl19