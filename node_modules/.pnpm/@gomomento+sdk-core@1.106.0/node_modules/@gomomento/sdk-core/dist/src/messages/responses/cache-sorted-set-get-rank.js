"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Error = exports.Miss = exports.Hit = void 0;
const response_base_1 = require("./response-base");
const enums_1 = require("./enums");
/**
 * Indicates that the requested data was successfully retrieved from the cache.  Provides
 * `rank()` accessor to retrieve rank.
 */
class Hit extends response_base_1.ResponseBase {
    constructor(rank) {
        super();
        this.type = enums_1.CacheSortedSetGetRankResponse.Hit;
        this._rank = rank;
    }
    /**
     * Returns the rank of the element in the sorted set.  Ranks start at 0.
     * @returns {number}
     */
    rank() {
        return this._rank;
    }
    toString() {
        return `${super.toString()}: rank: ${this.rank()}`;
    }
}
exports.Hit = Hit;
/**
 * Indicates that the requested data was not available in the cache.
 */
class Miss extends response_base_1.BaseResponseMiss {
    constructor() {
        super();
        this.type = enums_1.CacheSortedSetGetRankResponse.Miss;
    }
    rank() {
        return undefined;
    }
}
exports.Miss = Miss;
/**
 * Indicates that an error occurred during the sorted set get rank request.
 *
 * This response object includes the following fields that you can use to determine
 * how you would like to handle the error:
 *
 * - `errorCode()` - a unique Momento error code indicating the type of error that occurred.
 * - `message()` - a human-readable description of the error
 * - `innerException()` - the original error that caused the failure; can be re-thrown.
 */
class Error extends response_base_1.BaseResponseError {
    constructor(error) {
        super(error);
        this.type = enums_1.CacheSortedSetGetRankResponse.Error;
    }
    rank() {
        return undefined;
    }
}
exports.Error = Error;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FjaGUtc29ydGVkLXNldC1nZXQtcmFuay5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9tZXNzYWdlcy9yZXNwb25zZXMvY2FjaGUtc29ydGVkLXNldC1nZXQtcmFuay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxtREFJeUI7QUFDekIsbUNBQXNEO0FBUXREOzs7R0FHRztBQUNILE1BQWEsR0FBSSxTQUFRLDRCQUFZO0lBS25DLFlBQVksSUFBWTtRQUN0QixLQUFLLEVBQUUsQ0FBQztRQUpELFNBQUksR0FDWCxxQ0FBNkIsQ0FBQyxHQUFHLENBQUM7UUFJbEMsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7SUFDcEIsQ0FBQztJQUVEOzs7T0FHRztJQUNJLElBQUk7UUFDVCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7SUFDcEIsQ0FBQztJQUVlLFFBQVE7UUFDdEIsT0FBTyxHQUFHLEtBQUssQ0FBQyxRQUFRLEVBQUUsV0FBVyxJQUFJLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQztJQUNyRCxDQUFDO0NBQ0Y7QUFyQkQsa0JBcUJDO0FBRUQ7O0dBRUc7QUFDSCxNQUFhLElBQUssU0FBUSxnQ0FBZ0I7SUFJeEM7UUFDRSxLQUFLLEVBQUUsQ0FBQztRQUpELFNBQUksR0FDWCxxQ0FBNkIsQ0FBQyxJQUFJLENBQUM7SUFJckMsQ0FBQztJQUVNLElBQUk7UUFDVCxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0NBQ0Y7QUFYRCxvQkFXQztBQUVEOzs7Ozs7Ozs7R0FTRztBQUNILE1BQWEsS0FBTSxTQUFRLGlDQUFpQjtJQUkxQyxZQUFZLEtBQWU7UUFDekIsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBSk4sU0FBSSxHQUNYLHFDQUE2QixDQUFDLEtBQUssQ0FBQztJQUl0QyxDQUFDO0lBRU0sSUFBSTtRQUNULE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7Q0FDRjtBQVhELHNCQVdDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgUmVzcG9uc2VCYXNlLFxuICBCYXNlUmVzcG9uc2VFcnJvcixcbiAgQmFzZVJlc3BvbnNlTWlzcyxcbn0gZnJvbSAnLi9yZXNwb25zZS1iYXNlJztcbmltcG9ydCB7Q2FjaGVTb3J0ZWRTZXRHZXRSYW5rUmVzcG9uc2V9IGZyb20gJy4vZW51bXMnO1xuaW1wb3J0IHtTZGtFcnJvcn0gZnJvbSAnLi4vLi4vZXJyb3JzJztcblxuaW50ZXJmYWNlIElSZXNwb25zZSB7XG4gIHJhbmsoKTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICByZWFkb25seSB0eXBlOiBDYWNoZVNvcnRlZFNldEdldFJhbmtSZXNwb25zZTtcbn1cblxuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCB0aGUgcmVxdWVzdGVkIGRhdGEgd2FzIHN1Y2Nlc3NmdWxseSByZXRyaWV2ZWQgZnJvbSB0aGUgY2FjaGUuICBQcm92aWRlc1xuICogYHJhbmsoKWAgYWNjZXNzb3IgdG8gcmV0cmlldmUgcmFuay5cbiAqL1xuZXhwb3J0IGNsYXNzIEhpdCBleHRlbmRzIFJlc3BvbnNlQmFzZSBpbXBsZW1lbnRzIElSZXNwb25zZSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgX3Jhbms6IG51bWJlcjtcbiAgcmVhZG9ubHkgdHlwZTogQ2FjaGVTb3J0ZWRTZXRHZXRSYW5rUmVzcG9uc2UuSGl0ID1cbiAgICBDYWNoZVNvcnRlZFNldEdldFJhbmtSZXNwb25zZS5IaXQ7XG5cbiAgY29uc3RydWN0b3IocmFuazogbnVtYmVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9yYW5rID0gcmFuaztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByYW5rIG9mIHRoZSBlbGVtZW50IGluIHRoZSBzb3J0ZWQgc2V0LiAgUmFua3Mgc3RhcnQgYXQgMC5cbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIHB1YmxpYyByYW5rKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3Jhbms7XG4gIH1cblxuICBwdWJsaWMgb3ZlcnJpZGUgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7c3VwZXIudG9TdHJpbmcoKX06IHJhbms6ICR7dGhpcy5yYW5rKCl9YDtcbiAgfVxufVxuXG4vKipcbiAqIEluZGljYXRlcyB0aGF0IHRoZSByZXF1ZXN0ZWQgZGF0YSB3YXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgY2FjaGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBNaXNzIGV4dGVuZHMgQmFzZVJlc3BvbnNlTWlzcyBpbXBsZW1lbnRzIElSZXNwb25zZSB7XG4gIHJlYWRvbmx5IHR5cGU6IENhY2hlU29ydGVkU2V0R2V0UmFua1Jlc3BvbnNlLk1pc3MgPVxuICAgIENhY2hlU29ydGVkU2V0R2V0UmFua1Jlc3BvbnNlLk1pc3M7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIHB1YmxpYyByYW5rKCk6IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIEluZGljYXRlcyB0aGF0IGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyB0aGUgc29ydGVkIHNldCBnZXQgcmFuayByZXF1ZXN0LlxuICpcbiAqIFRoaXMgcmVzcG9uc2Ugb2JqZWN0IGluY2x1ZGVzIHRoZSBmb2xsb3dpbmcgZmllbGRzIHRoYXQgeW91IGNhbiB1c2UgdG8gZGV0ZXJtaW5lXG4gKiBob3cgeW91IHdvdWxkIGxpa2UgdG8gaGFuZGxlIHRoZSBlcnJvcjpcbiAqXG4gKiAtIGBlcnJvckNvZGUoKWAgLSBhIHVuaXF1ZSBNb21lbnRvIGVycm9yIGNvZGUgaW5kaWNhdGluZyB0aGUgdHlwZSBvZiBlcnJvciB0aGF0IG9jY3VycmVkLlxuICogLSBgbWVzc2FnZSgpYCAtIGEgaHVtYW4tcmVhZGFibGUgZGVzY3JpcHRpb24gb2YgdGhlIGVycm9yXG4gKiAtIGBpbm5lckV4Y2VwdGlvbigpYCAtIHRoZSBvcmlnaW5hbCBlcnJvciB0aGF0IGNhdXNlZCB0aGUgZmFpbHVyZTsgY2FuIGJlIHJlLXRocm93bi5cbiAqL1xuZXhwb3J0IGNsYXNzIEVycm9yIGV4dGVuZHMgQmFzZVJlc3BvbnNlRXJyb3IgaW1wbGVtZW50cyBJUmVzcG9uc2Uge1xuICByZWFkb25seSB0eXBlOiBDYWNoZVNvcnRlZFNldEdldFJhbmtSZXNwb25zZS5FcnJvciA9XG4gICAgQ2FjaGVTb3J0ZWRTZXRHZXRSYW5rUmVzcG9uc2UuRXJyb3I7XG5cbiAgY29uc3RydWN0b3IoZXJyb3I6IFNka0Vycm9yKSB7XG4gICAgc3VwZXIoZXJyb3IpO1xuICB9XG5cbiAgcHVibGljIHJhbmsoKTogdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIFJlc3BvbnNlID0gSGl0IHwgTWlzcyB8IEVycm9yO1xuIl19