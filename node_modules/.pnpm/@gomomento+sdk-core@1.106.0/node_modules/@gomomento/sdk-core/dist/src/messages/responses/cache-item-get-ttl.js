"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Error = exports.Miss = exports.Hit = void 0;
const response_base_1 = require("./response-base");
const enums_1 = require("./enums");
/**
 * Indicates a successful item get ttl request.
 */
class Hit extends response_base_1.ResponseBase {
    constructor(itemTTLMillisRemaining) {
        super();
        this.type = enums_1.CacheItemGetTtlResponse.Hit;
        this.ttlMillis = itemTTLMillisRemaining;
    }
    /**
     * Returns the remaining ttl in milliseconds for object stored at passed key.
     * @returns number
     */
    remainingTtlMillis() {
        return this.ttlMillis;
    }
    toString() {
        return `${super.toString()}: remaining ttl: ${this.ttlMillis}`;
    }
}
exports.Hit = Hit;
/**
 * Indicates that the requested item was not available in the cache.
 */
class Miss extends response_base_1.BaseResponseMiss {
    constructor() {
        super();
        this.type = enums_1.CacheItemGetTtlResponse.Miss;
    }
    remainingTtlMillis() {
        return undefined;
    }
}
exports.Miss = Miss;
/**
 * Indicates that an error occurred during the item get ttl request.
 *
 * This response object includes the following fields that you can use to determine
 * how you would like to handle the error:
 *
 * - `errorCode()` - a unique Momento error code indicating the type of error that occurred.
 * - `message()` - a human-readable description of the error
 * - `innerException()` - the original error that caused the failure; can be re-thrown.
 */
class Error extends response_base_1.BaseResponseError {
    constructor(_innerException) {
        super(_innerException);
        this.type = enums_1.CacheItemGetTtlResponse.Error;
    }
    remainingTtlMillis() {
        return undefined;
    }
}
exports.Error = Error;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FjaGUtaXRlbS1nZXQtdHRsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL21lc3NhZ2VzL3Jlc3BvbnNlcy9jYWNoZS1pdGVtLWdldC10dGwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EsbURBSXlCO0FBQ3pCLG1DQUFnRDtBQU9oRDs7R0FFRztBQUNILE1BQWEsR0FBSSxTQUFRLDRCQUFZO0lBSW5DLFlBQVksc0JBQThCO1FBQ3hDLEtBQUssRUFBRSxDQUFDO1FBSkQsU0FBSSxHQUFnQywrQkFBdUIsQ0FBQyxHQUFHLENBQUM7UUFLdkUsSUFBSSxDQUFDLFNBQVMsR0FBRyxzQkFBc0IsQ0FBQztJQUMxQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksa0JBQWtCO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQztJQUN4QixDQUFDO0lBRWUsUUFBUTtRQUN0QixPQUFPLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRSxvQkFBb0IsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO0lBQ2pFLENBQUM7Q0FDRjtBQXBCRCxrQkFvQkM7QUFFRDs7R0FFRztBQUNILE1BQWEsSUFBSyxTQUFRLGdDQUFnQjtJQUd4QztRQUNFLEtBQUssRUFBRSxDQUFDO1FBSEQsU0FBSSxHQUFpQywrQkFBdUIsQ0FBQyxJQUFJLENBQUM7SUFJM0UsQ0FBQztJQUVELGtCQUFrQjtRQUNoQixPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0NBQ0Y7QUFWRCxvQkFVQztBQUVEOzs7Ozs7Ozs7R0FTRztBQUNILE1BQWEsS0FBTSxTQUFRLGlDQUFpQjtJQUcxQyxZQUFZLGVBQXlCO1FBQ25DLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUhoQixTQUFJLEdBQWtDLCtCQUF1QixDQUFDLEtBQUssQ0FBQztJQUk3RSxDQUFDO0lBRUQsa0JBQWtCO1FBQ2hCLE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7Q0FDRjtBQVZELHNCQVVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtTZGtFcnJvcn0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7XG4gIEJhc2VSZXNwb25zZUVycm9yLFxuICBCYXNlUmVzcG9uc2VNaXNzLFxuICBSZXNwb25zZUJhc2UsXG59IGZyb20gJy4vcmVzcG9uc2UtYmFzZSc7XG5pbXBvcnQge0NhY2hlSXRlbUdldFR0bFJlc3BvbnNlfSBmcm9tICcuL2VudW1zJztcblxuaW50ZXJmYWNlIElSZXNwb25zZSB7XG4gIHJlbWFpbmluZ1R0bE1pbGxpcygpOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gIHJlYWRvbmx5IHR5cGU6IENhY2hlSXRlbUdldFR0bFJlc3BvbnNlO1xufVxuXG4vKipcbiAqIEluZGljYXRlcyBhIHN1Y2Nlc3NmdWwgaXRlbSBnZXQgdHRsIHJlcXVlc3QuXG4gKi9cbmV4cG9ydCBjbGFzcyBIaXQgZXh0ZW5kcyBSZXNwb25zZUJhc2UgaW1wbGVtZW50cyBJUmVzcG9uc2Uge1xuICByZWFkb25seSB0eXBlOiBDYWNoZUl0ZW1HZXRUdGxSZXNwb25zZS5IaXQgPSBDYWNoZUl0ZW1HZXRUdGxSZXNwb25zZS5IaXQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgdHRsTWlsbGlzOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoaXRlbVRUTE1pbGxpc1JlbWFpbmluZzogbnVtYmVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnR0bE1pbGxpcyA9IGl0ZW1UVExNaWxsaXNSZW1haW5pbmc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVtYWluaW5nIHR0bCBpbiBtaWxsaXNlY29uZHMgZm9yIG9iamVjdCBzdG9yZWQgYXQgcGFzc2VkIGtleS5cbiAgICogQHJldHVybnMgbnVtYmVyXG4gICAqL1xuICBwdWJsaWMgcmVtYWluaW5nVHRsTWlsbGlzKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMudHRsTWlsbGlzO1xuICB9XG5cbiAgcHVibGljIG92ZXJyaWRlIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke3N1cGVyLnRvU3RyaW5nKCl9OiByZW1haW5pbmcgdHRsOiAke3RoaXMudHRsTWlsbGlzfWA7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCB0aGUgcmVxdWVzdGVkIGl0ZW0gd2FzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGNhY2hlLlxuICovXG5leHBvcnQgY2xhc3MgTWlzcyBleHRlbmRzIEJhc2VSZXNwb25zZU1pc3MgaW1wbGVtZW50cyBJUmVzcG9uc2Uge1xuICByZWFkb25seSB0eXBlOiBDYWNoZUl0ZW1HZXRUdGxSZXNwb25zZS5NaXNzID0gQ2FjaGVJdGVtR2V0VHRsUmVzcG9uc2UuTWlzcztcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgcmVtYWluaW5nVHRsTWlsbGlzKCk6IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIEluZGljYXRlcyB0aGF0IGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyB0aGUgaXRlbSBnZXQgdHRsIHJlcXVlc3QuXG4gKlxuICogVGhpcyByZXNwb25zZSBvYmplY3QgaW5jbHVkZXMgdGhlIGZvbGxvd2luZyBmaWVsZHMgdGhhdCB5b3UgY2FuIHVzZSB0byBkZXRlcm1pbmVcbiAqIGhvdyB5b3Ugd291bGQgbGlrZSB0byBoYW5kbGUgdGhlIGVycm9yOlxuICpcbiAqIC0gYGVycm9yQ29kZSgpYCAtIGEgdW5pcXVlIE1vbWVudG8gZXJyb3IgY29kZSBpbmRpY2F0aW5nIHRoZSB0eXBlIG9mIGVycm9yIHRoYXQgb2NjdXJyZWQuXG4gKiAtIGBtZXNzYWdlKClgIC0gYSBodW1hbi1yZWFkYWJsZSBkZXNjcmlwdGlvbiBvZiB0aGUgZXJyb3JcbiAqIC0gYGlubmVyRXhjZXB0aW9uKClgIC0gdGhlIG9yaWdpbmFsIGVycm9yIHRoYXQgY2F1c2VkIHRoZSBmYWlsdXJlOyBjYW4gYmUgcmUtdGhyb3duLlxuICovXG5leHBvcnQgY2xhc3MgRXJyb3IgZXh0ZW5kcyBCYXNlUmVzcG9uc2VFcnJvciBpbXBsZW1lbnRzIElSZXNwb25zZSB7XG4gIHJlYWRvbmx5IHR5cGU6IENhY2hlSXRlbUdldFR0bFJlc3BvbnNlLkVycm9yID0gQ2FjaGVJdGVtR2V0VHRsUmVzcG9uc2UuRXJyb3I7XG5cbiAgY29uc3RydWN0b3IoX2lubmVyRXhjZXB0aW9uOiBTZGtFcnJvcikge1xuICAgIHN1cGVyKF9pbm5lckV4Y2VwdGlvbik7XG4gIH1cblxuICByZW1haW5pbmdUdGxNaWxsaXMoKTogdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIFJlc3BvbnNlID0gSGl0IHwgTWlzcyB8IEVycm9yO1xuIl19