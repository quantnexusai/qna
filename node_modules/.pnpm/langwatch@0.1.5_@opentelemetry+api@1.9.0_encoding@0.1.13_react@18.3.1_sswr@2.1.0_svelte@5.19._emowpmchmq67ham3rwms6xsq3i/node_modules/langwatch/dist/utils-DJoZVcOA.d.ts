import { CoreMessage } from 'ai';

type ChatRole = "system" | "user" | "assistant" | "function" | "tool" | "unknown";
interface FunctionCall {
    name?: string;
    arguments?: string;
}
interface ToolCall {
    id: string;
    type: string;
    function: FunctionCall;
}
interface ChatMessage$1 {
    role?: ChatRole;
    content?: string | ChatRichContent$1[] | null;
    function_call?: FunctionCall | null;
    tool_calls?: ToolCall[] | null;
    tool_call_id?: string | null;
    name?: string | null;
}
type ChatRichContent$1 = {
    type: "text";
    text?: string;
} | {
    type: "image_url";
    image_url?: {
        url: string;
        detail?: "auto" | "low" | "high";
    };
} | {
    type: "tool_call";
    toolName?: string;
    toolCallId?: string;
    args?: string;
} | {
    type: "tool_result";
    toolName?: string;
    toolCallId?: string;
    result?: any;
};
interface TypedValueChatMessages {
    type: "chat_messages";
    value: ChatMessage$1[];
}
interface TypedValueText {
    type: "text";
    value: string;
}
interface TypedValueRaw {
    type: "raw";
    value: string;
}
type JSONSerializable = string | number | boolean | null | Record<string, any> | any[];
interface TypedValueJson {
    type: "json";
    value: JSONSerializable;
}
type Money = {
    currency: string;
    amount: number;
};
interface EvaluationResult {
    status: "processed" | "skipped" | "error";
    passed?: boolean | null;
    score?: number | null;
    label?: string | null;
    details?: string | null;
    cost?: Money | null;
}
interface TypedValueGuardrailResult {
    type: "guardrail_result";
    value: EvaluationResult;
}
interface TypedValueEvaluationResult {
    type: "evaluation_result";
    value: EvaluationResult;
}
type SpanInputOutput$1 = TypedValueText | TypedValueChatMessages | TypedValueGuardrailResult | TypedValueEvaluationResult | TypedValueJson | TypedValueRaw | {
    type: "list";
    value: SpanInputOutput$1[];
};
interface ErrorCapture {
    has_error: true;
    message: string;
    stacktrace: string[];
}
interface SpanMetrics {
    prompt_tokens?: number | null;
    completion_tokens?: number | null;
    tokens_estimated?: boolean | null;
    cost?: number | null;
}
type ReservedSpanParams = {
    frequency_penalty?: number | null;
    logit_bias?: Record<string, number> | null;
    logprobs?: boolean | null;
    top_logprobs?: number | null;
    max_tokens?: number | null;
    n?: number | null;
    presence_penalty?: number | null;
    seed?: number | null;
    stop?: string | string[] | null;
    stream?: boolean | null;
    temperature?: number | null;
    top_p?: number | null;
    tools?: Record<string, any>[] | null;
    tool_choice?: Record<string, any> | string | null;
    parallel_tool_calls?: boolean | null;
    functions?: Record<string, any>[] | null;
    user?: string | null;
};
type SpanParams = ReservedSpanParams & Record<string, any>;
interface SpanTimestamps {
    started_at: number;
    first_token_at?: number | null;
    finished_at: number;
}
type SpanTypes = "span" | "llm" | "chain" | "tool" | "agent" | "rag" | "guardrail" | "evaluation" | "workflow" | "component" | "module" | "server" | "client" | "producer" | "consumer" | "task" | "unknown";
interface BaseSpan$1 {
    span_id: string;
    parent_id?: string | null;
    trace_id: string;
    type: SpanTypes;
    name?: string | null;
    input?: SpanInputOutput$1 | null;
    output?: SpanInputOutput$1 | null;
    error?: ErrorCapture | null;
    timestamps: SpanTimestamps;
    metrics?: SpanMetrics | null;
    params?: SpanParams | null;
}
interface LLMSpan$1 extends BaseSpan$1 {
    type: "llm";
    vendor?: string | null;
    model?: string | null;
}
interface RAGChunk {
    document_id?: string | null;
    chunk_id?: string | null;
    content: string | Record<string, any> | any[];
}
interface RAGSpan$1 extends BaseSpan$1 {
    type: "rag";
    contexts: RAGChunk[];
}
type Span = LLMSpan$1 | RAGSpan$1 | BaseSpan$1;
type TraceInput = {
    value: string;
    embeddings?: {
        model: string;
        embeddings: number[];
    };
    satisfaction_score?: number;
};
type TraceOutput = {
    value: string;
    embeddings?: {
        model: string;
        embeddings: number[];
    };
};
type PrimitiveType = string | number | boolean | null | undefined;
type ReservedTraceMetadata = {
    thread_id?: string | null;
    user_id?: string | null;
    customer_id?: string | null;
    labels?: string[] | null;
    topic_id?: string | null;
    subtopic_id?: string | null;
    sdk_version?: string | null;
    sdk_language?: string | null;
};
type CustomMetadata = Record<string, PrimitiveType | PrimitiveType[] | Record<string, PrimitiveType> | Record<string, Record<string, PrimitiveType>>>;
type TraceMetadata = ReservedTraceMetadata & CustomMetadata;
type Trace = {
    trace_id: string;
    project_id: string;
    metadata: TraceMetadata;
    timestamps: {
        started_at: number;
        inserted_at: number;
        updated_at: number;
    };
    input?: TraceInput;
    output?: TraceOutput;
    contexts?: RAGChunk[];
    expected_output?: {
        value: string;
    };
    metrics?: {
        first_token_ms?: number | null;
        total_time_ms?: number | null;
        prompt_tokens?: number | null;
        completion_tokens?: number | null;
        total_cost?: number | null;
        tokens_estimated?: boolean | null;
    };
    error?: ErrorCapture | null;
    indexing_md5s?: string[];
    events?: Event[];
    evaluations?: Evaluation[];
};
type EvaluationStatus = "scheduled" | "in_progress" | "error" | "skipped" | "processed";
type Evaluation = {
    evaluation_id: string;
    evaluator_id: string;
    span_id?: string | null;
    name: string;
    type?: string | null;
    is_guardrail?: boolean | null;
    status: EvaluationStatus;
    passed?: boolean | null;
    score?: number | null;
    label?: string | null;
    details?: string | null;
    error?: ErrorCapture | null;
    retries?: number | null;
    timestamps: {
        inserted_at?: number | null;
        started_at?: number | null;
        finished_at?: number | null;
        updated_at?: number | null;
    };
};
type RESTEvaluation$1 = Omit<Evaluation, "evaluation_id" | "evaluator_id" | "status" | "timestamps" | "retries"> & {
    evaluation_id?: string | null;
    evaluator_id?: string | null;
    status?: "processed" | "skipped" | "error" | null;
    timestamps?: {
        started_at?: number | null;
        finished_at?: number | null;
    } | null;
};
type CollectorRESTParams = {
    trace_id?: string | null | undefined;
    spans: Span[];
    metadata?: {
        user_id?: string | null | undefined;
        thread_id?: string | null | undefined;
        customer_id?: string | null | undefined;
        labels?: string[] | null | undefined;
        sdk_version?: string | null | undefined;
        sdk_language?: string | null | undefined;
    } & CustomMetadata;
    expected_output?: string | null;
    evaluations?: RESTEvaluation$1[];
};
type Event = {
    event_id: string;
    event_type: string;
    project_id: string;
    metrics: Record<string, number>;
    event_details: Record<string, string>;
    trace_id: string;
    timestamps: {
        started_at: number;
        inserted_at: number;
        updated_at: number;
    };
};

type SnakeToCamelCase<S extends string> = S extends `${infer T}_${infer U}` ? `${T}${Capitalize<SnakeToCamelCase<U>>}` : S;
type SnakeToCamelCaseNested<T> = T extends object ? T extends (infer U)[] ? U extends object ? {
    [K in keyof U as SnakeToCamelCase<K & string>]: SnakeToCamelCaseNested<U[K]>;
}[] : T : {
    [K in keyof T as SnakeToCamelCase<K & string>]: SnakeToCamelCaseNested<T[K]>;
} : T;

type Metadata = SnakeToCamelCaseNested<Trace["metadata"]>;
type ChatMessage = ChatMessage$1;
type ChatRichContent = ChatRichContent$1;
type SpanInputOutput = SnakeToCamelCaseNested<Exclude<SpanInputOutput$1, TypedValueChatMessages>> | (TypedValueChatMessages & {
    type: ChatMessage;
});
type ConvertServerSpan<T extends BaseSpan$1> = SnakeToCamelCaseNested<Omit<T, "input" | "output" | "error">> & {
    input?: SpanInputOutput | null;
    output?: SpanInputOutput | null;
    error?: T["error"] | NonNullable<unknown>;
};
type PendingSpan<T extends BaseSpan> = Omit<T, "traceId" | "timestamps"> & {
    timestamps: Omit<T["timestamps"], "finishedAt"> & {
        finishedAt?: number | null;
    };
};
type BaseSpan = ConvertServerSpan<BaseSpan$1>;
type PendingBaseSpan = PendingSpan<BaseSpan>;
type LLMSpan = ConvertServerSpan<Omit<LLMSpan$1, "vendor" | "model">> & {
    model: string;
};
type PendingLLMSpan = PendingSpan<LLMSpan>;
type RAGSpan = ConvertServerSpan<RAGSpan$1>;
type PendingRAGSpan = PendingSpan<RAGSpan>;
type RESTEvaluation = SnakeToCamelCaseNested<Omit<RESTEvaluation$1, "error">> & {
    error?: RESTEvaluation$1["error"];
};

declare function convertFromVercelAIMessages(messages: CoreMessage[]): ChatMessage[];
declare const captureError: (error: unknown) => ErrorCapture;
declare const autoconvertTypedValues: (value: unknown) => SpanInputOutput;

export { type BaseSpan as B, type CollectorRESTParams as C, type LLMSpan as L, type Metadata as M, type PendingBaseSpan as P, type RAGChunk as R, type Span as S, type RESTEvaluation as a, type PendingLLMSpan as b, type PendingRAGSpan as c, type SpanTypes as d, type ChatMessage as e, type ChatRichContent as f, type RAGSpan as g, type SpanInputOutput as h, autoconvertTypedValues as i, captureError as j, convertFromVercelAIMessages as k };
