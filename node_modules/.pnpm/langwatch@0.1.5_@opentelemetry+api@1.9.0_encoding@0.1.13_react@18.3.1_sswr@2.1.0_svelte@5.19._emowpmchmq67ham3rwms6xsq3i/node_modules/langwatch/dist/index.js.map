{"version":3,"sources":["../node_modules/secure-json-parse/index.js","../src/index.ts","../package.json","../src/evaluations.ts","../src/langchain.ts","../src/server/types/tracer.generated.ts","../src/typeUtils.ts","../node_modules/@ai-sdk/provider-utils/src/convert-async-generator-to-readable-stream.ts","../node_modules/@ai-sdk/provider-utils/src/extract-response-headers.ts","../node_modules/@ai-sdk/provider-utils/src/generate-id.ts","../node_modules/@ai-sdk/provider-utils/src/get-error-message.ts","../node_modules/@ai-sdk/provider-utils/src/is-abort-error.ts","../node_modules/@ai-sdk/provider-utils/src/load-api-key.ts","../node_modules/@ai-sdk/provider-utils/src/load-setting.ts","../node_modules/@ai-sdk/provider-utils/src/parse-json.ts","../node_modules/@ai-sdk/provider-utils/src/validate-types.ts","../node_modules/@ai-sdk/provider-utils/src/post-to-api.ts","../node_modules/@ai-sdk/provider-utils/src/response-handler.ts","../node_modules/@ai-sdk/provider-utils/src/uint8-utils.ts","../node_modules/@ai-sdk/provider-utils/src/without-trailing-slash.ts","../src/utils.ts","../src/LangWatchExporter.ts","../node_modules/@opentelemetry/core/src/ExportResult.ts"],"sourcesContent":["'use strict'\n\nconst hasBuffer = typeof Buffer !== 'undefined'\nconst suspectProtoRx = /\"(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])(?:p|\\\\u0070)(?:r|\\\\u0072)(?:o|\\\\u006[Ff])(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])\"\\s*:/\nconst suspectConstructorRx = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/\n\nfunction _parse (text, reviver, options) {\n  // Normalize arguments\n  if (options == null) {\n    if (reviver !== null && typeof reviver === 'object') {\n      options = reviver\n      reviver = undefined\n    }\n  }\n\n  if (hasBuffer && Buffer.isBuffer(text)) {\n    text = text.toString()\n  }\n\n  // BOM checker\n  if (text && text.charCodeAt(0) === 0xFEFF) {\n    text = text.slice(1)\n  }\n\n  // Parse normally, allowing exceptions\n  const obj = JSON.parse(text, reviver)\n\n  // Ignore null and non-objects\n  if (obj === null || typeof obj !== 'object') {\n    return obj\n  }\n\n  const protoAction = (options && options.protoAction) || 'error'\n  const constructorAction = (options && options.constructorAction) || 'error'\n\n  // options: 'error' (default) / 'remove' / 'ignore'\n  if (protoAction === 'ignore' && constructorAction === 'ignore') {\n    return obj\n  }\n\n  if (protoAction !== 'ignore' && constructorAction !== 'ignore') {\n    if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {\n      return obj\n    }\n  } else if (protoAction !== 'ignore' && constructorAction === 'ignore') {\n    if (suspectProtoRx.test(text) === false) {\n      return obj\n    }\n  } else {\n    if (suspectConstructorRx.test(text) === false) {\n      return obj\n    }\n  }\n\n  // Scan result for proto keys\n  return filter(obj, { protoAction, constructorAction, safe: options && options.safe })\n}\n\nfunction filter (obj, { protoAction = 'error', constructorAction = 'error', safe } = {}) {\n  let next = [obj]\n\n  while (next.length) {\n    const nodes = next\n    next = []\n\n    for (const node of nodes) {\n      if (protoAction !== 'ignore' && Object.prototype.hasOwnProperty.call(node, '__proto__')) { // Avoid calling node.hasOwnProperty directly\n        if (safe === true) {\n          return null\n        } else if (protoAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property')\n        }\n\n        delete node.__proto__ // eslint-disable-line no-proto\n      }\n\n      if (constructorAction !== 'ignore' &&\n          Object.prototype.hasOwnProperty.call(node, 'constructor') &&\n          Object.prototype.hasOwnProperty.call(node.constructor, 'prototype')) { // Avoid calling node.hasOwnProperty directly\n        if (safe === true) {\n          return null\n        } else if (constructorAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property')\n        }\n\n        delete node.constructor\n      }\n\n      for (const key in node) {\n        const value = node[key]\n        if (value && typeof value === 'object') {\n          next.push(value)\n        }\n      }\n    }\n  }\n  return obj\n}\n\nfunction parse (text, reviver, options) {\n  const stackTraceLimit = Error.stackTraceLimit\n  Error.stackTraceLimit = 0\n  try {\n    return _parse(text, reviver, options)\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit\n  }\n}\n\nfunction safeParse (text, reviver) {\n  const stackTraceLimit = Error.stackTraceLimit\n  Error.stackTraceLimit = 0\n  try {\n    return _parse(text, reviver, { safe: true })\n  } catch (_e) {\n    return null\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit\n  }\n}\n\nmodule.exports = parse\nmodule.exports.default = parse\nmodule.exports.parse = parse\nmodule.exports.safeParse = safeParse\nmodule.exports.scan = filter\n","import EventEmitter from 'eventemitter3';\nimport { nanoid } from \"nanoid\";\nimport { ZodError } from \"zod\";\nimport { fromZodError } from \"zod-validation-error\";\nimport { version } from \"../package.json\";\nimport {\n  evaluate,\n  type EvaluationParams,\n  type EvaluationResultModel,\n} from \"./evaluations\";\nimport { LangWatchCallbackHandler } from \"./langchain\";\nimport {\n  type CollectorRESTParams,\n  type EvaluationResult,\n  type Span as ServerSpan,\n  type SpanTypes,\n  type TypedValueEvaluationResult,\n} from \"./server/types/tracer\";\nimport {\n  collectorRESTParamsSchema,\n  spanSchema,\n} from \"./server/types/tracer.generated\";\nimport {\n  type BaseSpan,\n  type ChatMessage,\n  type ChatRichContent,\n  type LLMSpan,\n  type Metadata,\n  type PendingBaseSpan,\n  type PendingLLMSpan,\n  type PendingRAGSpan,\n  type RAGSpan,\n  type RESTEvaluation,\n  type SpanInputOutput,\n} from \"./types\";\nimport { camelToSnakeCaseNested, type Strict } from \"./typeUtils\";\nimport {\n  autoconvertTypedValues,\n  captureError,\n  convertFromVercelAIMessages,\n} from \"./utils\";\nimport { LangWatchExporter } from \"./LangWatchExporter\";\n\nexport type {\n  BaseSpan,\n  ChatMessage as ChatMessage,\n  ChatRichContent,\n  LLMSpan,\n  Metadata,\n  PendingBaseSpan,\n  PendingLLMSpan,\n  PendingRAGSpan,\n  RAGSpan,\n  SpanInputOutput,\n};\n\nexport {\n  autoconvertTypedValues,\n  captureError,\n  convertFromVercelAIMessages,\n  LangWatchExporter,\n};\n\nexport class LangWatch extends EventEmitter {\n  apiKey: string | undefined;\n  endpoint: string;\n\n  constructor({\n    apiKey,\n    endpoint = process.env.LANGWATCH_ENDPOINT ?? \"https://app.langwatch.ai\",\n  }: {\n    apiKey?: string;\n    endpoint?: string;\n  } = {}) {\n    super();\n    const apiKey_ = apiKey ?? process.env.LANGWATCH_API_KEY;\n    if (!apiKey_) {\n      const error = new Error(\n        \"LangWatch API key is not set, please set the LANGWATCH_API_KEY environment variable or pass it in the constructor. Traces will not be captured.\"\n      );\n      this.emit(\"error\", error);\n    }\n    this.apiKey = apiKey_;\n    this.endpoint = endpoint;\n  }\n\n  getTrace({\n    traceId,\n    metadata,\n  }: { traceId?: string; metadata?: Metadata } = {}) {\n    return new LangWatchTrace({\n      client: this,\n      traceId: traceId ?? `trace_${nanoid()}`,\n      metadata,\n    });\n  }\n\n  async sendTrace(params: CollectorRESTParams) {\n    const backoff = [1000, 2000, 4000, 8000, 16000];\n    for (const backoffTime of backoff) {\n      try {\n        await this._sendTrace(params);\n        return;\n      } catch (e) {\n        console.warn(\n          `[LangWatch] ⚠️ Failed to send trace, retrying in ${\n            backoffTime / 1000\n          }s`\n        );\n        await new Promise((resolve) => setTimeout(resolve, backoffTime));\n      }\n    }\n    console.warn(\"[LangWatch] ⚠️ Failed to send trace, giving up\");\n  }\n\n  async _sendTrace(params: CollectorRESTParams) {\n    if (params.spans.length === 0) {\n      return;\n    }\n\n    if (!this.apiKey) {\n      const error = new Error(\n        \"LangWatch API key is not set, LLMs traces will not be sent, go to https://langwatch.ai to set it up\"\n      );\n      this.emit(\"error\", error);\n      return;\n    }\n\n    const response = await fetch(`${this.endpoint}/api/collector`, {\n      method: \"POST\",\n      headers: {\n        \"X-Auth-Token\": this.apiKey,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(params),\n    });\n\n    if (response.status === 429) {\n      const error = new Error(\n        \"Rate limit exceeded, dropping message from being sent to LangWatch. Please check your dashboard to upgrade your plan.\"\n      );\n      this.emit(\"error\", error);\n      return;\n    }\n    if (!response.ok) {\n      const error = new Error(\n        `Failed to send trace, status: ${response.status}`\n      );\n      this.emit(\"error\", error);\n      throw error;\n    }\n  }\n}\n\ntype CurrentSpan = {\n  current: LangWatchSpan;\n  previous?: CurrentSpan;\n};\n\ntype AddEvaluationParams = {\n  evaluationId?: string;\n  span?: LangWatchSpan;\n  name: string;\n  type?: string;\n  isGuardrail?: boolean;\n  status?: \"processed\" | \"skipped\" | \"error\";\n  passed?: boolean;\n  score?: number;\n  label?: string;\n  details?: string;\n  error?: Error;\n  timestamps?: RESTEvaluation[\"timestamps\"];\n};\n\nexport class LangWatchTrace {\n  client: LangWatch;\n  traceId: string;\n  metadata?: Metadata;\n  finishedSpans: Record<string, ServerSpan> = {};\n  langchainCallback?: LangWatchCallbackHandler;\n  evaluations: RESTEvaluation[] = [];\n  private currentSpan?: CurrentSpan;\n  private timeoutRef?: NodeJS.Timeout;\n\n  constructor({\n    client,\n    traceId,\n    metadata,\n  }: {\n    client: LangWatch;\n    traceId: string;\n    metadata?: Metadata;\n  }) {\n    this.client = client;\n    this.traceId = traceId;\n    this.metadata = {\n      ...metadata,\n      sdkVersion: version,\n      sdkLanguage: \"typescript\",\n    };\n  }\n\n  update({ metadata }: { metadata: Metadata }) {\n    this.metadata = {\n      ...this.metadata,\n      ...metadata,\n      ...(typeof metadata.labels !== \"undefined\"\n        ? {\n            labels: [\n              ...(this.metadata?.labels ?? []),\n              ...(metadata.labels ?? []),\n            ],\n          }\n        : {}),\n    };\n  }\n\n  setCurrentSpan(span: LangWatchSpan) {\n    this.currentSpan = {\n      current: span,\n      previous: this.currentSpan,\n    };\n  }\n\n  getCurrentSpan() {\n    return this.currentSpan?.current;\n  }\n\n  resetCurrentSpan() {\n    this.currentSpan = this.currentSpan?.previous;\n  }\n\n  startSpan(params: Omit<Partial<PendingBaseSpan>, \"parentId\">) {\n    const span = new LangWatchSpan({\n      trace: this,\n      ...params,\n    });\n    this.setCurrentSpan(span);\n    return span;\n  }\n\n  startLLMSpan(params: Omit<Partial<PendingLLMSpan>, \"parentId\">) {\n    const span = new LangWatchLLMSpan({\n      trace: this,\n      ...params,\n    });\n    this.setCurrentSpan(span);\n    return span;\n  }\n\n  startRAGSpan(params: Omit<Partial<PendingRAGSpan>, \"parentId\">) {\n    const span = new LangWatchRAGSpan({\n      trace: this,\n      ...params,\n    });\n    this.setCurrentSpan(span);\n    return span;\n  }\n\n  addEvaluation = ({\n    evaluationId,\n    span,\n    name,\n    type,\n    isGuardrail,\n    status = \"processed\",\n    passed,\n    score,\n    label,\n    details,\n    error,\n    timestamps,\n  }: AddEvaluationParams): void => {\n    const currentEvaluationIndex = this.evaluations.findIndex(\n      (e) =>\n        evaluationId && \"evaluationId\" in e && e.evaluationId === evaluationId\n    );\n\n    const currentEvaluation =\n      currentEvaluationIndex !== -1\n        ? this.evaluations[currentEvaluationIndex]\n        : undefined;\n\n    const evaluationResult: EvaluationResult = {\n      status,\n      ...(passed !== undefined && { passed }),\n      ...(score !== undefined && { score }),\n      ...(label !== undefined && { label }),\n      ...(details !== undefined && { details }),\n    };\n\n    let span_ = span;\n    if (!span_) {\n      span_ = this.startSpan({\n        type: \"evaluation\",\n      });\n    }\n    if (span_.type !== \"evaluation\") {\n      span_ = span_.startSpan({ type: \"evaluation\" });\n    }\n\n    span_.update({\n      name,\n      output: {\n        type: \"evaluation_result\",\n        value: evaluationResult,\n      } as TypedValueEvaluationResult,\n      error,\n      timestamps: timestamps\n        ? {\n            startedAt: timestamps.startedAt ?? span_.timestamps.startedAt,\n            finishedAt: timestamps.finishedAt ?? undefined,\n          }\n        : undefined,\n    });\n    span_.end();\n\n    const evaluation: RESTEvaluation = {\n      evaluationId: evaluationId ?? `eval_${nanoid()}`,\n      spanId: span_.spanId,\n      name,\n      type,\n      isGuardrail,\n      status,\n      passed,\n      score,\n      label,\n      details,\n      error: error ? captureError(error) : undefined,\n      timestamps: timestamps ?? {\n        startedAt: span_.timestamps.startedAt,\n        finishedAt: span_.timestamps.finishedAt,\n      },\n    };\n\n    if (currentEvaluation && currentEvaluationIndex !== -1) {\n      this.evaluations[currentEvaluationIndex] = {\n        ...currentEvaluation,\n        ...evaluation,\n      };\n    } else {\n      this.evaluations.push(evaluation);\n    }\n  };\n\n  async evaluate(params: EvaluationParams): Promise<EvaluationResultModel> {\n    return evaluate({\n      trace: this,\n      ...params,\n    });\n  }\n\n  getLangChainCallback() {\n    if (!this.langchainCallback) {\n      this.langchainCallback = new LangWatchCallbackHandler({ trace: this });\n    }\n    return this.langchainCallback;\n  }\n\n  onEnd(span: ServerSpan) {\n    this.finishedSpans[span.span_id] = span;\n    this.resetCurrentSpan();\n    this.delayedSendSpans();\n  }\n\n  delayedSendSpans() {\n    clearTimeout(this.timeoutRef);\n    this.timeoutRef = setTimeout(() => {\n      void this.sendSpans();\n    }, 1000);\n  }\n\n  async sendSpans() {\n    clearTimeout(this.timeoutRef);\n\n    let trace: CollectorRESTParams | undefined = undefined;\n    try {\n      trace = collectorRESTParamsSchema.parse({\n        trace_id: this.traceId,\n        metadata: camelToSnakeCaseNested(this.metadata, \"metadata\"),\n        spans: Object.values(this.finishedSpans),\n        evaluations: camelToSnakeCaseNested(this.evaluations),\n      } as Strict<CollectorRESTParams>);\n    } catch (error) {\n      if (error instanceof ZodError) {\n        console.warn(\"[LangWatch] ⚠️ Failed to parse trace\");\n        console.warn(fromZodError(error).message);\n      }\n      this.client.emit(\"error\", error);\n    }\n\n    if (trace) {\n      await this.client.sendTrace(trace);\n    }\n  }\n}\n\nexport class LangWatchSpan implements PendingBaseSpan {\n  trace: LangWatchTrace;\n\n  spanId: string;\n  parentId?: string | null;\n  type: SpanTypes;\n  name?: string | null;\n  input?: PendingBaseSpan[\"input\"];\n  output?: PendingBaseSpan[\"output\"];\n  error?: PendingBaseSpan[\"error\"];\n  timestamps: PendingBaseSpan[\"timestamps\"];\n  metrics: PendingBaseSpan[\"metrics\"];\n\n  constructor({\n    trace,\n    spanId,\n    parentId,\n    type,\n    name,\n    input,\n    output,\n    error,\n    timestamps,\n    metrics,\n  }: Partial<PendingBaseSpan> & { trace: LangWatchTrace }) {\n    this.spanId = spanId ?? `span_${nanoid()}`;\n    this.parentId = parentId;\n    this.trace = trace;\n    this.type = type ?? \"span\";\n    this.name = name;\n    this.input = input;\n    this.output = output;\n    this.error = error;\n    this.timestamps = timestamps ?? {\n      startedAt: Date.now(),\n    };\n    this.metrics = metrics;\n  }\n\n  update(params: Partial<Omit<PendingBaseSpan, \"spanId\" | \"parentId\">>) {\n    if (Object.isFrozen(this)) {\n      const error = new Error(\n        `Tried to update span ${this.spanId}, but the span is already finished, discarding update`\n      );\n      this.trace.client.emit(\"error\", error);\n      return;\n    }\n\n    if (params.type) {\n      this.type = params.type;\n    }\n    if (\"name\" in params) {\n      this.name = params.name;\n    }\n    if (\"input\" in params) {\n      this.input = params.input;\n    }\n    if (\"output\" in params) {\n      this.output = params.output;\n    }\n    if (\"error\" in params) {\n      this.error = params.error;\n    }\n    if (params.timestamps) {\n      this.timestamps = params.timestamps;\n    }\n    if (\"metrics\" in params) {\n      this.metrics = params.metrics;\n    }\n  }\n\n  startSpan(params: Omit<Partial<PendingBaseSpan>, \"parentId\">) {\n    const span = new LangWatchSpan({\n      trace: this.trace,\n      parentId: this.spanId,\n      ...params,\n    });\n    this.trace.setCurrentSpan(span);\n    return span;\n  }\n\n  startLLMSpan(params: Omit<Partial<PendingLLMSpan>, \"parentId\">) {\n    const span = new LangWatchLLMSpan({\n      trace: this.trace,\n      parentId: this.spanId,\n      ...params,\n    });\n    this.trace.setCurrentSpan(span);\n    return span;\n  }\n\n  startRAGSpan(params: Omit<Partial<PendingRAGSpan>, \"parentId\">) {\n    const span = new LangWatchRAGSpan({\n      trace: this.trace,\n      parentId: this.spanId,\n      ...params,\n    });\n    this.trace.setCurrentSpan(span);\n    return span;\n  }\n\n  addEvaluation(params: AddEvaluationParams) {\n    this.trace.addEvaluation({\n      ...params,\n      span: this,\n    });\n  }\n\n  async evaluate(params: EvaluationParams): Promise<EvaluationResultModel> {\n    return evaluate({\n      span: this,\n      ...params,\n    });\n  }\n\n  end(params?: Partial<Omit<PendingBaseSpan, \"spanId\" | \"parentId\">>) {\n    this.timestamps.finishedAt = Date.now();\n    if (params) {\n      this.update(params);\n    }\n\n    Object.freeze(this);\n\n    try {\n      const finalSpan = spanSchema.parse(\n        camelToSnakeCaseNested({\n          ...this,\n          trace: undefined,\n          traceId: this.trace.traceId,\n          timestamps: {\n            ...this.timestamps,\n            finishedAt: this.timestamps.finishedAt,\n          },\n          ...(this.error && { error: captureError(this.error) }),\n        }) as ServerSpan\n      );\n      this.trace.onEnd(finalSpan);\n    } catch (error) {\n      if (error instanceof ZodError) {\n        console.warn(\"[LangWatch] ⚠️ Failed to parse span\");\n        console.warn(fromZodError(error).message);\n      }\n      this.trace.client.emit(\"error\", error);\n    }\n  }\n}\n\nexport class LangWatchLLMSpan extends LangWatchSpan implements PendingLLMSpan {\n  type: \"llm\";\n  model: PendingLLMSpan[\"model\"];\n  params: PendingLLMSpan[\"params\"];\n\n  constructor(params: Partial<PendingLLMSpan> & { trace: LangWatchTrace }) {\n    super({ ...params });\n    this.type = \"llm\";\n    this.model = params.model ?? \"unknown\";\n    this.params = params.params ?? {};\n  }\n\n  update(params: Partial<PendingLLMSpan>) {\n    super.update(params);\n    if (params.model) {\n      this.model = params.model;\n    }\n    if (params.params) {\n      this.params = params.params;\n    }\n  }\n\n  end(params?: Partial<PendingLLMSpan>) {\n    super.end(params);\n  }\n}\n\nexport class LangWatchRAGSpan extends LangWatchSpan implements PendingRAGSpan {\n  type: \"rag\";\n  contexts: PendingRAGSpan[\"contexts\"];\n\n  constructor(params: Partial<PendingRAGSpan> & { trace: LangWatchTrace }) {\n    super({ ...params });\n    this.type = \"rag\";\n    this.contexts = params.contexts ?? [];\n  }\n\n  update(params: Partial<PendingRAGSpan>) {\n    super.update(params);\n    if (params.contexts) {\n      this.contexts = params.contexts;\n    }\n  }\n\n  end(params?: Partial<PendingRAGSpan>) {\n    super.end(params);\n  }\n}\n","{\n  \"name\": \"langwatch\",\n  \"version\": \"0.1.5\",\n  \"description\": \"\",\n  \"main\": \"./dist/index.js\",\n  \"module\": \"./dist/index.mjs\",\n  \"types\": \"./dist/index.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/index.mjs\",\n      \"require\": \"./dist/index.js\"\n    }\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/langwatch/langwatch.git\",\n    \"directory\": \"typescript-sdk\"\n  },\n  \"scripts\": {\n    \"prepare\": \"./copy-types.sh\",\n    \"test\": \"vitest\",\n    \"build\": \"npm run prepare && tsup && esbuild src/index.ts --bundle --platform=node --outfile=dist/index.js\",\n    \"prepublish\": \"npm run build\"\n  },\n  \"author\": \"\",\n  \"license\": \"Apache-2.0\",\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  },\n  \"devDependencies\": {\n    \"@ai-sdk/openai\": \"^0.0.18\",\n    \"@eslint/js\": \"^9.4.0\",\n    \"@types/debug\": \"^4.1.12\",\n    \"@types/eslint__js\": \"^8.42.3\",\n    \"@types/node\": \"^16.0.0\",\n    \"dotenv\": \"^16.4.5\",\n    \"esbuild\": \"^0.21.5\",\n    \"eslint\": \"^8.57.0\",\n    \"ts-to-zod\": \"3.8.5\",\n    \"tsup\": \"^8.1.0\",\n    \"typescript\": \"^4.9.5\",\n    \"typescript-eslint\": \"^7.11.0\",\n    \"vitest\": \"^0.5.0\"\n  },\n  \"dependencies\": {\n    \"@langchain/core\": \"^0.2.7\",\n    \"@opentelemetry/otlp-transformer\": \"^0.56.0\",\n    \"@opentelemetry/sdk-trace-base\": \"^1.29.0\",\n    \"ai\": \"^3.1.23\",\n    \"eventemitter3\": \"^5.0.1\",\n    \"javascript-stringify\": \"^2.1.0\",\n    \"nanoid\": \"^5.0.7\",\n    \"openai\": \"^4.47.3\",\n    \"zod\": \"^3.22.4\",\n    \"zod-validation-error\": \"^3.3.0\"\n  }\n}\n","import { type LangWatchSpan, type LangWatchTrace } from \"./index\";\nimport { type Conversation } from \"./server/types/evaluations\";\nimport {\n  type Evaluators,\n  type EvaluatorTypes,\n} from \"./server/types/evaluators.generated\";\nimport {\n  type RAGChunk,\n  type SpanTypes,\n  type TypedValueEvaluationResult,\n  type TypedValueGuardrailResult,\n  type TypedValueJson,\n} from \"./server/types/tracer\";\n\ntype Money = {\n  currency: string;\n  amount: number;\n};\n\nexport type EvaluationResultModel = {\n  status: \"processed\" | \"skipped\" | \"error\";\n  passed?: boolean;\n  score?: number;\n  details?: string;\n  label?: string;\n  cost?: Money;\n};\n\nexport type CommonEvaluationParams = {\n  name?: string;\n  input?: string;\n  output?: string;\n  expectedOutput?: string;\n  contexts?: RAGChunk[] | string[];\n  conversation?: Conversation;\n  asGuardrail?: boolean;\n  trace?: LangWatchTrace;\n  span?: LangWatchSpan;\n};\n\nexport type SavedEvaluationParams = {\n  slug: string;\n  settings?: Record<string, unknown>;\n} & CommonEvaluationParams;\n\nexport type LangEvalsEvaluationParams<T extends EvaluatorTypes> = {\n  evaluator: T;\n  settings?: Evaluators[T][\"settings\"];\n} & CommonEvaluationParams;\n\nexport type EvaluationParams =\n  | SavedEvaluationParams\n  | LangEvalsEvaluationParams<EvaluatorTypes>;\n\nexport const evaluate = async (\n  params: EvaluationParams\n): Promise<EvaluationResultModel> => {\n  const slug = \"slug\" in params ? params.slug : params.evaluator;\n  const span = optionalCreateSpan({\n    trace: params.trace,\n    span: params.span,\n    name: params.name ? params.name : slug,\n    type: params.asGuardrail ? \"guardrail\" : \"evaluation\",\n  });\n\n  try {\n    const requestParams = prepareData({\n      ...params,\n      slug,\n      traceId: span?.trace.traceId,\n      spanId: span?.spanId,\n      span,\n    });\n\n    const response = await fetch(requestParams.url, {\n      method: \"POST\",\n      headers: requestParams.headers,\n      body: JSON.stringify(requestParams.json),\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    const result = await response.json();\n    return handleResponse(result, span, params.asGuardrail);\n  } catch (e) {\n    return handleException(e as Error, span, params.asGuardrail);\n  }\n};\n\nconst optionalCreateSpan = ({\n  trace,\n  span,\n  name,\n  type,\n}: {\n  trace?: LangWatchTrace;\n  span?: LangWatchSpan;\n  name: string;\n  type: SpanTypes;\n}): LangWatchSpan | undefined => {\n  if (span) {\n    return span.startSpan({ name, type });\n  } else if (trace) {\n    return trace.startSpan({ name, type });\n  }\n  return undefined;\n};\n\nconst prepareData = (params: {\n  slug: string;\n  name?: string;\n  input?: string;\n  output?: string;\n  expectedOutput?: string;\n  contexts?: RAGChunk[] | string[];\n  conversation?: Conversation;\n  settings?: Record<string, unknown>;\n  traceId?: string;\n  spanId?: string;\n  span?: LangWatchSpan;\n  asGuardrail?: boolean;\n}) => {\n  const data: Record<string, unknown> = {};\n  if (params.input) data.input = params.input;\n  if (params.output) data.output = params.output;\n  if (params.expectedOutput) data.expected_output = params.expectedOutput;\n  if (params.contexts && params.contexts.length > 0)\n    data.contexts = params.contexts;\n  if (params.conversation && params.conversation.length > 0)\n    data.conversation = params.conversation;\n\n  if (params.span) {\n    params.span.update({\n      input: { type: \"json\", value: data } as TypedValueJson,\n      params: params.settings,\n    });\n  }\n\n  return {\n    url: `${process.env.LANGWATCH_ENDPOINT}/api/evaluations/${params.slug}/evaluate`,\n    json: {\n      trace_id: params.traceId,\n      span_id: params.spanId,\n      name: params.name,\n      data,\n      settings: params.settings,\n      as_guardrail: params.asGuardrail,\n    },\n    headers: {\n      \"X-Auth-Token\": process.env.LANGWATCH_API_KEY ?? \"\",\n      \"Content-Type\": \"application/json\",\n    },\n  };\n};\n\nconst handleResponse = (\n  response: EvaluationResultModel,\n  span?: LangWatchSpan,\n  asGuardrail = false\n): EvaluationResultModel => {\n  if (response.status === \"error\") {\n    response.details = response.details ?? \"\";\n  }\n\n  for (const key of Object.keys(response)) {\n    if (\n      response[key as keyof EvaluationResultModel] === null ||\n      response[key as keyof EvaluationResultModel] === undefined\n    ) {\n      delete response[key as keyof EvaluationResultModel];\n    }\n  }\n\n  if (span) {\n    const output: TypedValueGuardrailResult | TypedValueEvaluationResult =\n      asGuardrail\n        ? {\n            type: \"guardrail_result\",\n            value: response,\n          }\n        : {\n            type: \"evaluation_result\",\n            value: response,\n          };\n\n    span.update({ output });\n\n    if (response.cost) {\n      span.update({\n        metrics: {\n          cost: response.cost.amount,\n        },\n      });\n    }\n\n    span.end();\n  }\n\n  return response;\n};\n\nconst handleException = (\n  e: Error,\n  span?: LangWatchSpan,\n  asGuardrail = false\n): EvaluationResultModel => {\n  const response: EvaluationResultModel = {\n    status: \"error\",\n    details: e.toString(),\n  };\n\n  if (asGuardrail) {\n    response.passed = true;\n  }\n\n  return handleResponse(response, span, asGuardrail);\n};\n","import type { AgentAction, AgentFinish } from \"@langchain/core/agents\";\nimport { BaseCallbackHandler } from \"@langchain/core/callbacks/base\";\nimport { type DocumentInterface } from \"@langchain/core/documents\";\nimport type { Serialized } from \"@langchain/core/load/serializable\";\nimport {\n  AIMessage,\n  AIMessageChunk,\n  FunctionMessage,\n  FunctionMessageChunk,\n  HumanMessage,\n  HumanMessageChunk,\n  SystemMessage,\n  SystemMessageChunk,\n  ToolMessage,\n  ToolMessageChunk,\n  mapChatMessagesToStoredMessages,\n  type BaseMessage,\n  type StoredMessage,\n} from \"@langchain/core/messages\";\nimport type { ChatGeneration, LLMResult } from \"@langchain/core/outputs\";\nimport type { ChainValues } from \"@langchain/core/utils/types\";\nimport { stringify } from \"javascript-stringify\";\nimport {\n  type LangWatchRAGSpan,\n  type LangWatchSpan,\n  type LangWatchTrace,\n} from \".\";\nimport {\n  type RAGSpan,\n  type BaseSpan,\n  type ChatMessage,\n  type ChatRichContent,\n  type SpanInputOutput,\n} from \"./types\";\n\nexport class LangWatchCallbackHandler extends BaseCallbackHandler {\n  name = \"LangWatchCallbackHandler\";\n  trace: LangWatchTrace;\n  spans: Record<string, LangWatchSpan> = {};\n\n  constructor({ trace }: { trace: LangWatchTrace }) {\n    super();\n    this.trace = trace;\n  }\n\n  async handleLLMStart(\n    llm: Serialized,\n    prompts: string[],\n    runId: string,\n    parentRunId?: string | undefined,\n    extraParams?: Record<string, unknown> | undefined,\n    _tags?: string[] | undefined,\n    metadata?: Record<string, unknown> | undefined,\n    name?: string\n  ): Promise<void> {\n    this.spans[runId] = this.buildLLMSpan({\n      llm,\n      runId,\n      parentRunId,\n      input: {\n        type: \"json\",\n        value: prompts,\n      },\n      extraParams,\n      metadata,\n      name,\n    });\n  }\n\n  private buildLLMSpan({\n    llm,\n    runId,\n    parentRunId,\n    input,\n    extraParams,\n    metadata,\n    name,\n  }: {\n    llm: Serialized;\n    runId: string;\n    parentRunId?: string | undefined;\n    input: SpanInputOutput;\n    extraParams?: Record<string, unknown> | undefined;\n    metadata?: Record<string, unknown> | undefined;\n    name?: string | undefined;\n  }) {\n    try {\n      const parent = this.getParent(parentRunId);\n\n      const vendor = metadata?.ls_provider ?? llm.id.at(-2)?.toString();\n      const model =\n        metadata?.ls_model_name ?? (llm as any).kwargs?.model ?? \"unknown\";\n\n      const span = parent.startLLMSpan({\n        spanId: runId,\n        name: name ?? llm.id.at(-1)?.toString(),\n        input,\n        model: [vendor, model].filter((x) => x).join(\"/\"),\n        params: {\n          temperature: (extraParams?.invocation_params as any)?.temperature,\n          ...((extraParams?.invocation_params as any)?.functions\n            ? { functions: (extraParams?.invocation_params as any)?.functions }\n            : {}),\n        },\n      });\n\n      return span;\n    } catch (e) {\n      this.trace.client.emit(\"error\", e);\n      throw e;\n    }\n  }\n\n  async handleChatModelStart(\n    llm: Serialized,\n    messages: BaseMessage[][],\n    runId: string,\n    parentRunId?: string | undefined,\n    extraParams?: Record<string, unknown> | undefined,\n    tags?: string[] | undefined,\n    metadata?: Record<string, unknown> | undefined,\n    name?: string\n  ): Promise<void> {\n    this.spans[runId] = this.buildLLMSpan({\n      name,\n      llm,\n      runId,\n      parentRunId,\n      input: {\n        type: \"chat_messages\",\n        value: messages.flatMap(convertFromLangChainMessages),\n      },\n      extraParams,\n      metadata,\n    });\n  }\n\n  async handleNewToken(_token: string, runId: string): Promise<void> {\n    const span = this.spans[runId];\n    if (runId && span && !span.timestamps.firstTokenAt) {\n      span.update({\n        timestamps: { ...span.timestamps, firstTokenAt: Date.now() },\n      });\n    }\n  }\n\n  async handleLLMEnd(\n    response: LLMResult,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    try {\n      const span = this.spans[runId];\n      if (!span) {\n        return;\n      }\n\n      const outputs: SpanInputOutput[] = [];\n      for (const generation of response.generations) {\n        // TODO: again, why the twice loop? Can OpenAI generate multiple chat outputs?\n        for (const generation_ of generation) {\n          if (\"message\" in generation_) {\n            outputs.push({\n              type: \"chat_messages\",\n              value: convertFromLangChainMessages([\n                (generation_ as ChatGeneration).message,\n              ]),\n            });\n          } else if (\"text\" in generation_) {\n            outputs.push({\n              type: \"text\",\n              value: generation_.text,\n            });\n          } else {\n            outputs.push({\n              type: \"text\",\n              value: JSON.stringify(generation_),\n            });\n          }\n        }\n      }\n\n      const output: SpanInputOutput | undefined =\n        outputs.length === 1\n          ? outputs[0]\n          : { type: \"list\", value: outputs as any };\n\n      // Commenting it out because LangChain.js prompt and completion tokens is broken, this one doesn't work as it should with python,\n      // and response_metadata.prompt and response_metadata.completion is there but it's always 0. Better let our server count.\n      // const metrics = response.llmOutput?.token_usage\n      //   ? {\n      //       promptTokens: response.llmOutput.token_usage.prompt_tokens,\n      //       completionTokens: response.llmOutput.token_usage.completion_tokens,\n      //     }\n      //   : undefined;\n\n      span.end({\n        output,\n        // ...(metrics ? { metrics } : {}),\n      });\n    } catch (e) {\n      this.trace.client.emit(\"error\", e);\n      throw e;\n    }\n  }\n\n  async handleLLMError(\n    err: Error,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    this.errorSpan({ runId, error: err });\n  }\n\n  async handleChainStart(\n    chain: Serialized,\n    inputs: ChainValues,\n    runId: string,\n    parentRunId?: string | undefined,\n    _tags?: string[] | undefined,\n    _metadata?: Record<string, unknown> | undefined,\n    _runType?: string,\n    name?: string\n  ): Promise<void> {\n    this.spans[runId] = this.buildSpan({\n      type: \"chain\",\n      serialized: chain,\n      runId,\n      parentRunId,\n      input: inputs,\n      name,\n    });\n  }\n\n  async handleChainEnd(\n    output: ChainValues,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    this.endSpan({\n      runId,\n      output,\n    });\n  }\n\n  async handleChainError(\n    err: Error,\n    runId: string,\n    _parentRunId?: string | undefined,\n    _tags?: string[] | undefined,\n    _kwargs?: { inputs?: Record<string, unknown> | undefined } | undefined\n  ): Promise<void> {\n    this.errorSpan({ runId, error: err });\n  }\n\n  async handleToolStart(\n    tool: Serialized,\n    input: string,\n    runId: string,\n    parentRunId?: string | undefined,\n    _tags?: string[] | undefined,\n    _metadata?: Record<string, unknown> | undefined,\n    name?: string\n  ): Promise<void> {\n    this.spans[runId] = this.buildSpan({\n      type: \"tool\",\n      serialized: tool,\n      runId,\n      parentRunId,\n      input,\n      name,\n    });\n  }\n\n  async handleToolEnd(\n    output: string,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    this.endSpan({ runId, output });\n  }\n\n  async handleToolError(\n    err: Error,\n    runId: string,\n    _parentRunId?: string | undefined,\n    _tags?: string[] | undefined\n  ): Promise<void> {\n    this.errorSpan({ runId, error: err });\n  }\n\n  async handleRetrieverStart(\n    retriever: Serialized,\n    query: string,\n    runId: string,\n    parentRunId?: string | undefined,\n    _tags?: string[] | undefined,\n    _metadata?: Record<string, unknown> | undefined,\n    name?: string | undefined\n  ) {\n    try {\n      const parent = this.getParent(parentRunId);\n\n      this.spans[runId] = parent.startRAGSpan({\n        spanId: runId,\n        name: name ?? retriever.name ?? retriever.id.at(-1)?.toString(),\n        input: this.autoconvertTypedValues(query),\n      });\n    } catch (e) {\n      this.trace.client.emit(\"error\", e);\n      throw e;\n    }\n  }\n\n  async handleRetrieverEnd(\n    documents: DocumentInterface<Record<string, any>>[],\n    runId: string,\n    _parentRunId?: string | undefined,\n    _tags?: string[] | undefined\n  ) {\n    try {\n      const contexts: RAGSpan[\"contexts\"] = documents.map((doc) => ({\n        content: doc.pageContent,\n        ...(doc.metadata.source ? { documentId: doc.metadata.source } : {}),\n      }));\n\n      const span = this.spans[runId] as LangWatchRAGSpan;\n      if (!span) {\n        return;\n      }\n\n      span.end({\n        contexts,\n        output: this.autoconvertTypedValues(documents),\n      });\n    } catch (e) {\n      this.trace.client.emit(\"error\", e);\n      throw e;\n    }\n  }\n\n  async handleRetrieverError(\n    err: Error,\n    runId: string,\n    _parentRunId?: string | undefined,\n    _tags?: string[] | undefined\n  ) {\n    this.errorSpan({ runId, error: err });\n  }\n\n  async handleAgentAction(\n    _action: AgentAction,\n    runId: string,\n    _parentRunId?: string | undefined,\n    _tags?: string[] | undefined\n  ): Promise<void> {\n    const span = this.spans[runId];\n    if (!span) {\n      return;\n    }\n\n    span.update({\n      type: \"agent\",\n    });\n  }\n\n  async handleAgentEnd(\n    action: AgentFinish,\n    runId: string,\n    _parentRunId?: string | undefined,\n    _tags?: string[] | undefined\n  ): Promise<void> {\n    this.endSpan({\n      runId,\n      output: action.returnValues,\n    });\n  }\n\n  private buildSpan({\n    type,\n    serialized,\n    runId,\n    parentRunId,\n    input,\n    name,\n  }: {\n    type: BaseSpan[\"type\"];\n    serialized: Serialized;\n    runId: string;\n    parentRunId?: string | undefined;\n    input: unknown;\n    name?: string | undefined;\n  }) {\n    try {\n      const parent = this.getParent(parentRunId);\n\n      const span = parent.startSpan({\n        spanId: runId,\n        type,\n        name: name ?? serialized.name ?? serialized.id.at(-1)?.toString(),\n        input: this.autoconvertTypedValues(input),\n      });\n\n      return span;\n    } catch (e) {\n      this.trace.client.emit(\"error\", e);\n      throw e;\n    }\n  }\n\n  private endSpan({ runId, output }: { runId: string; output: unknown }): void {\n    try {\n      const span = this.spans[runId];\n      if (!span) {\n        return;\n      }\n\n      span.end({\n        output: this.autoconvertTypedValues(output),\n      });\n    } catch (e) {\n      this.trace.client.emit(\"error\", e);\n      throw e;\n    }\n  }\n\n  private errorSpan({ runId, error }: { runId: string; error: Error }): void {\n    const span = this.spans[runId];\n    if (!span) {\n      return;\n    }\n\n    span.end({\n      error,\n    });\n  }\n\n  private autoconvertTypedValues(value: any): SpanInputOutput | undefined {\n    if (\n      !value ||\n      (typeof value === \"object\" && Object.keys(value).length === 0)\n    ) {\n      return undefined;\n    }\n    if (typeof value === \"string\") {\n      return { type: \"text\", value };\n    }\n    try {\n      JSON.stringify(value);\n      return { type: \"json\", value };\n    } catch (e) {\n      return { type: \"text\", value: stringify(value) ?? value.toString() };\n    }\n  }\n\n  private getParent(\n    parentRunId?: string | undefined\n  ): LangWatchSpan | LangWatchTrace {\n    return (\n      (parentRunId\n        ? this.spans[parentRunId]\n        : this.spans[Object.keys(this.spans).at(-1) ?? \"\"]) ?? this.trace\n    );\n  }\n}\n\nexport const convertFromLangChainMessages = (\n  messages: BaseMessage[]\n): ChatMessage[] => {\n  const chatMessages: ChatMessage[] = [];\n  for (const message of messages) {\n    chatMessages.push(convertFromLangChainMessage(message));\n  }\n  return chatMessages;\n};\n\nconst convertFromLangChainMessage = (\n  message: BaseMessage & { id?: string[] }\n): ChatMessage => {\n  let role: ChatMessage[\"role\"] = \"user\";\n\n  const message_: (BaseMessage | StoredMessage) & {\n    id?: string[];\n    type?: string;\n  } = message.lc_serializable\n    ? mapChatMessagesToStoredMessages([message])[0]!\n    : message;\n\n  // Dang this is so hard, langchain.js has 3 ways of representing the same thing...\n  if (\n    message_ instanceof HumanMessage ||\n    message_ instanceof HumanMessageChunk ||\n    message_.id?.at(-1) === \"HumanMessage\" ||\n    message_.id?.at(-1) === \"HumanMessageChunk\" ||\n    message_.type === \"human\"\n  ) {\n    role = \"user\";\n  } else if (\n    message instanceof AIMessage ||\n    message instanceof AIMessageChunk ||\n    message.id?.at(-1) === \"AIMessage\" ||\n    message.id?.at(-1) === \"AIMessageChunk\" ||\n    message_.type === \"ai\"\n  ) {\n    role = \"assistant\";\n  } else if (\n    message instanceof SystemMessage ||\n    message instanceof SystemMessageChunk ||\n    message.id?.at(-1) === \"SystemMessage\" ||\n    message.id?.at(-1) === \"SystemMessageChunk\" ||\n    message_.type === \"system\"\n  ) {\n    role = \"system\";\n  } else if (\n    message instanceof FunctionMessage ||\n    message instanceof FunctionMessageChunk ||\n    message.id?.at(-1) === \"FunctionMessage\" ||\n    message.id?.at(-1) === \"FunctionMessageChunk\" ||\n    message_.type === \"function\"\n  ) {\n    role = \"function\";\n  } else if (\n    message instanceof ToolMessage ||\n    message instanceof ToolMessageChunk ||\n    message.id?.at(-1) === \"ToolMessage\" ||\n    message.id?.at(-1) === \"ToolMessageChunk\" ||\n    message_.type === \"tool\"\n  ) {\n    role = \"tool\";\n  }\n\n  const content =\n    typeof message.content === \"string\"\n      ? message.content\n      : message.content.map(\n          (content): ChatRichContent =>\n            content.type === \"text\"\n              ? { type: \"text\", text: content.text }\n              : content.type == \"image_url\"\n              ? { type: \"image_url\", image_url: content.image_url }\n              : { type: \"text\", text: JSON.stringify(content) }\n        );\n\n  const functionCall = message.additional_kwargs as\n    | ChatMessage[\"function_call\"]\n    | undefined;\n\n  return {\n    role,\n    content,\n    ...(functionCall &&\n    typeof functionCall === \"object\" &&\n    Object.keys(functionCall).length > 0\n      ? { function_call: functionCall }\n      : {}),\n  };\n};\n","// Generated by ts-to-zod\nimport { z } from \"zod\";\nimport { SpanInputOutput } from \"./tracer\";\n\nconst chatRoleSchema = z.union([\n  z.literal(\"system\"),\n  z.literal(\"user\"),\n  z.literal(\"assistant\"),\n  z.literal(\"function\"),\n  z.literal(\"tool\"),\n  z.literal(\"unknown\"),\n]);\n\nconst functionCallSchema = z.object({\n  name: z.string().optional(),\n  arguments: z.string().optional(),\n});\n\nconst toolCallSchema = z.object({\n  id: z.string(),\n  type: z.string(),\n  function: functionCallSchema,\n});\n\nexport const rAGChunkSchema = z.object({\n  document_id: z.string().optional().nullable(),\n  chunk_id: z.string().optional().nullable(),\n  content: z.union([z.string(), z.record(z.any()), z.array(z.any())]),\n});\n\nexport const chatRichContentSchema = z.union([\n  z.object({\n    type: z.literal(\"text\"),\n    text: z.string().optional(),\n  }),\n  z.object({\n    type: z.literal(\"image_url\"),\n    image_url: z\n      .object({\n        url: z.string(),\n        detail: z\n          .union([z.literal(\"auto\"), z.literal(\"low\"), z.literal(\"high\")])\n          .optional(),\n      })\n      .optional(),\n  }),\n  z.object({\n    type: z.literal(\"tool_call\"),\n    toolName: z.string().optional(),\n    toolCallId: z.string().optional(),\n    args: z.string().optional(),\n  }),\n  z.object({\n    type: z.literal(\"tool_result\"),\n    toolName: z.string().optional(),\n    toolCallId: z.string().optional(),\n    result: z.any().optional(),\n  }),\n]);\n\nconst typedValueTextSchema = z.object({\n  type: z.literal(\"text\"),\n  value: z.string(),\n});\n\nconst typedValueRawSchema = z.object({\n  type: z.literal(\"raw\"),\n  value: z.string(),\n});\n\nconst jSONSerializableSchema = z\n  .union([\n    z.string(),\n    z.number(),\n    z.boolean(),\n    z.record(z.any()),\n    z.array(z.any()),\n  ])\n  .nullable();\n\nexport const typedValueJsonSchema = z.object({\n  type: z.literal(\"json\"),\n  value: jSONSerializableSchema,\n});\n\nexport const moneySchema = z.object({\n  currency: z.string(),\n  amount: z.number(),\n});\n\nexport const evaluationResultSchema = z.object({\n  status: z.union([\n    z.literal(\"processed\"),\n    z.literal(\"skipped\"),\n    z.literal(\"error\"),\n  ]),\n  passed: z.boolean().optional().nullable(),\n  score: z.number().optional().nullable(),\n  label: z.string().optional().nullable(),\n  details: z.string().optional().nullable(),\n  cost: moneySchema.optional().nullable(),\n});\n\nexport const typedValueGuardrailResultSchema = z.object({\n  type: z.literal(\"guardrail_result\"),\n  value: evaluationResultSchema,\n});\n\nexport const typedValueEvaluationResultSchema = z.object({\n  type: z.literal(\"evaluation_result\"),\n  value: evaluationResultSchema,\n});\n\nexport const errorCaptureSchema = z.object({\n  has_error: z.literal(true),\n  message: z.string(),\n  stacktrace: z.array(z.string()),\n});\n\nexport const spanMetricsSchema = z.object({\n  prompt_tokens: z.number().optional().nullable(),\n  completion_tokens: z.number().optional().nullable(),\n  tokens_estimated: z.boolean().optional().nullable(),\n  cost: z.number().optional().nullable(),\n});\n\nexport const reservedSpanParamsSchema = z.object({\n  frequency_penalty: z.number().optional().nullable(),\n  logit_bias: z.record(z.number()).optional().nullable(),\n  logprobs: z.boolean().optional().nullable(),\n  top_logprobs: z.number().optional().nullable(),\n  max_tokens: z.number().optional().nullable(),\n  n: z.number().optional().nullable(),\n  presence_penalty: z.number().optional().nullable(),\n  seed: z.number().optional().nullable(),\n  stop: z\n    .union([z.string(), z.array(z.string())])\n    .optional()\n    .nullable(),\n  stream: z.boolean().optional().nullable(),\n  temperature: z.number().optional().nullable(),\n  top_p: z.number().optional().nullable(),\n  tools: z.array(z.record(z.any())).optional().nullable(),\n  tool_choice: z\n    .union([z.record(z.any()), z.string()])\n    .optional()\n    .nullable(),\n  parallel_tool_calls: z.boolean().optional().nullable(),\n  functions: z.array(z.record(z.any())).optional().nullable(),\n  user: z.string().optional().nullable(),\n});\n\nexport const spanParamsSchema = reservedSpanParamsSchema.and(z.record(z.any()));\n\nexport const spanTimestampsSchema = z.object({\n  started_at: z.number(),\n  first_token_at: z.number().optional().nullable(),\n  finished_at: z.number(),\n});\n\nexport const spanTypesSchema = z.union([\n  z.literal(\"span\"),\n  z.literal(\"llm\"),\n  z.literal(\"chain\"),\n  z.literal(\"tool\"),\n  z.literal(\"agent\"),\n  z.literal(\"rag\"),\n  z.literal(\"guardrail\"),\n  z.literal(\"evaluation\"),\n  z.literal(\"workflow\"),\n  z.literal(\"component\"),\n  z.literal(\"module\"),\n  z.literal(\"server\"),\n  z.literal(\"client\"),\n  z.literal(\"producer\"),\n  z.literal(\"consumer\"),\n  z.literal(\"task\"),\n  z.literal(\"unknown\"),\n]);\n\nexport const traceInputSchema = z.object({\n  value: z.string(),\n  embeddings: z\n    .object({\n      model: z.string(),\n      embeddings: z.array(z.number()),\n    })\n    .optional(),\n  satisfaction_score: z.number().optional(),\n});\n\nexport const traceOutputSchema = z.object({\n  value: z.string(),\n  embeddings: z\n    .object({\n      model: z.string(),\n      embeddings: z.array(z.number()),\n    })\n    .optional(),\n});\n\nconst primitiveTypeSchema = z\n  .union([z.string(), z.number(), z.boolean(), z.undefined()])\n  .nullable();\n\nexport const reservedTraceMetadataSchema = z.object({\n  thread_id: z.string().optional().nullable(),\n  user_id: z.string().optional().nullable(),\n  customer_id: z.string().optional().nullable(),\n  labels: z.array(z.string()).optional().nullable(),\n  topic_id: z.string().optional().nullable(),\n  subtopic_id: z.string().optional().nullable(),\n  sdk_version: z.string().optional().nullable(),\n  sdk_language: z.string().optional().nullable(),\n});\n\nexport const customMetadataSchema = z.record(\n  z.union([\n    primitiveTypeSchema,\n    z.array(primitiveTypeSchema),\n    z.record(primitiveTypeSchema),\n    z.record(z.record(primitiveTypeSchema)),\n  ]),\n);\n\nexport const traceMetadataSchema =\n  reservedTraceMetadataSchema.and(customMetadataSchema);\n\nexport const eventSchema = z.object({\n  event_id: z.string(),\n  event_type: z.string(),\n  project_id: z.string(),\n  metrics: z.record(z.number()),\n  event_details: z.record(z.string()),\n  trace_id: z.string(),\n  timestamps: z.object({\n    started_at: z.number(),\n    inserted_at: z.number(),\n    updated_at: z.number(),\n  }),\n});\n\nexport const elasticSearchEventSchema = eventSchema\n  .omit({ metrics: true, event_details: true })\n  .and(\n    z.object({\n      metrics: z.array(\n        z.object({\n          key: z.string(),\n          value: z.number(),\n        }),\n      ),\n      event_details: z.array(\n        z.object({\n          key: z.string(),\n          value: z.string(),\n        }),\n      ),\n    }),\n  );\n\nconst evaluationStatusSchema = z.union([\n  z.literal(\"scheduled\"),\n  z.literal(\"in_progress\"),\n  z.literal(\"error\"),\n  z.literal(\"skipped\"),\n  z.literal(\"processed\"),\n]);\n\nexport const trackEventRESTParamsValidatorSchema = eventSchema\n  .omit({\n    event_id: true,\n    project_id: true,\n    timestamps: true,\n    event_details: true,\n  })\n  .and(\n    z.object({\n      event_id: z.string().optional(),\n      event_details: z.record(z.string()).optional(),\n      timestamp: z.number().optional(),\n    }),\n  );\n\nexport const contextsSchema = z.object({\n  traceId: z.string(),\n  contexts: z.array(rAGChunkSchema),\n});\n\nexport const chatMessageSchema = z.object({\n  role: chatRoleSchema.optional(),\n  content: z\n    .union([z.string(), z.array(chatRichContentSchema)])\n    .optional()\n    .nullable(),\n  function_call: functionCallSchema.optional().nullable(),\n  tool_calls: z.array(toolCallSchema).optional().nullable(),\n  tool_call_id: z.string().optional().nullable(),\n  name: z.string().optional().nullable(),\n});\n\nexport const typedValueChatMessagesSchema = z.object({\n  type: z.literal(\"chat_messages\"),\n  value: z.array(chatMessageSchema),\n});\n\nexport const spanInputOutputSchema: z.ZodSchema<SpanInputOutput> = z.lazy(() =>\n  z.union([\n    typedValueTextSchema,\n    typedValueChatMessagesSchema,\n    typedValueGuardrailResultSchema,\n    typedValueEvaluationResultSchema,\n    typedValueJsonSchema,\n    typedValueRawSchema,\n    z.object({\n      type: z.literal(\"list\"),\n      value: z.array(spanInputOutputSchema),\n    }),\n  ]),\n);\n\nexport const baseSpanSchema = z.object({\n  span_id: z.string(),\n  parent_id: z.string().optional().nullable(),\n  trace_id: z.string(),\n  type: spanTypesSchema,\n  name: z.string().optional().nullable(),\n  input: spanInputOutputSchema.optional().nullable(),\n  output: spanInputOutputSchema.optional().nullable(),\n  error: errorCaptureSchema.optional().nullable(),\n  timestamps: spanTimestampsSchema,\n  metrics: spanMetricsSchema.optional().nullable(),\n  params: spanParamsSchema.optional().nullable(),\n});\n\nexport const lLMSpanSchema = baseSpanSchema.extend({\n  type: z.literal(\"llm\"),\n  vendor: z.string().optional().nullable(),\n  model: z.string().optional().nullable(),\n});\n\nexport const rAGSpanSchema = baseSpanSchema.extend({\n  type: z.literal(\"rag\"),\n  contexts: z.array(rAGChunkSchema),\n});\n\nexport const spanSchema = z.union([\n  lLMSpanSchema,\n  rAGSpanSchema,\n  baseSpanSchema,\n]);\n\nconst spanInputOutputValidatorSchema = spanInputOutputSchema.and(\n  z.object({\n    value: z.any(),\n  }),\n);\n\nexport const spanValidatorSchema = z\n  .union([\n    lLMSpanSchema.omit({ input: true, output: true, params: true }),\n    rAGSpanSchema.omit({ input: true, output: true, params: true }),\n    baseSpanSchema.omit({ input: true, output: true, params: true }),\n  ])\n  .and(\n    z.object({\n      input: spanInputOutputValidatorSchema.optional().nullable(),\n      output: spanInputOutputValidatorSchema.optional().nullable(),\n      params: z.record(z.any()).optional().nullable(),\n    }),\n  );\n\nexport const evaluationSchema = z.object({\n  evaluation_id: z.string(),\n  evaluator_id: z.string(),\n  span_id: z.string().optional().nullable(),\n  name: z.string(),\n  type: z.string().optional().nullable(),\n  is_guardrail: z.boolean().optional().nullable(),\n  status: evaluationStatusSchema,\n  passed: z.boolean().optional().nullable(),\n  score: z.number().optional().nullable(),\n  label: z.string().optional().nullable(),\n  details: z.string().optional().nullable(),\n  error: errorCaptureSchema.optional().nullable(),\n  retries: z.number().optional().nullable(),\n  timestamps: z.object({\n    inserted_at: z.number().optional().nullable(),\n    started_at: z.number().optional().nullable(),\n    finished_at: z.number().optional().nullable(),\n    updated_at: z.number().optional().nullable(),\n  }),\n});\n\nexport const elasticSearchEvaluationSchema = evaluationSchema;\n\nexport const rESTEvaluationSchema = evaluationSchema\n  .omit({\n    evaluation_id: true,\n    evaluator_id: true,\n    status: true,\n    timestamps: true,\n    retries: true,\n  })\n  .and(\n    z.object({\n      evaluation_id: z.string().optional().nullable(),\n      evaluator_id: z.string().optional().nullable(),\n      status: z\n        .union([\n          z.literal(\"processed\"),\n          z.literal(\"skipped\"),\n          z.literal(\"error\"),\n        ])\n        .optional()\n        .nullable(),\n      timestamps: z\n        .object({\n          started_at: z.number().optional().nullable(),\n          finished_at: z.number().optional().nullable(),\n        })\n        .optional()\n        .nullable(),\n    }),\n  );\n\nexport const collectorRESTParamsSchema = z.object({\n  trace_id: z.union([z.string(), z.undefined()]).optional().nullable(),\n  spans: z.array(spanSchema),\n  metadata: z\n    .object({\n      user_id: z.union([z.string(), z.undefined()]).optional().nullable(),\n      thread_id: z.union([z.string(), z.undefined()]).optional().nullable(),\n      customer_id: z.union([z.string(), z.undefined()]).optional().nullable(),\n      labels: z\n        .union([z.array(z.string()), z.undefined()])\n        .optional()\n        .nullable(),\n      sdk_version: z.union([z.string(), z.undefined()]).optional().nullable(),\n      sdk_language: z.union([z.string(), z.undefined()]).optional().nullable(),\n    })\n    .and(customMetadataSchema)\n    .optional(),\n  expected_output: z.string().optional().nullable(),\n  evaluations: z.array(rESTEvaluationSchema).optional(),\n});\n\nexport const collectorRESTParamsValidatorSchema =\n  collectorRESTParamsSchema.omit({ spans: true });\n\nexport const datasetSpanSchema = z.union([\n  baseSpanSchema\n    .omit({\n      project_id: true,\n      trace_id: true,\n      id: true,\n      timestamps: true,\n      metrics: true,\n      params: true,\n    })\n    .and(\n      z.object({\n        params: z.record(z.any()),\n      }),\n    ),\n  lLMSpanSchema\n    .omit({\n      project_id: true,\n      trace_id: true,\n      id: true,\n      timestamps: true,\n      metrics: true,\n      params: true,\n    })\n    .and(\n      z.object({\n        params: z.record(z.any()),\n      }),\n    ),\n  rAGSpanSchema\n    .omit({\n      project_id: true,\n      trace_id: true,\n      id: true,\n      timestamps: true,\n      metrics: true,\n      params: true,\n    })\n    .and(\n      z.object({\n        params: z.record(z.any()),\n      }),\n    ),\n]);\n\nexport const traceSchema = z.object({\n  trace_id: z.string(),\n  project_id: z.string(),\n  metadata: traceMetadataSchema,\n  timestamps: z.object({\n    started_at: z.number(),\n    inserted_at: z.number(),\n    updated_at: z.number(),\n  }),\n  input: traceInputSchema.optional(),\n  output: traceOutputSchema.optional(),\n  contexts: z.array(rAGChunkSchema).optional(),\n  expected_output: z\n    .object({\n      value: z.string(),\n    })\n    .optional(),\n  metrics: z\n    .object({\n      first_token_ms: z.number().optional().nullable(),\n      total_time_ms: z.number().optional().nullable(),\n      prompt_tokens: z.number().optional().nullable(),\n      completion_tokens: z.number().optional().nullable(),\n      total_cost: z.number().optional().nullable(),\n      tokens_estimated: z.boolean().optional().nullable(),\n    })\n    .optional(),\n  error: errorCaptureSchema.optional().nullable(),\n  indexing_md5s: z.array(z.string()).optional(),\n  events: z.array(eventSchema).optional(),\n  evaluations: z.array(evaluationSchema).optional(),\n});\n\nexport const traceWithSpansSchema = traceSchema.and(\n  z.object({\n    spans: z.array(spanSchema),\n  }),\n);\n","import {\n  reservedSpanParamsSchema,\n  reservedTraceMetadataSchema,\n} from \"./server/types/tracer.generated\";\n\nexport type Strict<T> = T & { [K in Exclude<keyof any, keyof T>]: never };\n\ntype SnakeToCamelCase<S extends string> = S extends `${infer T}_${infer U}`\n  ? `${T}${Capitalize<SnakeToCamelCase<U>>}`\n  : S;\n\nexport type SnakeToCamelCaseNested<T> = T extends object\n  ? T extends (infer U)[]\n    ? U extends object\n      ? {\n          [K in keyof U as SnakeToCamelCase<\n            K & string\n          >]: SnakeToCamelCaseNested<U[K]>;\n        }[]\n      : T\n    : {\n        [K in keyof T as SnakeToCamelCase<K & string>]: SnakeToCamelCaseNested<\n          T[K]\n        >;\n      }\n  : T;\n\ntype CamelToSnakeCase<S extends string> = S extends `${infer T}${infer U}`\n  ? `${T extends Capitalize<T> ? \"_\" : \"\"}${Lowercase<T>}${CamelToSnakeCase<U>}`\n  : S;\n\nexport type CamelToSnakeCaseNested<T> = T extends object\n  ? T extends (infer U)[]\n    ? U extends object\n      ? {\n          [K in keyof U as CamelToSnakeCase<\n            K & string\n          >]: CamelToSnakeCaseNested<U[K]>;\n        }[]\n      : T\n    : {\n        [K in keyof T as CamelToSnakeCase<K & string>]: CamelToSnakeCaseNested<\n          T[K]\n        >;\n      }\n  : T;\n\nfunction camelToSnakeCase(str: string): string {\n  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);\n}\n\nexport function camelToSnakeCaseNested<T>(\n  obj: T,\n  parentKey?: string\n): CamelToSnakeCaseNested<T> {\n  if (Array.isArray(obj)) {\n    return obj.map((item) =>\n      camelToSnakeCaseNested(item, parentKey)\n    ) as CamelToSnakeCaseNested<T>;\n  } else if (typeof obj === \"object\" && obj !== null) {\n    const newObj: any = {};\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        const newKey = camelToSnakeCase(key);\n        // Keep arbitrary keys the same\n        if (\n          (parentKey === \"metadata\" &&\n            !Object.keys(reservedTraceMetadataSchema.shape).includes(newKey)) ||\n          (parentKey === \"params\" &&\n            !Object.keys(reservedSpanParamsSchema.shape).includes(newKey)) ||\n          (parentKey === \"input\" &&\n            [\"json\", \"raw\", \"list\"].includes(newObj.type) &&\n            newKey === \"value\") ||\n          (parentKey === \"output\" &&\n            [\"json\", \"raw\", \"list\"].includes(newObj.type) &&\n            newKey === \"value\") ||\n          (parentKey === \"contexts\" && newKey === \"content\")\n        ) {\n          newObj[key] = (obj as any)[key];\n        } else {\n          newObj[newKey] = camelToSnakeCaseNested((obj as any)[key], newKey);\n        }\n      }\n    }\n    return newObj as CamelToSnakeCaseNested<T>;\n  } else {\n    return obj as CamelToSnakeCaseNested<T>;\n  }\n}\n","/**\n * Converts an AsyncGenerator to a ReadableStream.\n *\n * @template T - The type of elements produced by the AsyncGenerator.\n * @param {AsyncGenerator<T>} stream - The AsyncGenerator to convert.\n * @returns {ReadableStream<T>} - A ReadableStream that provides the same data as the AsyncGenerator.\n */\nexport function convertAsyncGeneratorToReadableStream<T>(\n  stream: AsyncGenerator<T>,\n): ReadableStream<T> {\n  return new ReadableStream<T>({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      try {\n        const { value, done } = await stream.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    cancel() {},\n  });\n}\n","/**\nExtracts the headers from a response object and returns them as a key-value object.\n\n@param response - The response object to extract headers from.\n@returns The headers as a key-value object.\n*/\nexport function extractResponseHeaders(\n  response: Response,\n): Record<string, string> {\n  const headers: Record<string, string> = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n","import { customAlphabet } from 'nanoid/non-secure';\n\n/**\n * Generates a 7-character random string to use for IDs. Not secure.\n */\nexport const generateId = customAlphabet(\n  '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n  7,\n);\n","export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n","export function isAbortError(error: unknown): error is DOMException {\n  return (\n    error instanceof DOMException &&\n    (error.name === 'AbortError' || error.name === 'TimeoutError')\n  );\n}\n","import { LoadAPIKeyError } from '@ai-sdk/provider';\n\nexport function loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = 'apiKey',\n  description,\n}: {\n  apiKey: string | undefined;\n  environmentVariableName: string;\n  apiKeyParameterName?: string;\n  description: string;\n}): string {\n  if (typeof apiKey === 'string') {\n    return apiKey;\n  }\n\n  if (apiKey != null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`,\n    });\n  }\n\n  apiKey = process.env[environmentVariableName];\n\n  if (apiKey == null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof apiKey !== 'string') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return apiKey;\n}\n","import { LoadSettingError } from '@ai-sdk/provider';\n\nexport function loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n  settingName: string;\n  description: string;\n}): string {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null) {\n    throw new LoadSettingError({\n      message: `${description} setting must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter. Environment variables is not supported in this environment.`,\n    });\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null) {\n    throw new LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof settingValue !== 'string') {\n    throw new LoadSettingError({\n      message: `${description} setting must be a string. The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return settingValue;\n}\n","import { JSONParseError, TypeValidationError } from '@ai-sdk/provider';\nimport SecureJSON from 'secure-json-parse';\nimport { ZodSchema } from 'zod';\nimport { safeValidateTypes, validateTypes } from './validate-types';\n\n/**\n * Parses a JSON string into an unknown object.\n *\n * @param text - The JSON string to parse.\n * @returns {unknown} - The parsed JSON object.\n */\nexport function parseJSON({ text }: { text: string }): unknown;\n/**\n * Parses a JSON string into a strongly-typed object using the provided schema.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Schema<T>} schema - The schema to use for parsing the JSON.\n * @returns {T} - The parsed object.\n */\nexport function parseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema: ZodSchema<T>;\n}): T;\nexport function parseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T>;\n}): T {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return value;\n    }\n\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (\n      JSONParseError.isJSONParseError(error) ||\n      TypeValidationError.isTypeValidationError(error)\n    ) {\n      throw error;\n    }\n\n    throw new JSONParseError({ text, cause: error });\n  }\n}\n\nexport type ParseResult<T> =\n  | { success: true; value: T }\n  | { success: false; error: JSONParseError | TypeValidationError };\n\n/**\n * Safely parses a JSON string and returns the result as an object of type `unknown`.\n *\n * @param text - The JSON string to parse.\n * @returns {object} Either an object with `success: true` and the parsed data, or an object with `success: false` and the error that occurred.\n */\nexport function safeParseJSON({ text }: { text: string }): ParseResult<unknown>;\n/**\n * Safely parses a JSON string into a strongly-typed object, using a provided schema to validate the object.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Schema<T>} schema - The schema to use for parsing the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeParseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema: ZodSchema<T>;\n}): ParseResult<T>;\nexport function safeParseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T>;\n}):\n  | { success: true; value: T }\n  | { success: false; error: JSONParseError | TypeValidationError } {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return {\n        success: true,\n        value: value as T,\n      };\n    }\n\n    return safeValidateTypes({ value, schema });\n  } catch (error) {\n    return {\n      success: false,\n      error: JSONParseError.isJSONParseError(error)\n        ? error\n        : new JSONParseError({ text, cause: error }),\n    };\n  }\n}\n\nexport function isParseableJson(input: string): boolean {\n  try {\n    SecureJSON.parse(input);\n    return true;\n  } catch {\n    return false;\n  }\n}\n","import { TypeValidationError } from '@ai-sdk/provider';\nimport { ZodSchema } from 'zod';\n\n/**\n * Validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The object to validate.\n * @param {Schema<T>} options.schema - The schema to use for validating the JSON.\n * @returns {T} - The typed object.\n */\nexport function validateTypes<T>({\n  value,\n  schema,\n}: {\n  value: unknown;\n  schema: ZodSchema<T>;\n}): T {\n  try {\n    return schema.parse(value);\n  } catch (error) {\n    throw new TypeValidationError({ value, cause: error });\n  }\n}\n\n/**\n * Safely validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The JSON object to validate.\n * @param {Schema<T>} options.schema - The schema to use for validating the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeValidateTypes<T>({\n  value,\n  schema,\n}: {\n  value: unknown;\n  schema: ZodSchema<T>;\n}):\n  | { success: true; value: T }\n  | { success: false; error: TypeValidationError } {\n  try {\n    const validationResult = schema.safeParse(value);\n\n    if (validationResult.success) {\n      return {\n        success: true,\n        value: validationResult.data,\n      };\n    }\n\n    return {\n      success: false,\n      error: new TypeValidationError({\n        value,\n        cause: validationResult.error,\n      }),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: TypeValidationError.isTypeValidationError(error)\n        ? error\n        : new TypeValidationError({ value, cause: error }),\n    };\n  }\n}\n","import { APICallError } from '@ai-sdk/provider';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { isAbortError } from './is-abort-error';\nimport { ResponseHandler } from './response-handler';\n\nexport const postJsonToApi = async <T>({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: unknown;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n}) =>\n  postToApi({\n    url,\n    headers: {\n      ...headers,\n      'Content-Type': 'application/json',\n    },\n    body: {\n      content: JSON.stringify(body),\n      values: body,\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n  });\n\nexport const postToApi = async <T>({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: {\n    content: string | FormData | Uint8Array;\n    values: unknown;\n  };\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n}) => {\n  try {\n    // remove undefined headers:\n    const definedHeaders = Object.fromEntries(\n      Object.entries(headers).filter(([_key, value]) => value != null),\n    ) as Record<string, string>;\n\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: definedHeaders,\n      body: body.content,\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values,\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isAPICallError(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values,\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values,\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isAPICallError(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values,\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n\n    // unwrap original error when fetch failed (for easier debugging):\n    if (error instanceof TypeError && error.message === 'fetch failed') {\n      const cause = (error as any).cause;\n\n      if (cause != null) {\n        // Failed to connect to server:\n        throw new APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          requestBodyValues: body.values,\n          isRetryable: true, // retry when network error\n        });\n      }\n    }\n\n    throw error;\n  }\n};\n","import { APICallError, EmptyResponseBodyError } from '@ai-sdk/provider';\nimport {\n  EventSourceParserStream,\n  ParsedEvent,\n} from 'eventsource-parser/stream';\nimport { ZodSchema } from 'zod';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { ParseResult, parseJSON, safeParseJSON } from './parse-json';\n\nexport type ResponseHandler<RETURN_TYPE> = (options: {\n  url: string;\n  requestBodyValues: unknown;\n  response: Response;\n}) => PromiseLike<{\n  value: RETURN_TYPE;\n  responseHeaders?: Record<string, string>;\n}>;\n\nexport const createJsonErrorResponseHandler =\n  <T>({\n    errorSchema,\n    errorToMessage,\n    isRetryable,\n  }: {\n    errorSchema: ZodSchema<T>;\n    errorToMessage: (error: T) => string;\n    isRetryable?: (response: Response, error?: T) => boolean;\n  }): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n    const responseHeaders = extractResponseHeaders(response);\n\n    // Some providers return an empty response body for some errors:\n    if (responseBody.trim() === '') {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n\n    // resilient parsing in case the response is not JSON or does not match the schema:\n    try {\n      const parsedError = parseJSON({\n        text: responseBody,\n        schema: errorSchema,\n      });\n\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: errorToMessage(parsedError),\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          data: parsedError,\n          isRetryable: isRetryable?.(response, parsedError),\n        }),\n      };\n    } catch (parseError) {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n  };\n\nexport const createEventSourceResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    return {\n      responseHeaders,\n      value: response.body\n        .pipeThrough(new TextDecoderStream())\n        .pipeThrough(new EventSourceParserStream())\n        .pipeThrough(\n          new TransformStream<ParsedEvent, ParseResult<T>>({\n            transform({ data }, controller) {\n              // ignore the 'DONE' event that e.g. OpenAI sends:\n              if (data === '[DONE]') {\n                return;\n              }\n\n              controller.enqueue(\n                safeParseJSON({\n                  text: data,\n                  schema: chunkSchema,\n                }),\n              );\n            },\n          }),\n        ),\n    };\n  };\n\nexport const createJsonResponseHandler =\n  <T>(responseSchema: ZodSchema<T>): ResponseHandler<T> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n\n    const parsedResult = safeParseJSON({\n      text: responseBody,\n      schema: responseSchema,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!parsedResult.success) {\n      throw new APICallError({\n        message: 'Invalid JSON response',\n        cause: parsedResult.error,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        url,\n        requestBodyValues,\n      });\n    }\n\n    return {\n      responseHeaders,\n      value: parsedResult.value,\n    };\n  };\n","export function convertBase64ToUint8Array(base64String: string) {\n  const base64Url = base64String.replace(/-/g, '+').replace(/_/g, '/');\n  const latin1string = globalThis.atob(base64Url);\n  return Uint8Array.from(latin1string, byte => byte.codePointAt(0)!);\n}\n\nexport function convertUint8ArrayToBase64(array: Uint8Array): string {\n  let latin1string = '';\n\n  // Note: regular for loop to support older JavaScript versions that\n  // do not support for..of on Uint8Array\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n\n  return globalThis.btoa(latin1string);\n}\n","export function withoutTrailingSlash(url: string | undefined) {\n  return url?.replace(/\\/$/, '');\n}\n","import { convertUint8ArrayToBase64 } from \"@ai-sdk/provider-utils\";\nimport { type CoreMessage, type ImagePart } from \"ai\";\nimport { z } from \"zod\";\nimport { type ErrorCapture } from \"./server/types/tracer\";\nimport { chatMessageSchema } from \"./server/types/tracer.generated\";\nimport { type ChatMessage, type SpanInputOutput } from \"./types\";\n\nconst convertImageToUrl = (\n  image: ImagePart[\"image\"],\n  mimeType: string | undefined\n) => {\n  try {\n    return image instanceof URL\n      ? image.toString()\n      : typeof image === \"string\"\n      ? image\n      : `data:${mimeType ?? \"image/jpeg\"};base64,${convertUint8ArrayToBase64(\n          image as any\n        )}`;\n  } catch (e) {\n    console.error(\"[LangWatch] error converting vercel ui image to url:\", e);\n    return \"\";\n  }\n};\n\n// Mostly copied from https://github.com/vercel/ai/blob/main/packages/openai/src/convert-to-openai-chat-messages.ts\nexport function convertFromVercelAIMessages(\n  messages: CoreMessage[]\n): ChatMessage[] {\n  const lwMessages: ChatMessage[] = [];\n\n  for (const { role, content } of messages) {\n    switch (role) {\n      case \"system\": {\n        lwMessages.push({ role: \"system\", content });\n        break;\n      }\n\n      case \"user\": {\n        if (\n          Array.isArray(content) &&\n          content.length === 1 &&\n          content[0]?.type === \"text\"\n        ) {\n          lwMessages.push({ role: \"user\", content: content[0].text });\n          break;\n        }\n\n        lwMessages.push({\n          role: \"user\",\n          content: Array.isArray(content)\n            ? content.map((part) => {\n                switch (part.type) {\n                  case \"text\": {\n                    return { type: \"text\", text: part.text };\n                  }\n                  case \"image\": {\n                    return {\n                      type: \"image_url\",\n                      image_url: {\n                        url: convertImageToUrl(part.image, part.mimeType),\n                      },\n                    };\n                  }\n                }\n              })\n            : content,\n        });\n\n        break;\n      }\n\n      case \"assistant\": {\n        let text = \"\";\n        const toolCalls: Array<{\n          id: string;\n          type: \"function\";\n          function: { name: string; arguments: string };\n        }> = [];\n\n        if (Array.isArray(content)) {\n          for (const part of content) {\n            switch (part.type) {\n              case \"text\": {\n                text += part.text;\n                break;\n              }\n              case \"tool-call\": {\n                toolCalls.push({\n                  id: part.toolCallId,\n                  type: \"function\",\n                  function: {\n                    name: part.toolName,\n                    arguments: JSON.stringify(part.args),\n                  },\n                });\n                break;\n              }\n              default: {\n                const _exhaustiveCheck = part;\n                throw new Error(`Unsupported part: ${_exhaustiveCheck as any}`);\n              }\n            }\n          }\n        } else {\n          text = content;\n        }\n\n        lwMessages.push({\n          role: \"assistant\",\n          content: text,\n          tool_calls: toolCalls.length > 0 ? toolCalls : undefined,\n        });\n\n        break;\n      }\n\n      case \"tool\": {\n        for (const toolResponse of content) {\n          lwMessages.push({\n            role: \"tool\",\n            tool_call_id: toolResponse.toolCallId,\n            content: JSON.stringify(toolResponse.result),\n          });\n        }\n        break;\n      }\n\n      default: {\n        const _exhaustiveCheck = role;\n        throw new Error(`Unsupported role: ${_exhaustiveCheck as any}`);\n      }\n    }\n  }\n\n  return lwMessages;\n}\n\nexport const captureError = (error: unknown): ErrorCapture => {\n  if (\n    error &&\n    typeof error === \"object\" &&\n    \"has_error\" in error &&\n    \"message\" in error &&\n    \"stacktrace\" in error\n  ) {\n    return error as ErrorCapture;\n  } else if (error instanceof Error) {\n    return {\n      has_error: true,\n      message: error.message,\n      stacktrace: error.stack ? error.stack.split(\"\\n\") : [],\n    };\n  } else if (typeof error === \"object\" && error !== null) {\n    const err = error as { message: unknown; stack: unknown };\n    const message =\n      typeof err.message === \"string\"\n        ? err.message\n        : \"An unknown error occurred\";\n    const stacktrace =\n      typeof err.stack === \"string\"\n        ? err.stack.split(\"\\n\")\n        : Array.isArray(err.stack) &&\n          err.stack.length > 0 &&\n          typeof err.stack[0] === \"string\"\n        ? err.stack\n        : [\"No stack trace available\"];\n    return {\n      has_error: true,\n      message,\n      stacktrace,\n    };\n  } else {\n    // Handle primitives and other types that are not an error object\n    return {\n      has_error: true,\n      message: String(error),\n      stacktrace: [],\n    };\n  }\n};\n\nexport const autoconvertTypedValues = (value: unknown): SpanInputOutput => {\n  if (typeof value === \"string\") {\n    return { type: \"text\", value };\n  }\n\n  const chatMessages = z.array(chatMessageSchema).safeParse(value);\n  if (Array.isArray(value) && chatMessages.success) {\n    return {\n      type: \"chat_messages\",\n      value: chatMessages.data,\n    };\n  }\n\n  try {\n    JSON.stringify(value);\n    return { type: \"json\", value: value as object };\n  } catch (e) {\n    return { type: \"raw\", value: value as any };\n  }\n};\n","import {\n  type ReadableSpan,\n  type SpanExporter,\n} from \"@opentelemetry/sdk-trace-base\";\nimport { createExportTraceServiceRequest } from \"@opentelemetry/otlp-transformer\";\n\nimport { type ExportResult, ExportResultCode } from \"@opentelemetry/core\";\n\nexport class LangWatchExporter implements SpanExporter {\n  private endpoint: string;\n  private apiKey: string;\n  private includeAllSpans: boolean;\n  private debug: boolean;\n\n  constructor(\n    params: {\n      endpoint?: string;\n      apiKey?: string;\n      includeAllSpans?: boolean;\n      debug?: boolean;\n    } = {}\n  ) {\n    this.endpoint =\n      params.endpoint ??\n      process.env.LANGWATCH_ENDPOINT ??\n      \"https://app.langwatch.ai\";\n    this.apiKey = params.apiKey ?? process.env.LANGWATCH_API_KEY ?? \"\";\n    this.includeAllSpans = params.includeAllSpans ?? false;\n    this.debug = params.debug ?? false;\n\n    if (!this.apiKey) {\n      throw new Error(\"LANGWATCH_API_KEY is not set\");\n    }\n  }\n\n  export(\n    allSpans: ReadableSpan[],\n    resultCallback: (result: ExportResult) => void\n  ): void {\n    const spans = allSpans.filter(\n      (span) => this.includeAllSpans || this.isAiSdkSpan(span)\n    );\n    if (spans.length === 0) {\n      resultCallback({ code: ExportResultCode.SUCCESS });\n      return;\n    }\n    if (this.debug) {\n      console.log(\"[LangWatchExporter] Exporting spans:\", spans);\n    }\n\n    let body;\n    try {\n      body = JSON.stringify(createExportTraceServiceRequest(spans));\n    } catch (error) {\n      console.error(\"[LangWatchExporter] Failed to serialize spans:\", error);\n      resultCallback({ code: ExportResultCode.FAILED });\n      return;\n    }\n\n    fetch(`${this.endpoint}/api/otel/v1/traces`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${this.apiKey}`,\n      },\n      body,\n    })\n      .then((response) => {\n        if (!response.ok) {\n          resultCallback({ code: ExportResultCode.FAILED });\n          return;\n        }\n        resultCallback({ code: ExportResultCode.SUCCESS });\n      })\n      .catch((error) => {\n        console.error(\"[LangWatchExporter] Failed to export spans:\", error);\n        resultCallback({\n          code: ExportResultCode.FAILED,\n          error: error instanceof Error ? error : new Error(\"Unknown error\"),\n        });\n      });\n  }\n\n  private isAiSdkSpan(span: ReadableSpan): boolean {\n    return span.instrumentationLibrary.name === \"ai\";\n  }\n\n  shutdown(): Promise<void> {\n    return Promise.resolve();\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface ExportResult {\n  code: ExportResultCode;\n  error?: Error;\n}\n\nexport enum ExportResultCode {\n  SUCCESS,\n  FAILED,\n}\n"],"mappings":"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","names":["exports","module","import_zod","content","import_zod","ExportResultCode","EventEmitter"]}