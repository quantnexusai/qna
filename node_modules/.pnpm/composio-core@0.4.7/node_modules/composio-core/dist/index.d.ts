import * as axios from 'axios';
import { z, ZodObject, ZodString, ZodOptional } from 'zod';
import { DynamicStructuredTool } from '@langchain/core/tools';
import { OpenAI } from 'openai';
import { Stream } from 'openai/streaming';
import { AiTextGenerationToolInput, AiTextGenerationOutput } from '@cloudflare/workers-types';

/**
 * Member information
 */
type MemberInfoResDTO = {
    id: string;
    projectId: string;
    email: string;
    name: string;
    role: string;
    metadata?: unknown;
    createdAt: string;
    updatedAt: string;
    deletedAt?: string;
};
type DeleteRowAPIDTO = {
    /**
     * Status of the delete operation
     */
    status: string;
    /**
     * Number of records deleted
     */
    count: number;
};
type SingleAppInfoResDTO = {
    /**
     * The unique identifier for the app
     */
    appId: string;
    /**
     * The key of the app
     */
    key: string;
    /**
     * The name of the app
     */
    name: string;
    /**
     * The description of the app
     */
    description: string;
    /**
     * The logo of the app
     */
    logo?: string;
    /**
     * The categories of the app
     */
    categories?: Array<string>;
    /**
     * The path of the app
     */
    path?: string;
    /**
     * The documentation URL of the app
     */
    docs?: string;
    /**
     * The configuration documentation text of the app
     */
    configuration_docs_text?: string;
    /**
     * The status of the app
     */
    status?: string;
    /**
     * The documentation text of the app
     */
    documentation_doc_text?: string;
    /**
     * The test connectors of the app
     */
    testConnectors?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Indicates if the app has no authentication
     */
    no_auth?: boolean;
    /**
     * The authentication schemes of the app
     */
    auth_schemes?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * The metadata of the app
     */
    meta?: unknown;
    /**
     * The yaml of the app
     */
    yaml?: unknown;
};
type AppInfoResponseDto = {
    /**
     * The ID of the app
     */
    appId: string;
    /**
     * The key of the app
     */
    key: string;
    /**
     * The name of the app
     */
    name: string;
    /**
     * The description of the app
     */
    description: string;
    /**
     * The logo of the app
     */
    logo: string;
    /**
     * The categories of the app
     */
    categories: string;
    /**
     * The tags of the app
     */
    tags?: string;
    /**
     * The authentication schemes of the app
     */
    auth_schemes?: unknown;
    /**
     * Indicates if the app is enabled
     */
    enabled: boolean;
    /**
     * Indicates if the app has no authentication
     */
    no_auth?: boolean;
};
type ExpectedInputFieldsDTO = {
    /**
     * Name of the field
     */
    name: string;
    /**
     * Type of the field
     */
    type: string;
    /**
     * Description of the field
     */
    description: string;
    /**
     * Display name of the field
     */
    display_name: string;
    /**
     * Default value of the field
     */
    default: {
        [key: string]: unknown;
    };
    /**
     * Whether the field is required
     */
    required: boolean;
    /**
     * Whether the field is expected from customer
     */
    expected_from_customer: boolean;
    /**
     * Whether the field is a secret
     */
    is_secret: boolean;
};
type GetConnectorInfoResDTO = {
    /**
     * Unique identifier of the connector
     */
    id?: string;
    /**
     * Authentication scheme used by the connector
     */
    authScheme?: string;
    /**
     * Name of the connector
     */
    name?: string;
    /**
     * Creation date of the connector
     */
    createdAt?: string;
    /**
     * Last update date of the connector
     */
    updatedAt?: string;
    /**
     * Flag to indicate if the connector is currently enabled
     */
    enabled: boolean;
    /**
     * Flag to indicate if the connector has been deleted
     */
    deleted?: boolean;
    /**
     * Application ID associated with the connector
     */
    appId: string;
    /**
     * Default connector ID if one exists
     */
    defaultConnectorId?: string;
    /**
     * Authentication configuration with sensitive data obscured
     */
    authConfig: {
        [key: string]: unknown;
    };
    /**
     * List of required fields expected from the customer
     */
    expectedInputFields: Array<ExpectedInputFieldsDTO>;
    /**
     * Logo URL of the application associated with the connector
     */
    logo: string;
    /**
     * Name of the application associated with the connector
     */
    appName: string;
    /**
     * Flag to indicate if Composio authentication is used
     */
    useComposioAuth: boolean;
};
type GetConnectorListResDTO = {
    items: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Total number of pages available
     */
    totalPages: number;
    /**
     * Current page number
     */
    page: number;
};
type ConnectionParams = {
    integrationId: string;
    connectionParams?: {
        [key: string]: unknown;
    };
    isDisabled: boolean;
    invocationCount: number;
    id: string;
    clientUniqueUserId?: string;
    status: string;
    data?: {
        [key: string]: unknown;
    };
    deleted?: boolean;
    enabled?: boolean;
    createdAt: string;
    updatedAt: string;
    appUniqueId: string;
    appName: string;
    logo?: string;
    authConfig?: {
        [key: string]: unknown;
    };
    member: {
        [key: string]: unknown;
    };
    labels?: Array<string>;
};
type Meta = {
    app: {
        [key: string]: unknown;
    };
};
type ConnectedAccountResponseDTO = {
    integrationId: string;
    appUniqueId: string;
    memberInfo?: MemberInfoResDTO;
    meta?: Meta;
    isDisabled?: boolean;
    id: string;
    clientUniqueUserId: string;
    appName: string;
    entityId: string;
    status: string;
    enabled?: boolean;
    createdAt: string;
    updatedAt: string;
};
type GetConnectionsResponseDto = {
    items: Array<ConnectionParams>;
    totalPages: number;
    page: number;
};
type GetConnectionInfoResponseDTO = {
    base_url: string;
    parameters: Array<Parameter$1>;
    body: {
        [key: string]: unknown;
    };
};
type Parameter$1 = {
    /**
     * The name of the parameter. For example, 'x-api-key', 'Content-Type', etc.,
     */
    name: string;
    /**
     * The location of the parameter. Can be 'query' or 'header'.
     */
    in: "query" | "header";
    /**
     * The value of the parameter. For example, '1234567890', 'application/json', etc.,
     */
    value: string;
};
type InitiateConnectionPayloadDto = {
    data: {
        [key: string]: unknown;
    };
    integrationId: string;
    redirectUri?: string;
    userUuid?: string;
    entityId?: string;
    labels?: Array<string>;
};
type InitiateConnectionResponse = {
    connectionStatus: string;
    connectedAccountId: string;
    redirectUrl?: string;
};
type ActionExecutionResDto = {
    data: {
        [key: string]: unknown;
    };
    error?: string;
    successfull?: string;
};
type ActionProxyRequestConfigDTO = {
    /**
     * The connected account uuid to use for the action.
     */
    connectedAccountId: string;
    /**
     * The endpoint to call for the action. If the given url is relative, it will be resolved relative to the base_url set in the connected account info.
     */
    endpoint: string;
    /**
     * The HTTP method to use for the action.
     */
    method: "GET" | "POST" | "PUT" | "PATCH" | "DELETE";
    parameters: Array<Parameter$1>;
    /**
     * The body to be sent to the endpoint. This can either be a JSON field or a string.
     */
    body?: {
        [key: string]: unknown;
    };
};
type ActionDetails = {
    parameters: {
        [key: string]: unknown;
    };
    response: {
        [key: string]: unknown;
    };
    appId?: string;
    appKey: string;
    appName: string;
    description: string;
    displayName: string;
    enabled: boolean;
    logo: string;
    name: string;
    tags: Array<string>;
    deprecated: boolean;
};
type ActionsListResponseDTO = {
    items: Array<ActionDetails>;
    page: number;
    totalPages: number;
};
type TriggerResDTO = {
    /**
     * Trigger name
     */
    name: string;
    /**
     * Trigger display name
     */
    display_name: string;
    /**
     * Trigger description
     */
    description?: string;
    /**
     * Is trigger enabled
     */
    enabled?: boolean;
    /**
     * Trigger configuration
     */
    config?: {
        [key: string]: unknown;
    };
    /**
     * Trigger payload
     */
    payload?: {
        [key: string]: unknown;
    };
    /**
     * Trigger logo URL
     */
    logo?: string;
    /**
     * Trigger count
     */
    count?: number;
    /**
     * App key
     */
    appKey: string;
    /**
     * App ID
     */
    appId: string;
    /**
     * App name
     */
    appName: string;
    /**
     * Trigger instructions
     */
    instructions?: string;
    /**
     * Trigger type
     */
    type?: string;
};
type DeleteConnectorData = {
    path: {
        integrationId: string;
    };
};
type GetConnectionsData = {
    query?: {
        appNames?: string;
        connectionId?: string;
        integrationId?: string;
        labels?: Array<string>;
        page?: number;
        pageSize?: number;
        showActiveOnly?: boolean;
        showDisabled?: boolean;
        status?: string;
        user_uuid?: string;
    };
};
type GetConnectionInfoData = {
    path: {
        connectedAccountId: string;
    };
};
type GetConnectionInfoResponse = GetConnectionInfoResponseDTO;
type ListTriggersData = {
    query?: {
        appNames?: string;
        connectedAccountIds?: string;
        integrationIds?: string;
        showEnabledOnly?: boolean;
        triggerIds?: string;
    };
};
type ListTriggersResponse = Array<TriggerResDTO>;
type GetActiveTriggersData = {
    query?: {
        connectedAccountIds?: string;
        integrationIds?: string;
        limit?: number;
        page?: number;
        showDisabled?: boolean;
        triggerIds?: string;
        triggerNames?: string;
    };
};

/**
 * Class representing the details required to initialize and configure the API client.
 */
declare class BackendClient {
    /**
     * The API key used for authenticating requests.
     */
    apiKey: string;
    /**
     * The base URL of the API against which requests will be made.
     */
    baseUrl: string;
    /**
     * The runtime environment where the client is being used.
     */
    runtime: string;
    /**
     * Creates an instance of apiClientDetails.
     * @param {string} apiKey - The API key for client initialization.
     * @param {string} baseUrl - The base URL for the API client.
     * @param {string} runtime - The runtime environment identifier.
     * @throws Will throw an error if the API key is not provided.
     */
    constructor(apiKey: string, baseUrl: string, runtime?: string);
    /**
     * Retrieves the client ID from the user's information.
     * @returns {Promise<string>} A promise that resolves to the client ID.
     * @throws Will throw an error if the HTTP request fails.
     */
    getClientId(): Promise<string>;
    /**
     * Initializes the API client with the provided configuration.
     * @private
     */
    private initializeApiClient;
}

type ListAllIntegrationsData = {
    /**
     * Page number to fetch
     */
    page?: number;
    /**
     * Page Size to assume
     */
    pageSize?: number;
    /**
     * The name of the app to filter by
     */
    appName?: string;
    /**
     * Whether to show disabled integrations
     */
    showDisabled?: boolean;
};
type GetIntegrationData = {
    /**
     * The unique identifier of the integration.
     */
    integrationId: string;
};
type CreateIntegrationData = {
    requestBody?: {
        /**
         * The name of the connector.
         */
        name?: string;
        /**
         * The authentication scheme used by the connector (e.g., "OAUTH2", "API_KEY").
         */
        authScheme?: string;
        /**
         * The unique identifier of the app associated with the connector.
         */
        appId?: string;
        forceNewIntegration?: boolean;
        /**
         * An object containing the authentication configuration for the connector.
         */
        authConfig?: {
            /**
             * The client ID used for authentication with the app - if authScheme is OAUTH2
             */
            client_id?: string;
            /**
             * The client secret used for authentication with the app - if authScheme is OAUTH2
             */
            client_secret?: string;
            /**
             * The API key used for authentication with the app - if authScheme is API_KEY
             */
            api_key?: string;
            /**
             * The Consumer key used for authentication with the app - if authScheme is OAUTH1
             */
            consumer_key?: string;
            /**
             * The Consumer secret used for authentication with the app - if authScheme is OAUTH1
             */
            consumer_secret?: string;
            /**
             *  The base URL for making API requests to the app.
             */
            base_url?: string;
            [key: string]: unknown;
        };
        /**
         * Use default Composio credentials to proceed. The developer app credentials will be of Composio.
         */
        useComposioAuth?: boolean;
    };
};
declare class Integrations {
    backendClient: BackendClient;
    fileName: string;
    constructor(backendClient: BackendClient);
    /**
     * Retrieves a list of all available integrations in the Composio platform.
     *
     * This method allows clients to explore and discover the supported integrations. It returns an array of integration objects, each containing essential details such as the integration's key, name, description, logo, categories, and unique identifier.
     *
     * @returns {Promise<ListAllIntegrationsResponse>} A promise that resolves to the list of all integrations.
     * @throws {ApiError} If the request fails.
     */
    list(data?: ListAllIntegrationsData): Promise<GetConnectorListResDTO | undefined>;
    /**
     * Retrieves details of a specific integration in the Composio platform by providing its integration name.
     *
     * The response includes the integration's name, display name, description, input parameters, expected response, associated app information, and enabled status.
     *
     * @param {GetIntegrationData} data The data for the request.
     * @returns {Promise<AppConnectorControllerGetConnectorInfoResponse | undefined>} A promise that resolves to the details of the integration.
     * @throws {ApiError} If the request fails.
     */
    get(data: GetIntegrationData): Promise<GetConnectorInfoResDTO | undefined>;
    getRequiredParams(integrationId: string): Promise<ExpectedInputFieldsDTO[]>;
    /**
     * Creates a new integration in the Composio platform.
     *
     * This method allows clients to create a new integration by providing the necessary details such as app ID, name, authentication mode, and configuration.
     *
     * @param {CreateIntegrationData["requestBody"]} data The data for the request.
     * @returns {Promise<CreateIntegrationResponse>} A promise that resolves to the created integration model.
     * @throws {ApiError} If the request fails.
     */
    create(data: CreateIntegrationData["requestBody"]): Promise<GetConnectorInfoResDTO>;
    delete(data: DeleteConnectorData): Promise<DeleteRowAPIDTO | undefined>;
}

type GetAppData = {
    appKey: string;
};
type RequiredParamsResponse = {
    required_fields: string[];
    expected_from_user: string[];
    optional_fields: string[];
};
type RequiredParamsFullResponse = {
    availableAuthSchemes: string[];
    authSchemes: Record<string, RequiredParamsResponse>;
};
declare class Apps {
    backendClient: BackendClient;
    fileName: string;
    constructor(backendClient: BackendClient);
    /**
     * Retrieves a list of all available apps in the Composio platform.
     *
     * This method allows clients to explore and discover the supported apps. It returns an array of app objects, each containing essential details such as the app's key, name, description, logo, categories, and unique identifier.
     *
     * @returns {Promise<AppListResDTO>} A promise that resolves to the list of all apps.
     * @throws {ApiError} If the request fails.
     */
    list(): Promise<AppInfoResponseDto[]>;
    /**
     * Retrieves details of a specific app in the Composio platform.
     *
     * This method allows clients to fetch detailed information about a specific app by providing its unique key. The response includes the app's name, key, status, description, logo, categories, authentication schemes, and other metadata.
     *
     * @param {GetAppData} data The data for the request, including the app's unique key.
     * @returns {CancelablePromise<GetAppResponse>} A promise that resolves to the details of the app.
     * @throws {ApiError} If the request fails.
     */
    get(data: GetAppData): Promise<SingleAppInfoResDTO>;
    getRequiredParams(appId: string): Promise<RequiredParamsFullResponse>;
    getRequiredParamsForAuthScheme({ appId, authScheme, }: {
        appId: string;
        authScheme: string;
    }): Promise<RequiredParamsResponse>;
}

type ConnectedAccountsListData = GetConnectionsData["query"] & {
    appNames?: string;
};
type InitiateConnectionDataReq = InitiateConnectionPayloadDto & {
    data?: Record<string, unknown> | unknown;
    entityId?: string;
    labels?: string[];
    integrationId?: string;
    redirectUri?: string;
    authMode?: string;
    authConfig?: {
        [key: string]: any;
    };
    appName?: string;
};
declare class ConnectedAccounts {
    backendClient: BackendClient;
    integrations: Integrations;
    apps: Apps;
    fileName: string;
    constructor(backendClient: BackendClient);
    list(data: ConnectedAccountsListData): Promise<GetConnectionsResponseDto>;
    create(data: InitiateConnectionPayloadDto): Promise<ConnectionRequest>;
    get(data: {
        connectedAccountId: string;
    }): Promise<ConnectedAccountResponseDTO | undefined>;
    delete(data: {
        connectedAccountId: string;
    }): Promise<DeleteRowAPIDTO | undefined>;
    getAuthParams(data: {
        connectedAccountId: string;
    }): Promise<ConnectedAccountResponseDTO | undefined>;
    initiate(payload: InitiateConnectionDataReq): Promise<ConnectionRequest>;
}
declare class ConnectionRequest {
    connectionStatus: string;
    connectedAccountId: string;
    redirectUrl: string | null;
    constructor({ connectionStatus, connectedAccountId, redirectUri, }: {
        connectionStatus: string;
        connectedAccountId: string;
        redirectUri: string | null;
    });
    saveUserAccessData(data: {
        fieldInputs: Record<string, string>;
        redirectUrl?: string;
        entityId?: string;
    }): Promise<(axios.AxiosError<unknown, any> & {
        data: undefined;
        error: unknown;
    }) | (axios.AxiosResponse<InitiateConnectionResponse, any> & {
        error: undefined;
    })>;
    getAuthInfo(data: GetConnectionInfoData["path"]): Promise<GetConnectionInfoResponse>;
    waitUntilActive(timeout?: number): Promise<ConnectedAccountResponseDTO>;
}

/**
 * The `Actions` class provides methods to interact with the Composio platform's actions.
 * It allows fetching details of specific actions, listing all actions, and executing actions.
 *
 * - `get` method retrieves details of a specific action.
 * - `list` method retrieves a list of all actions.
 * - `execute` method executes a specific action.
 *
 * Each method returns a `CancelablePromise` which can be canceled. If canceled, the promise
 * will reject with a `Cancellation` object.
 *
 * @typeParam Composio The client configuration object type.
 * @groupDescription Methods
 * The methods in this class are grouped under 'Actions Methods' and provide functionalities
 * to interact with actions in the Composio platform. This includes fetching, listing, and
 * executing actions.
 */
type GetListActionsData = {
    /**
     * Name of the apps like "github", "linear" separated by a comma
     */
    apps?: string;
    /**
     * Filter by Action names
     */
    actions?: string;
    /**
     * Filter by Action tags
     */
    tags?: string;
    /**
     * Filter by use case
     */
    useCase?: string | undefined;
    /**
     * Limit of use-cases based search
     */
    usecaseLimit?: number;
    /**
     * Show all actions - i.e disable pagination
     */
    showAll?: boolean;
    /**
     * Show actions enabled for the API Key
     */
    showEnabledOnly?: boolean;
    /**
     * Use smart tag filtering
     */
    filterImportantActions?: boolean;
    /**
     * Should search in available apps only
     */
    filterByAvailableApps?: boolean;
};
type Parameter = {
    /**
     * The name of the parameter.
     */
    name: string;
    /**
     * The location of the parameter (e.g., query, header).
     */
    in: string;
    /**
     * The value of the parameter.
     */
    value: string | number;
};
type CustomAuthData = {
    /**
     * The base URL for the custom authentication.
     */
    base_url?: string;
    /**
     * An array of parameters for the custom authentication.
     */
    parameters: Parameter[];
    /**
     * An optional object containing the body for the custom authentication.
     */
    body?: Record<string, unknown>;
};
type ExecuteActionData = {
    /**
     * The name of the action to execute.
     */
    actionName: string;
    requestBody?: {
        /**
         * The unique identifier of the connection to use for executing the action.
         */
        connectedAccountId?: string;
        /**
         * An object containing the input parameters for the action. If you want to execute
         * NLP based action (i.e text), you can use text parameter instead of input.
         */
        input?: {
            [key: string]: unknown;
        };
        appName?: string;
        /**
         * The text to supply to the action which will be automatically converted to
         * appropriate input parameters.
         */
        text?: string;
        /**
         * The custom authentication configuration for executing the action.
         */
        authConfig?: CustomAuthData;
    };
};
declare class Actions {
    backendClient: BackendClient;
    fileName: string;
    constructor(backendClient: BackendClient);
    /**
     * Retrieves details of a specific action in the Composio platform by providing its action name.
     *
     * The response includes the action's name, display name, description, input parameters, expected response, associated app information, and enabled status.
     *
     * @param {GetActionData} data The data for the request.
     * @returns {CancelablePromise<GetActionResponse[0]>} A promise that resolves to the details of the action.
     * @throws {ApiError} If the request fails.
     */
    get(data: {
        actionName: string;
    }): Promise<ActionDetails>;
    /**
     * Retrieves a list of all actions in the Composio platform.
     *
     * This method allows you to fetch a list of all the available actions. It supports pagination to handle large numbers of actions. The response includes an array of action objects, each containing information such as the action's name, display name, description, input parameters, expected response, associated app information, and enabled status.
     *
     * @param {GetListActionsData} data The data for the request.
     * @returns {Promise<ActionsListResponseDTO>} A promise that resolves to the list of all actions.
     * @throws {ApiError} If the request fails.
     */
    list(data?: GetListActionsData): Promise<ActionsListResponseDTO>;
    /**
     * Executes a specific action in the Composio platform.
     *
     * This method allows you to trigger the execution of an action by providing its name and the necessary input parameters. The request includes the connected account ID to identify the app connection to use for the action, and the input parameters required by the action. The response provides details about the execution status and the response data returned by the action.
     *
     * @param {ExecuteActionData} data The data for the request.
     * @returns {Promise<ActionExecutionResDto>} A promise that resolves to the execution status and response data.
     * @throws {ApiError} If the request fails.
     */
    execute(data: ExecuteActionData): Promise<ActionExecutionResDto>;
    findActionEnumsByUseCase(data: {
        apps: Array<string>;
        useCase: string;
        limit?: number;
        filterByAvailableApps?: boolean;
    }): Promise<Array<string>>;
    /**
     * Executes a action using Composio Proxy
     *
     * This method allows you to trigger the execution of an action by providing its name and the necessary input parameters. The request includes the connected account ID to identify the app connection to use for the action, and the input parameters required by the action. The response provides details about the execution status and the response data returned by the action.
     *
     * @param {ExecuteActionData} data The data for the request.
     * @returns {Promise<ActionExecutionResDto>} A promise that resolves to the execution status and response data.
     * @throws {ApiError} If the request fails.
     */
    executeRequest(data: ActionProxyRequestConfigDTO): Promise<ActionExecutionResDto>;
}

interface TriggerData {
    appName: string;
    clientId: number;
    payload: {};
    originalPayload: Record<string, any>;
    metadata: {
        id: string;
        connectionId: string;
        triggerName: string;
        triggerData: string;
        triggerConfig: Record<string, any>;
        connection: {
            id: string;
            integrationId: string;
            clientUniqueUserId: string;
            status: string;
        };
    };
}

type RequiredQuery = ListTriggersData["query"];
declare class Triggers {
    trigger_to_client_event: string;
    backendClient: BackendClient;
    fileName: string;
    constructor(backendClient: BackendClient);
    /**
     * Retrieves a list of all triggers in the Composio platform.
     *
     * This method allows you to fetch a list of all the available triggers. It supports pagination to handle large numbers of triggers. The response includes an array of trigger objects, each containing information such as the trigger's name, description, input parameters, expected response, associated app information, and enabled status.
     *
     * @param {ListTriggersData} data The data for the request.
     * @returns {CancelablePromise<ListTriggersResponse>} A promise that resolves to the list of all triggers.
     * @throws {ApiError} If the request fails.
     */
    list(data?: RequiredQuery): Promise<ListTriggersResponse>;
    /**
     * Setup a trigger for a connected account.
     *
     * @param {SetupTriggerData} data The data for the request.
     * @returns {CancelablePromise<SetupTriggerResponse>} A promise that resolves to the setup trigger response.
     * @throws {ApiError} If the request fails.
     */
    setup({ connectedAccountId, triggerName, config, }: {
        connectedAccountId: string;
        triggerName: string;
        config: Record<string, any>;
    }): Promise<{
        status: string;
        triggerId: string;
    }>;
    enable(data: {
        triggerId: string;
    }): Promise<{
        status: string;
    }>;
    disable(data: {
        triggerId: string;
    }): Promise<{
        status: string;
    }>;
    delete(data: {
        triggerInstanceId: string;
    }): Promise<{
        status: string;
    }>;
    subscribe(fn: (data: TriggerData) => void, filters?: {
        appName?: string;
        triggerId?: string;
        connectionId?: string;
        integrationId?: string;
        triggerName?: string;
        triggerData?: string;
        entityId?: string;
    }): Promise<void>;
    unsubscribe(): Promise<void>;
}

declare class ActiveTriggers {
    backendClient: BackendClient;
    fileName: string;
    constructor(backendClient: BackendClient);
    /**
     * Retrieves details of a specific active trigger in the Composio platform by providing its trigger name.
     *
     * The response includes the trigger's name, description, input parameters, expected response, associated app information, and enabled status.
     *
     * @param {GetActiveTriggerData} data The data for the request.
     * @returns {CancelablePromise<GetActiveTriggerResponse>} A promise that resolves to the details of the active trigger.
     * @throws {ApiError} If the request fails.
     */
    get({ triggerId }: {
        triggerId: string;
    }): Promise<{
        [key: string]: unknown;
    } | undefined>;
    /**
     * Retrieves a list of all active triggers in the Composio platform.
     *
     * This method allows you to fetch a list of all the available active triggers. It supports pagination to handle large numbers of triggers. The response includes an array of trigger objects, each containing information such as the trigger's name, description, input parameters, expected response, associated app information, and enabled status.
     *
     * @param {ListActiveTriggersData} data The data for the request.
     * @returns {CancelablePromise<ListActiveTriggersResponse>} A promise that resolves to the list of all active triggers.
     * @throws {ApiError} If the request fails.
     */
    list(data?: GetActiveTriggersData): Promise<{
        [key: string]: unknown;
    }[]>;
    /**
     * Enables the previously disabled trigger.
     *
     * @param {Object} data The data for the request.
     * @param {string} data.triggerId Id of the trigger
     * @returns {CancelablePromise<Record<string, any>>} A promise that resolves to the response of the enable request.
     * @throws {ApiError} If the request fails.
     */
    enable(data: {
        triggerId: string;
    }): Promise<boolean>;
    disable(data: {
        triggerId: string;
    }): Promise<boolean>;
}

declare const ZExecuteActionParams$1: z.ZodObject<{
    actionName: z.ZodString;
    params: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
    text: z.ZodOptional<z.ZodString>;
    connectedAccountId: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    actionName: string;
    connectedAccountId?: string | undefined;
    text?: string | undefined;
    params?: Record<string, any> | undefined;
}, {
    actionName: string;
    connectedAccountId?: string | undefined;
    text?: string | undefined;
    params?: Record<string, any> | undefined;
}>;
type TExecuteActionParams = z.infer<typeof ZExecuteActionParams$1>;
declare const ZInitiateConnectionParams: z.ZodObject<{
    appName: z.ZodString;
    authConfig: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
    integrationId: z.ZodOptional<z.ZodString>;
    authMode: z.ZodOptional<z.ZodString>;
    connectionData: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
    config: z.ZodOptional<z.ZodObject<{
        labels: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        redirectUrl: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        labels?: string[] | undefined;
        redirectUrl?: string | undefined;
    }, {
        labels?: string[] | undefined;
        redirectUrl?: string | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    appName: string;
    authConfig?: Record<string, any> | undefined;
    integrationId?: string | undefined;
    config?: {
        labels?: string[] | undefined;
        redirectUrl?: string | undefined;
    } | undefined;
    authMode?: string | undefined;
    connectionData?: Record<string, any> | undefined;
}, {
    appName: string;
    authConfig?: Record<string, any> | undefined;
    integrationId?: string | undefined;
    config?: {
        labels?: string[] | undefined;
        redirectUrl?: string | undefined;
    } | undefined;
    authMode?: string | undefined;
    connectionData?: Record<string, any> | undefined;
}>;
type TInitiateConnectionParams = z.infer<typeof ZInitiateConnectionParams>;
declare class Entity {
    id: string;
    backendClient: BackendClient;
    triggerModel: Triggers;
    actionsModel: Actions;
    apps: Apps;
    connectedAccounts: ConnectedAccounts;
    integrations: Integrations;
    activeTriggers: ActiveTriggers;
    fileName: string;
    constructor(backendClient: BackendClient, id?: string);
    execute({ actionName, params, text, connectedAccountId, }: TExecuteActionParams): Promise<ActionExecutionResDto>;
    getConnection({ app, connectedAccountId, }: {
        app?: string;
        connectedAccountId?: string;
    }): Promise<any | null>;
    setupTrigger(app: string, triggerName: string, config: {
        [key: string]: any;
    }): Promise<{
        status: string;
        triggerId: string;
    }>;
    disableTrigger(triggerId: string): Promise<{
        status: string;
    }>;
    getConnections(): Promise<ConnectionParams[]>;
    getActiveTriggers(): Promise<{
        [key: string]: unknown;
    }[]>;
    initiateConnection(data: TInitiateConnectionParams): Promise<ConnectionRequest>;
}

declare class Composio {
    /**
     * The Composio class serves as the main entry point for interacting with the Composio SDK.
     * It provides access to various models that allow for operations on connected accounts, apps,
     * actions, triggers, integrations, and active triggers.
     */
    backendClient: BackendClient;
    connectedAccounts: ConnectedAccounts;
    apps: Apps;
    actions: Actions;
    triggers: Triggers;
    integrations: Integrations;
    activeTriggers: ActiveTriggers;
    fileName: string;
    /**
     * Initializes a new instance of the Composio class.
     *
     * @param {Object} config - Configuration object for the Composio SDK
     * @param {string} [config.apiKey] - The API key for authenticating with the Composio backend. Can also be set locally in an environment variable.
     * @param {string} [config.baseUrl] - The base URL for the Composio backend. By default, it is set to the production URL.
     * @param {string} [config.runtime] - The runtime environment for the SDK.
     */
    constructor(config: {
        apiKey?: string;
        baseUrl?: string;
        runtime?: string;
    });
    /**
     * Checks for the latest version of the Composio SDK from NPM.
     * If a newer version is available, it logs a warning to the console.
     */
    checkForLatestVersionFromNPM(): Promise<void>;
    /**
     * Retrieves an Entity instance associated with a given ID.
     *
     * @param {string} [id='default'] - The ID of the entity to retrieve.
     * @returns {Entity} An instance of the Entity class.
     */
    getEntity(id?: string): Entity;
    getExpectedParamsForUser(params?: {
        app?: string;
        integrationId?: string;
        entityId?: string;
        authScheme?: "OAUTH2" | "OAUTH1" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "BASIC_WITH_JWT";
    }): Promise<{
        expectedInputFields: GetConnectorInfoResDTO["expectedInputFields"];
        integrationId: string;
        authScheme: "OAUTH2" | "OAUTH1" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "BASIC_WITH_JWT";
    }>;
}

type Optional$3<T> = T | null;
type Sequence$2<T> = Array<T>;

type IPythonActionDetails = {
  data: {
    name: string;
    display_name: string;
    description: string;
    parameters: any;
    response: any;
    appKey: string;
    appId: string;
    tags: string[];
    appName: string;
    enabled: boolean;
    logo: string;
  }[];
  error: any | null;
  traceback: any | null;
};

interface IWorkspaceConfig {
    composioAPIKey?: string | null;
    composioBaseURL?: string | null;
    githubAccessToken?: string | null;
    environment?: {
        [key: string]: string;
    };
}
declare class WorkspaceConfig<TConfig extends IWorkspaceConfig = IWorkspaceConfig> {
    env: ExecEnv;
    config: TConfig;
    constructor(env: ExecEnv, config: TConfig);
}

declare class Shell {
    private _id;
    constructor();
    sanitizeCommand(cmd: string): string;
    toString(): string;
    get id(): string;
    setup(): void;
    exec(cmd: string): void;
    stop(): void;
}
declare class ShellFactory {
    private _factory;
    private _recent;
    private _shells;
    constructor(factory: () => Shell);
    get recent(): Shell;
    set recent(shell: Shell);
    new(): Shell;
    get(id?: string | null): Shell;
    exec(cmd: string, id?: string | null): void;
    stop(id: string): void;
    teardown(): void;
}
interface IExecuteActionMetadata {
    entityId?: string | null;
}
declare class Workspace$1 {
    id: string;
    accessToken: string;
    composioAPIKey: string;
    composioBaseURL: string;
    githubAccessToken: string;
    environment: {
        [key: string]: string;
    };
    private _shell_factory;
    constructor(configRepo: WorkspaceConfig<IWorkspaceConfig>);
    toString(): string;
    setup(): void;
    get shells(): ShellFactory;
    _createShell(): Shell;
    executeAction(action: any, request_data: any, metadata?: IExecuteActionMetadata): Promise<Record<string, any>>;
    teardown(): void;
}

declare enum ExecEnv {
    HOST = "HOST",
    DOCKER = "DOCKER",
    E2B = "E2B"
}
declare class WorkspaceFactory {
    workspace: Workspace$1 | null;
    id: string | null;
    env: ExecEnv;
    workspaceConfig: WorkspaceConfig;
    constructor(env: ExecEnv, kwargs: WorkspaceConfig);
    new(): Promise<void>;
    get(id?: string | null): Promise<Workspace$1>;
    close(): Promise<void>;
}

type ExecuteRequest = Omit<ActionProxyRequestConfigDTO, "connectedAccountId">;
interface CreateActionOptions {
    actionName?: string;
    toolName?: string;
    description?: string;
    inputParams: ZodObject<{
        [key: string]: ZodString | ZodOptional<ZodString>;
    }>;
    callback: (inputParams: Record<string, any>, authCredentials: Record<string, any> | undefined, executeRequest: (data: ExecuteRequest) => Promise<any>) => Promise<Record<string, any>>;
}
interface ExecuteMetadata {
    entityId?: string;
    connectionId?: string;
}
declare class ActionRegistry {
    client: Composio;
    customActions: Map<string, {
        metadata: CreateActionOptions;
        schema: any;
    }>;
    constructor(client: Composio);
    createAction(options: CreateActionOptions): Promise<Record<string, any>>;
    getActions({ actions, }: {
        actions: Array<string>;
    }): Promise<Array<any>>;
    getAllActions(): Promise<Array<any>>;
    executeAction(name: string, inputParams: Record<string, any>, metadata: ExecuteMetadata): Promise<any>;
}

type GetListActionsResponse = {
    items: any[];
};
declare const ZExecuteActionParams: z.ZodObject<{
    action: z.ZodString;
    params: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
    entityId: z.ZodString;
    nlaText: z.ZodOptional<z.ZodString>;
    connectedAccountId: z.ZodOptional<z.ZodString>;
    config: z.ZodOptional<z.ZodObject<{
        labels: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    }, "strip", z.ZodTypeAny, {
        labels?: string[] | undefined;
    }, {
        labels?: string[] | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    entityId: string;
    action: string;
    connectedAccountId?: string | undefined;
    config?: {
        labels?: string[] | undefined;
    } | undefined;
    params?: Record<string, any> | undefined;
    nlaText?: string | undefined;
}, {
    entityId: string;
    action: string;
    connectedAccountId?: string | undefined;
    config?: {
        labels?: string[] | undefined;
    } | undefined;
    params?: Record<string, any> | undefined;
    nlaText?: string | undefined;
}>;
type TPreProcessor = ({ action, toolRequest, }: {
    action: string;
    toolRequest: Record<string, unknown>;
}) => Record<string, unknown>;
type TPostProcessor = ({ action, toolResponse, }: {
    action: string;
    toolResponse: ActionExecutionResDto;
}) => ActionExecutionResDto;
declare class ComposioToolSet {
    client: Composio;
    apiKey: string;
    runtime: string | null;
    entityId: string;
    workspace: WorkspaceFactory;
    workspaceEnv: ExecEnv;
    localActions: IPythonActionDetails["data"] | undefined;
    customActionRegistry: ActionRegistry;
    private processors;
    constructor(apiKey: string | null, baseUrl?: string | null, runtime?: string | null, entityId?: string, workspaceConfig?: WorkspaceConfig);
    /**
     * @deprecated This method is deprecated. Please use this.client.getExpectedParamsForUser instead.
     */
    getExpectedParamsForUser(params?: {
        app?: string;
        integrationId?: string;
        entityId?: string;
        authScheme?: "OAUTH2" | "OAUTH1" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "BASIC_WITH_JWT";
    }): Promise<{
        expectedInputFields: ExpectedInputFieldsDTO[];
        integrationId: string;
        authScheme: "OAUTH2" | "OAUTH1" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "BASIC_WITH_JWT";
    }>;
    setup(): Promise<void>;
    getActionsSchema(filters?: {
        actions?: Optional$3<Sequence$2<string>>;
    }, entityId?: Optional$3<string>): Promise<Sequence$2<NonNullable<GetListActionsResponse["items"]>[0]>>;
    /**
     * @deprecated This method is deprecated. Please use this.client.connectedAccounts.getAuthParams instead.
     */
    getAuthParams(data: {
        connectedAccountId: string;
    }): Promise<ConnectedAccountResponseDTO | undefined>;
    getTools(filters: {
        apps: Sequence$2<string>;
        tags?: Optional$3<Array<string>>;
        useCase?: Optional$3<string>;
    }, entityId?: Optional$3<string>): Promise<unknown>;
    getToolsSchema(filters: {
        actions?: Optional$3<Array<string>>;
        apps?: Array<string>;
        tags?: Optional$3<Array<string>>;
        useCase?: Optional$3<string>;
        useCaseLimit?: Optional$3<number>;
        filterByAvailableApps?: Optional$3<boolean>;
    }, entityId?: Optional$3<string>): Promise<Sequence$2<NonNullable<GetListActionsResponse["items"]>[0]>>;
    modifyActionForLocalExecution(toolSchema: any): any;
    createAction(options: CreateActionOptions): Promise<Record<string, any>>;
    private isCustomAction;
    executeAction(functionParams: z.infer<typeof ZExecuteActionParams>): Promise<any>;
    private processResponse;
    addPreProcessor(processor: TPreProcessor): Promise<void>;
    addPostProcessor(processor: TPostProcessor): Promise<void>;
    removePreProcessor(): Promise<void>;
    removePostProcessor(): Promise<void>;
}

declare class LangchainToolSet extends ComposioToolSet {
    /**
     * Composio toolset for Langchain framework.
     *
     */
    static FRAMEWORK_NAME: string;
    static DEFAULT_ENTITY_ID: string;
    fileName: string;
    constructor(config?: {
        apiKey?: Optional$3<string>;
        baseUrl?: Optional$3<string>;
        entityId?: string;
        workspaceConfig?: WorkspaceConfig;
        runtime?: string;
    });
    private _wrapTool;
    getTools(filters: {
        actions?: Optional$3<Array<string>>;
        apps?: Sequence$2<string>;
        tags?: Optional$3<Array<string>>;
        useCase?: Optional$3<string>;
        usecaseLimit?: Optional$3<number>;
        filterByAvailableApps?: Optional$3<boolean>;
    }, entityId?: Optional$3<string>): Promise<Sequence$2<DynamicStructuredTool>>;
}

type Optional$2<T> = T | null;
type Sequence$1<T> = Array<T>;
declare class OpenAIToolSet extends ComposioToolSet {
    static FRAMEWORK_NAME: string;
    static DEFAULT_ENTITY_ID: string;
    fileName: string;
    /**
     * Composio toolset for OpenAI framework.
     *
     * Example:
     * ```typescript
     *
     * ```
     */
    constructor(config?: {
        apiKey?: Optional$2<string>;
        baseUrl?: Optional$2<string>;
        entityId?: string;
        workspaceConfig?: WorkspaceConfig;
    });
    getTools(filters: {
        actions?: Sequence$1<string>;
        apps?: Sequence$1<string>;
        tags?: Optional$2<Array<string>>;
        useCase?: Optional$2<string>;
        useCaseLimit?: Optional$2<number>;
        filterByAvailableApps?: Optional$2<boolean>;
    }, entityId?: Optional$2<string>): Promise<Sequence$1<OpenAI.ChatCompletionTool>>;
    executeToolCall(tool: OpenAI.ChatCompletionMessageToolCall, entityId?: Optional$2<string>): Promise<string>;
    handleToolCall(chatCompletion: OpenAI.ChatCompletion, entityId?: Optional$2<string>): Promise<Sequence$1<string>>;
    handleAssistantMessage(run: OpenAI.Beta.Threads.Run, entityId?: Optional$2<string>): Promise<Array<OpenAI.Beta.Threads.Runs.RunSubmitToolOutputsParams.ToolOutput>>;
    waitAndHandleAssistantStreamToolCalls(client: OpenAI, runStream: Stream<OpenAI.Beta.Assistants.AssistantStreamEvent>, thread: OpenAI.Beta.Threads.Thread, entityId?: string | null): AsyncGenerator<any, void, unknown>;
    waitAndHandleAssistantToolCalls(client: OpenAI, run: OpenAI.Beta.Threads.Run, thread: OpenAI.Beta.Threads.Thread, entityId?: Optional$2<string>): Promise<OpenAI.Beta.Threads.Run>;
}

type Optional$1<T> = T | null;
type Sequence<T> = Array<T>;
/**
 * CloudflareToolSet provides integration with Cloudflare Workers AI
 * for executing AI tool calls and handling responses
 */
declare class CloudflareToolSet extends ComposioToolSet {
    static FRAMEWORK_NAME: string;
    static DEFAULT_ENTITY_ID: string;
    fileName: string;
    /**
     * Initialize a new CloudflareToolSet instance
     *
     * @param config Configuration options including API key, base URL, entity ID and workspace config
     */
    constructor(config?: {
        apiKey?: Optional$1<string>;
        baseUrl?: Optional$1<string>;
        entityId?: string;
        workspaceConfig?: WorkspaceConfig;
    });
    /**
     * Retrieve available tools based on provided filters
     *
     * @param filters Optional filters for actions, apps, tags and use cases
     * @returns Promise resolving to array of AI text generation tools
     */
    getTools(filters: {
        actions?: Optional$1<Sequence<string>>;
        apps?: Sequence<string>;
        tags?: Optional$1<Array<string>>;
        useCase?: Optional$1<string>;
        usecaseLimit?: Optional$1<number>;
        filterByAvailableApps?: Optional$1<boolean>;
    }): Promise<Sequence<AiTextGenerationToolInput>>;
    /**
     * Execute a single tool call
     *
     * @param tool The tool to execute with name and arguments
     * @param entityId Optional entity ID to execute the tool for
     * @returns Promise resolving to stringified tool execution result
     */
    executeToolCall(tool: {
        name: string;
        arguments: unknown;
    }, entityId?: Optional$1<string>): Promise<string>;
    /**
     * Handle tool calls from AI text generation output
     *
     * @param result The AI text generation output containing tool calls
     * @param entityId Optional entity ID to execute the tools for
     * @returns Promise resolving to array of tool execution results
     */
    handleToolCall(result: AiTextGenerationOutput, entityId?: Optional$1<string>): Promise<Sequence<string>>;
}

type Optional<T> = T | null;
declare class VercelAIToolSet extends ComposioToolSet {
    fileName: string;
    constructor(config?: {
        apiKey?: Optional<string>;
        baseUrl?: Optional<string>;
        entityId?: string;
    });
    private generateVercelTool;
    getTools(filters: {
        actions?: Array<string>;
        apps?: Array<string>;
        tags?: Optional<Array<string>>;
        useCase?: Optional<string>;
        usecaseLimit?: Optional<number>;
        filterByAvailableApps?: Optional<boolean>;
    }): Promise<{
        [key: string]: any;
    }>;
    executeToolCall(tool: {
        name: string;
        arguments: unknown;
    }, entityId?: Optional<string>): Promise<string>;
}

declare class LangGraphToolSet extends LangchainToolSet {
    /**
     * Composio toolset for Langgraph framework.
     *
     */
    static FRAMEWORK_NAME: string;
    static DEFAULT_ENTITY_ID: string;
    constructor(config?: {
        apiKey?: Optional$3<string>;
        baseUrl?: Optional$3<string>;
        entityId?: string;
        workspaceConfig?: WorkspaceConfig;
    });
}

interface IDockerConfig extends IWorkspaceConfig {
    /** Name of the docker image. */
    image?: string;
    /**
     * Ports to bind inside the container
     *
     * Note: port 8000 is reserved for the tooling server inside the container
     */
    ports?: {
        [key: number]: any;
    };
    /** Volumes to bind inside the container */
    volumes?: {
        [key: string]: any;
    };
}

interface IE2BConfig extends IWorkspaceConfig {
    template?: string;
    apiKey?: string;
    port?: number;
}

declare class Workspace {
    static Docker(config?: IDockerConfig): WorkspaceConfig<IDockerConfig>;
    static E2B(config?: IE2BConfig): WorkspaceConfig<IE2BConfig>;
    static Host(): WorkspaceConfig<{}>;
}

declare const APPS: any;
declare const ACTIONS: any;

export { ACTIONS, APPS, CloudflareToolSet, Composio, LangGraphToolSet, LangchainToolSet, OpenAIToolSet, VercelAIToolSet, Workspace };
