"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CacheServiceErrorMapper = void 0;
const constants_1 = require("@grpc/grpc-js/build/src/constants");
const src_1 = require("../../src");
const errors_1 = require("@gomomento/sdk-core/dist/src/errors");
const sdk_core_1 = require("@gomomento/sdk-core");
class CacheServiceErrorMapper {
    constructor(throwOnError) {
        this.throwOnErrors = throwOnError;
    }
    returnOrThrowError(err, errorResponseFactoryFn) {
        const sdkError = normalizeSdkError(err);
        if (this.throwOnErrors) {
            throw sdkError;
        }
        else {
            return errorResponseFactoryFn(sdkError);
        }
    }
    resolveOrRejectError(opts) {
        const error = this.convertError(opts.err);
        if (this.throwOnErrors) {
            opts.rejectFn(error);
        }
        else {
            opts.resolveFn(opts.errorResponseFactoryFn(error));
        }
    }
    convertError(err) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const errParams = [
            (err === null || err === void 0 ? void 0 : err.message) || 'Unable to process request',
            err === null || err === void 0 ? void 0 : err.code,
            err === null || err === void 0 ? void 0 : err.metadata,
            err === null || err === void 0 ? void 0 : err.stack,
        ];
        switch (err === null || err === void 0 ? void 0 : err.code) {
            case constants_1.Status.PERMISSION_DENIED:
                return new src_1.PermissionError(...errParams);
            case constants_1.Status.DATA_LOSS:
            case constants_1.Status.INTERNAL:
            case constants_1.Status.ABORTED:
                return new src_1.InternalServerError(...errParams);
            case constants_1.Status.UNKNOWN:
                return new src_1.UnknownServiceError(...errParams);
            case constants_1.Status.UNAVAILABLE:
                return new src_1.ServerUnavailableError(...errParams);
            case constants_1.Status.NOT_FOUND: {
                let errCause = (_b = (_a = errParams[2]) === null || _a === void 0 ? void 0 : _a.get('err')) === null || _b === void 0 ? void 0 : _b[0];
                // TODO: Remove this once the error message is standardized on the server side
                const errorMessage = (_c = errParams[0]) === null || _c === void 0 ? void 0 : _c.toString();
                const isStoreNotFound = (errorMessage === null || errorMessage === void 0 ? void 0 : errorMessage.includes('Store with name:')) &&
                    (errorMessage === null || errorMessage === void 0 ? void 0 : errorMessage.includes("doesn't exist"));
                // If errCause is not already set to 'store_not_found', check for store_not_found error
                if (!errCause && isStoreNotFound) {
                    errCause = 'store_not_found';
                }
                switch (errCause) {
                    case 'item_not_found':
                        return new errors_1.StoreItemNotFoundError(...errParams);
                    case 'store_not_found':
                        return new errors_1.StoreNotFoundError(...errParams);
                    default:
                        return new errors_1.CacheNotFoundError(...errParams);
                }
            }
            case constants_1.Status.OUT_OF_RANGE:
            case constants_1.Status.UNIMPLEMENTED:
                return new src_1.BadRequestError(...errParams);
            case constants_1.Status.FAILED_PRECONDITION:
                return new src_1.FailedPreconditionError(...errParams);
            case constants_1.Status.INVALID_ARGUMENT:
                return new src_1.InvalidArgumentError(...errParams);
            case constants_1.Status.CANCELLED:
                return new src_1.CancelledError(...errParams);
            case constants_1.Status.DEADLINE_EXCEEDED:
                return new src_1.TimeoutError(...errParams);
            case constants_1.Status.UNAUTHENTICATED:
                return new src_1.AuthenticationError(...errParams);
            case constants_1.Status.RESOURCE_EXHAUSTED: {
                const errCause = (_f = (_e = (_d = errParams[2]) === null || _d === void 0 ? void 0 : _d.get('err')) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.toString();
                return new src_1.LimitExceededError(...errParams, errCause);
            }
            case constants_1.Status.ALREADY_EXISTS: {
                let errCause = (_h = (_g = errParams[2]) === null || _g === void 0 ? void 0 : _g.get('err')) === null || _h === void 0 ? void 0 : _h[0];
                // TODO: Remove this once the error message is standardized on the server side
                const errorMessage = (_j = errParams[0]) === null || _j === void 0 ? void 0 : _j.toString();
                const isStoreAlreadyExists = (errorMessage === null || errorMessage === void 0 ? void 0 : errorMessage.includes('Store with name:')) &&
                    (errorMessage === null || errorMessage === void 0 ? void 0 : errorMessage.includes('already exists'));
                // If errCause is not already set to 'store_already_exists', check for store_already_exists error
                if (!errCause && isStoreAlreadyExists) {
                    errCause = 'store_already_exists';
                }
                switch (errCause) {
                    case 'store_already_exists':
                        return new sdk_core_1.StoreAlreadyExistsError(...errParams);
                    default:
                        return new sdk_core_1.CacheAlreadyExistsError(...errParams);
                }
            }
            default:
                return new src_1.UnknownError(...errParams);
        }
    }
}
exports.CacheServiceErrorMapper = CacheServiceErrorMapper;
function normalizeSdkError(error) {
    if (error instanceof src_1.SdkError) {
        return error;
    }
    return new src_1.UnknownError(error.message);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FjaGUtc2VydmljZS1lcnJvci1tYXBwZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvZXJyb3JzL2NhY2hlLXNlcnZpY2UtZXJyb3ItbWFwcGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLGlFQUF5RDtBQUV6RCxtQ0FjbUI7QUFDbkIsZ0VBSTZDO0FBSzdDLGtEQUc2QjtBQUU3QixNQUFhLHVCQUF1QjtJQUtsQyxZQUFZLFlBQXFCO1FBQy9CLElBQUksQ0FBQyxhQUFhLEdBQUcsWUFBWSxDQUFDO0lBQ3BDLENBQUM7SUFFRCxrQkFBa0IsQ0FDaEIsR0FBVSxFQUNWLHNCQUF5RDtRQUV6RCxNQUFNLFFBQVEsR0FBRyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN4QyxJQUFJLElBQUksQ0FBQyxhQUFhLEVBQUU7WUFDdEIsTUFBTSxRQUFRLENBQUM7U0FDaEI7YUFBTTtZQUNMLE9BQU8sc0JBQXNCLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDekM7SUFDSCxDQUFDO0lBRUQsb0JBQW9CLENBQUMsSUFBK0M7UUFDbEUsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFMUMsSUFBSSxJQUFJLENBQUMsYUFBYSxFQUFFO1lBQ3RCLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDdEI7YUFBTTtZQUNMLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLHNCQUFzQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7U0FDcEQ7SUFDSCxDQUFDO0lBRUQsWUFBWSxDQUFDLEdBQXdCOztRQUNuQyxNQUFNLFNBQVMsR0FLWDtZQUNGLENBQUEsR0FBRyxhQUFILEdBQUcsdUJBQUgsR0FBRyxDQUFFLE9BQU8sS0FBSSwyQkFBMkI7WUFDM0MsR0FBRyxhQUFILEdBQUcsdUJBQUgsR0FBRyxDQUFFLElBQUk7WUFDVCxHQUFHLGFB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QUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ3pDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1N0YXR1c30gZnJvbSAnQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29uc3RhbnRzJztcbmltcG9ydCB7TWV0YWRhdGEsIFNlcnZpY2VFcnJvcn0gZnJvbSAnQGdycGMvZ3JwYy1qcyc7XG5pbXBvcnQge1xuICBJbnRlcm5hbFNlcnZlckVycm9yLFxuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgUGVybWlzc2lvbkVycm9yLFxuICBCYWRSZXF1ZXN0RXJyb3IsXG4gIENhbmNlbGxlZEVycm9yLFxuICBUaW1lb3V0RXJyb3IsXG4gIEF1dGhlbnRpY2F0aW9uRXJyb3IsXG4gIExpbWl0RXhjZWVkZWRFcnJvcixcbiAgU2RrRXJyb3IsXG4gIFVua25vd25TZXJ2aWNlRXJyb3IsXG4gIFNlcnZlclVuYXZhaWxhYmxlRXJyb3IsXG4gIFVua25vd25FcnJvcixcbiAgRmFpbGVkUHJlY29uZGl0aW9uRXJyb3IsXG59IGZyb20gJy4uLy4uL3NyYyc7XG5pbXBvcnQge1xuICBDYWNoZU5vdEZvdW5kRXJyb3IsXG4gIFN0b3JlSXRlbU5vdEZvdW5kRXJyb3IsXG4gIFN0b3JlTm90Rm91bmRFcnJvcixcbn0gZnJvbSAnQGdvbW9tZW50by9zZGstY29yZS9kaXN0L3NyYy9lcnJvcnMnO1xuaW1wb3J0IHtcbiAgSUNhY2hlU2VydmljZUVycm9yTWFwcGVyLFxuICBSZXNvbHZlT3JSZWplY3RFcnJvck9wdGlvbnMsXG59IGZyb20gJ0Bnb21vbWVudG8vc2RrLWNvcmUvZGlzdC9zcmMvZXJyb3JzL0lDYWNoZVNlcnZpY2VFcnJvck1hcHBlcic7XG5pbXBvcnQge1xuICBDYWNoZUFscmVhZHlFeGlzdHNFcnJvcixcbiAgU3RvcmVBbHJlYWR5RXhpc3RzRXJyb3IsXG59IGZyb20gJ0Bnb21vbWVudG8vc2RrLWNvcmUnO1xuXG5leHBvcnQgY2xhc3MgQ2FjaGVTZXJ2aWNlRXJyb3JNYXBwZXJcbiAgaW1wbGVtZW50cyBJQ2FjaGVTZXJ2aWNlRXJyb3JNYXBwZXI8U2VydmljZUVycm9yPlxue1xuICBwcml2YXRlIHJlYWRvbmx5IHRocm93T25FcnJvcnM6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IodGhyb3dPbkVycm9yOiBib29sZWFuKSB7XG4gICAgdGhpcy50aHJvd09uRXJyb3JzID0gdGhyb3dPbkVycm9yO1xuICB9XG5cbiAgcmV0dXJuT3JUaHJvd0Vycm9yPFRFcnJvclJlc3BvbnNlPihcbiAgICBlcnI6IEVycm9yLFxuICAgIGVycm9yUmVzcG9uc2VGYWN0b3J5Rm46IChlcnI6IFNka0Vycm9yKSA9PiBURXJyb3JSZXNwb25zZVxuICApOiBURXJyb3JSZXNwb25zZSB7XG4gICAgY29uc3Qgc2RrRXJyb3IgPSBub3JtYWxpemVTZGtFcnJvcihlcnIpO1xuICAgIGlmICh0aGlzLnRocm93T25FcnJvcnMpIHtcbiAgICAgIHRocm93IHNka0Vycm9yO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZXJyb3JSZXNwb25zZUZhY3RvcnlGbihzZGtFcnJvcik7XG4gICAgfVxuICB9XG5cbiAgcmVzb2x2ZU9yUmVqZWN0RXJyb3Iob3B0czogUmVzb2x2ZU9yUmVqZWN0RXJyb3JPcHRpb25zPFNlcnZpY2VFcnJvcj4pOiB2b2lkIHtcbiAgICBjb25zdCBlcnJvciA9IHRoaXMuY29udmVydEVycm9yKG9wdHMuZXJyKTtcblxuICAgIGlmICh0aGlzLnRocm93T25FcnJvcnMpIHtcbiAgICAgIG9wdHMucmVqZWN0Rm4oZXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRzLnJlc29sdmVGbihvcHRzLmVycm9yUmVzcG9uc2VGYWN0b3J5Rm4oZXJyb3IpKTtcbiAgICB9XG4gIH1cblxuICBjb252ZXJ0RXJyb3IoZXJyOiBTZXJ2aWNlRXJyb3IgfCBudWxsKTogU2RrRXJyb3Ige1xuICAgIGNvbnN0IGVyclBhcmFtczogW1xuICAgICAgc3RyaW5nLFxuICAgICAgbnVtYmVyIHwgdW5kZWZpbmVkLFxuICAgICAgTWV0YWRhdGEgfCB1bmRlZmluZWQsXG4gICAgICBzdHJpbmcgfCB1bmRlZmluZWRcbiAgICBdID0gW1xuICAgICAgZXJyPy5tZXNzYWdlIHx8ICdVbmFibGUgdG8gcHJvY2VzcyByZXF1ZXN0JyxcbiAgICAgIGVycj8uY29kZSxcbiAgICAgIGVycj8ubWV0YWRhdGEsXG4gICAgICBlcnI/LnN0YWNrLFxuICAgIF07XG4gICAgc3dpdGNoIChlcnI/LmNvZGUpIHtcbiAgICAgIGNhc2UgU3RhdHVzLlBFUk1JU1NJT05fREVOSUVEOlxuICAgICAgICByZXR1cm4gbmV3IFBlcm1pc3Npb25FcnJvciguLi5lcnJQYXJhbXMpO1xuICAgICAgY2FzZSBTdGF0dXMuREFUQV9MT1NTOlxuICAgICAgY2FzZSBTdGF0dXMuSU5URVJOQUw6XG4gICAgICBjYXNlIFN0YXR1cy5BQk9SVEVEOlxuICAgICAgICByZXR1cm4gbmV3IEludGVybmFsU2VydmVyRXJyb3IoLi4uZXJyUGFyYW1zKTtcbiAgICAgIGNhc2UgU3RhdHVzLlVOS05PV046XG4gICAgICAgIHJldHVybiBuZXcgVW5rbm93blNlcnZpY2VFcnJvciguLi5lcnJQYXJhbXMpO1xuICAgICAgY2FzZSBTdGF0dXMuVU5BVkFJTEFCTEU6XG4gICAgICAgIHJldHVybiBuZXcgU2VydmVyVW5hdmFpbGFibGVFcnJvciguLi5lcnJQYXJhbXMpO1xuICAgICAgY2FzZSBTdGF0dXMuTk9UX0ZPVU5EOiB7XG4gICAgICAgIGxldCBlcnJDYXVzZSA9IGVyclBhcmFtc1syXT8uZ2V0KCdlcnInKT8uWzBdO1xuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBvbmNlIHRoZSBlcnJvciBtZXNzYWdlIGlzIHN0YW5kYXJkaXplZCBvbiB0aGUgc2VydmVyIHNpZGVcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyUGFyYW1zWzBdPy50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBpc1N0b3JlTm90Rm91bmQgPVxuICAgICAgICAgIGVycm9yTWVzc2FnZT8uaW5jbHVkZXMoJ1N0b3JlIHdpdGggbmFtZTonKSAmJlxuICAgICAgICAgIGVycm9yTWVzc2FnZT8uaW5jbHVkZXMoXCJkb2Vzbid0IGV4aXN0XCIpO1xuICAgICAgICAvLyBJZiBlcnJDYXVzZSBpcyBub3QgYWxyZWFkeSBzZXQgdG8gJ3N0b3JlX25vdF9mb3VuZCcsIGNoZWNrIGZvciBzdG9yZV9ub3RfZm91bmQgZXJyb3JcbiAgICAgICAgaWYgKCFlcnJDYXVzZSAmJiBpc1N0b3JlTm90Rm91bmQpIHtcbiAgICAgICAgICBlcnJDYXVzZSA9ICdzdG9yZV9ub3RfZm91bmQnO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZXJyQ2F1c2UpIHtcbiAgICAgICAgICBjYXNlICdpdGVtX25vdF9mb3VuZCc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0b3JlSXRlbU5vdEZvdW5kRXJyb3IoLi4uZXJyUGFyYW1zKTtcbiAgICAgICAgICBjYXNlICdzdG9yZV9ub3RfZm91bmQnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdG9yZU5vdEZvdW5kRXJyb3IoLi4uZXJyUGFyYW1zKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDYWNoZU5vdEZvdW5kRXJyb3IoLi4uZXJyUGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FzZSBTdGF0dXMuT1VUX09GX1JBTkdFOlxuICAgICAgY2FzZSBTdGF0dXMuVU5JTVBMRU1FTlRFRDpcbiAgICAgICAgcmV0dXJuIG5ldyBCYWRSZXF1ZXN0RXJyb3IoLi4uZXJyUGFyYW1zKTtcbiAgICAgIGNhc2UgU3RhdHVzLkZBSUxFRF9QUkVDT05ESVRJT046XG4gICAgICAgIHJldHVybiBuZXcgRmFpbGVkUHJlY29uZGl0aW9uRXJyb3IoLi4uZXJyUGFyYW1zKTtcbiAgICAgIGNhc2UgU3RhdHVzLklOVkFMSURfQVJHVU1FTlQ6XG4gICAgICAgIHJldHVybiBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoLi4uZXJyUGFyYW1zKTtcbiAgICAgIGNhc2UgU3RhdHVzLkNBTkNFTExFRDpcbiAgICAgICAgcmV0dXJuIG5ldyBDYW5jZWxsZWRFcnJvciguLi5lcnJQYXJhbXMpO1xuICAgICAgY2FzZSBTdGF0dXMuREVBRExJTkVfRVhDRUVERUQ6XG4gICAgICAgIHJldHVybiBuZXcgVGltZW91dEVycm9yKC4uLmVyclBhcmFtcyk7XG4gICAgICBjYXNlIFN0YXR1cy5VTkFVVEhFTlRJQ0FURUQ6XG4gICAgICAgIHJldHVybiBuZXcgQXV0aGVudGljYXRpb25FcnJvciguLi5lcnJQYXJhbXMpO1xuICAgICAgY2FzZSBTdGF0dXMuUkVTT1VSQ0VfRVhIQVVTVEVEOiB7XG4gICAgICAgIGNvbnN0IGVyckNhdXNlID0gZXJyUGFyYW1zWzJdPy5nZXQoJ2VycicpPy5bMF0/LnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBuZXcgTGltaXRFeGNlZWRlZEVycm9yKC4uLmVyclBhcmFtcywgZXJyQ2F1c2UpO1xuICAgICAgfVxuICAgICAgY2FzZSBTdGF0dXMuQUxSRUFEWV9FWElTVFM6IHtcbiAgICAgICAgbGV0IGVyckNhdXNlID0gZXJyUGFyYW1zWzJdPy5nZXQoJ2VycicpPy5bMF07XG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIG9uY2UgdGhlIGVycm9yIG1lc3NhZ2UgaXMgc3RhbmRhcmRpemVkIG9uIHRoZSBzZXJ2ZXIgc2lkZVxuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJQYXJhbXNbMF0/LnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGlzU3RvcmVBbHJlYWR5RXhpc3RzID1cbiAgICAgICAgICBlcnJvck1lc3NhZ2U/LmluY2x1ZGVzKCdTdG9yZSB3aXRoIG5hbWU6JykgJiZcbiAgICAgICAgICBlcnJvck1lc3NhZ2U/LmluY2x1ZGVzKCdhbHJlYWR5IGV4aXN0cycpO1xuICAgICAgICAvLyBJZiBlcnJDYXVzZSBpcyBub3QgYWxyZWFkeSBzZXQgdG8gJ3N0b3JlX2FscmVhZHlfZXhpc3RzJywgY2hlY2sgZm9yIHN0b3JlX2FscmVhZHlfZXhpc3RzIGVycm9yXG4gICAgICAgIGlmICghZXJyQ2F1c2UgJiYgaXNTdG9yZUFscmVhZHlFeGlzdHMpIHtcbiAgICAgICAgICBlcnJDYXVzZSA9ICdzdG9yZV9hbHJlYWR5X2V4aXN0cyc7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChlcnJDYXVzZSkge1xuICAgICAgICAgIGNhc2UgJ3N0b3JlX2FscmVhZHlfZXhpc3RzJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RvcmVBbHJlYWR5RXhpc3RzRXJyb3IoLi4uZXJyUGFyYW1zKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDYWNoZUFscmVhZHlFeGlzdHNFcnJvciguLi5lcnJQYXJhbXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbmV3IFVua25vd25FcnJvciguLi5lcnJQYXJhbXMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTZGtFcnJvcihlcnJvcjogRXJyb3IpOiBTZGtFcnJvciB7XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIFNka0Vycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIHJldHVybiBuZXcgVW5rbm93bkVycm9yKGVycm9yLm1lc3NhZ2UpO1xufVxuIl19