import * as axios from 'axios';
import { z, ZodObject, ZodString, ZodOptional } from 'zod';
import { DynamicStructuredTool } from '@langchain/core/tools';
import { OpenAI } from 'openai';
import { Stream } from 'openai/streaming';
import { AiTextGenerationToolInput, AiTextGenerationOutput } from '@cloudflare/workers-types';

/**
 * Member information
 */
export type MemberInfoResDTO = {
    id: string;
    projectId: string;
    email: string;
    name: string;
    role: string;
    metadata?: unknown;
    createdAt: string;
    updatedAt: string;
    deletedAt?: string;
};
export type DeleteRowAPIDTO = {
    /**
     * Status of the delete operation
     */
    status: string;
    /**
     * Number of records deleted
     */
    count: number;
};
export type SingleAppInfoResDTO = {
    /**
     * The unique identifier for the app
     */
    appId: string;
    /**
     * The key of the app
     */
    key: string;
    /**
     * The name of the app
     */
    name: string;
    /**
     * The description of the app
     */
    description: string;
    /**
     * The logo of the app
     */
    logo?: string;
    /**
     * The categories of the app
     */
    categories?: Array<string>;
    /**
     * The path of the app
     */
    path?: string;
    /**
     * The documentation URL of the app
     */
    docs?: string;
    /**
     * The configuration documentation text of the app
     */
    configuration_docs_text?: string;
    /**
     * The status of the app
     */
    status?: string;
    /**
     * The documentation text of the app
     */
    documentation_doc_text?: string;
    /**
     * The test connectors of the app
     */
    testConnectors?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Indicates if the app has no authentication
     */
    no_auth?: boolean;
    /**
     * The authentication schemes of the app
     */
    auth_schemes?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * The metadata of the app
     */
    meta?: unknown;
    /**
     * The yaml of the app
     */
    yaml?: unknown;
};
export type AppInfoResponseDto = {
    /**
     * The ID of the app
     */
    appId: string;
    /**
     * The key of the app
     */
    key: string;
    /**
     * The name of the app
     */
    name: string;
    /**
     * The description of the app
     */
    description: string;
    /**
     * The logo of the app
     */
    logo: string;
    /**
     * The categories of the app
     */
    categories: string;
    /**
     * The tags of the app
     */
    tags?: string;
    /**
     * The authentication schemes of the app
     */
    auth_schemes?: unknown;
    /**
     * Indicates if the app is enabled
     */
    enabled: boolean;
    /**
     * Indicates if the app has no authentication
     */
    no_auth?: boolean;
};
export type ExpectedInputFieldsDTO = {
    /**
     * Name of the field
     */
    name: string;
    /**
     * Type of the field
     */
    type: string;
    /**
     * Description of the field
     */
    description: string;
    /**
     * Display name of the field
     */
    display_name: string;
    /**
     * Default value of the field
     */
    default: {
        [key: string]: unknown;
    };
    /**
     * Whether the field is required
     */
    required: boolean;
    /**
     * Whether the field is expected from customer
     */
    expected_from_customer: boolean;
    /**
     * Whether the field is a secret
     */
    is_secret: boolean;
};
export type GetConnectorInfoResDTO = {
    /**
     * Unique identifier of the connector
     */
    id?: string;
    /**
     * Authentication scheme used by the connector
     */
    authScheme?: string;
    /**
     * Name of the connector
     */
    name?: string;
    /**
     * Creation date of the connector
     */
    createdAt?: string;
    /**
     * Last update date of the connector
     */
    updatedAt?: string;
    /**
     * Flag to indicate if the connector is currently enabled
     */
    enabled: boolean;
    /**
     * Flag to indicate if the connector has been deleted
     */
    deleted?: boolean;
    /**
     * Application ID associated with the connector
     */
    appId: string;
    /**
     * Default connector ID if one exists
     */
    defaultConnectorId?: string;
    /**
     * Authentication configuration with sensitive data obscured
     */
    authConfig: {
        [key: string]: unknown;
    };
    /**
     * List of required fields expected from the customer
     */
    expectedInputFields: Array<ExpectedInputFieldsDTO>;
    /**
     * Logo URL of the application associated with the connector
     */
    logo: string;
    /**
     * Name of the application associated with the connector
     */
    appName: string;
    /**
     * Flag to indicate if Composio authentication is used
     */
    useComposioAuth: boolean;
};
export type GetConnectorListResDTO = {
    items: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Total number of pages available
     */
    totalPages: number;
    /**
     * Current page number
     */
    page: number;
};
export type ConnectionParams = {
    integrationId: string;
    connectionParams?: {
        [key: string]: unknown;
    };
    isDisabled: boolean;
    invocationCount: number;
    id: string;
    clientUniqueUserId?: string;
    status: string;
    data?: {
        [key: string]: unknown;
    };
    deleted?: boolean;
    enabled?: boolean;
    createdAt: string;
    updatedAt: string;
    appUniqueId: string;
    appName: string;
    logo?: string;
    authConfig?: {
        [key: string]: unknown;
    };
    member: {
        [key: string]: unknown;
    };
    labels?: Array<string>;
};
export type Meta = {
    app: {
        [key: string]: unknown;
    };
};
export type ConnectedAccountResponseDTO = {
    integrationId: string;
    appUniqueId: string;
    memberInfo?: MemberInfoResDTO;
    meta?: Meta;
    isDisabled?: boolean;
    id: string;
    clientUniqueUserId: string;
    appName: string;
    entityId: string;
    status: string;
    enabled?: boolean;
    createdAt: string;
    updatedAt: string;
};
export type GetConnectionsResponseDto = {
    items: Array<ConnectionParams>;
    totalPages: number;
    page: number;
};
export type GetConnectionInfoResponseDTO = {
    base_url: string;
    parameters: Array<Parameter$1>;
    body: {
        [key: string]: unknown;
    };
};
type Parameter$1 = {
    /**
     * The name of the parameter. For example, 'x-api-key', 'Content-Type', etc.,
     */
    name: string;
    /**
     * The location of the parameter. Can be 'query' or 'header'.
     */
    in: "query" | "header";
    /**
     * The value of the parameter. For example, '1234567890', 'application/json', etc.,
     */
    value: string;
};
export type InitiateConnectionPayloadDto = {
    data: {
        [key: string]: unknown;
    };
    integrationId: string;
    redirectUri?: string;
    userUuid?: string;
    entityId?: string;
    labels?: Array<string>;
};
export type InitiateConnectionResponse = {
    connectionStatus: string;
    connectedAccountId: string;
    redirectUrl?: string;
};
export type ActionExecutionResDto = {
    data: {
        [key: string]: unknown;
    };
    error?: string;
    successfull?: string;
};
export type ActionProxyRequestConfigDTO = {
    /**
     * The connected account uuid to use for the action.
     */
    connectedAccountId: string;
    /**
     * The endpoint to call for the action. If the given url is relative, it will be resolved relative to the base_url set in the connected account info.
     */
    endpoint: string;
    /**
     * The HTTP method to use for the action.
     */
    method: "GET" | "POST" | "PUT" | "PATCH" | "DELETE";
    parameters: Array<Parameter$1>;
    /**
     * The body to be sent to the endpoint. This can either be a JSON field or a string.
     */
    body?: {
        [key: string]: unknown;
    };
};
export type ActionDetails = {
    parameters: {
        [key: string]: unknown;
    };
    response: {
        [key: string]: unknown;
    };
    appId?: string;
    appKey: string;
    appName: string;
    description: string;
    displayName: string;
    enabled: boolean;
    logo: string;
    name: string;
    tags: Array<string>;
    deprecated: boolean;
};
export type ActionsListResponseDTO = {
    items: Array<ActionDetails>;
    page: number;
    totalPages: number;
};
export type TriggerResDTO = {
    /**
     * Trigger name
     */
    name: string;
    /**
     * Trigger display name
     */
    display_name: string;
    /**
     * Trigger description
     */
    description?: string;
    /**
     * Is trigger enabled
     */
    enabled?: boolean;
    /**
     * Trigger configuration
     */
    config?: {
        [key: string]: unknown;
    };
    /**
     * Trigger payload
     */
    payload?: {
        [key: string]: unknown;
    };
    /**
     * Trigger logo URL
     */
    logo?: string;
    /**
     * Trigger count
     */
    count?: number;
    /**
     * App key
     */
    appKey: string;
    /**
     * App ID
     */
    appId: string;
    /**
     * App name
     */
    appName: string;
    /**
     * Trigger instructions
     */
    instructions?: string;
    /**
     * Trigger type
     */
    type?: string;
};
export type DeleteConnectorData = {
    path: {
        integrationId: string;
    };
};
export type GetConnectionsData = {
    query?: {
        appNames?: string;
        connectionId?: string;
        integrationId?: string;
        labels?: Array<string>;
        page?: number;
        pageSize?: number;
        showActiveOnly?: boolean;
        showDisabled?: boolean;
        status?: string;
        user_uuid?: string;
    };
};
export type GetConnectionInfoData = {
    path: {
        connectedAccountId: string;
    };
};
export type GetConnectionInfoResponse = GetConnectionInfoResponseDTO;
export type ListTriggersData = {
    query?: {
        appNames?: string;
        connectedAccountIds?: string;
        integrationIds?: string;
        showEnabledOnly?: boolean;
        triggerIds?: string;
    };
};
export type ListTriggersResponse = Array<TriggerResDTO>;
export type GetActiveTriggersData = {
    query?: {
        connectedAccountIds?: string;
        integrationIds?: string;
        limit?: number;
        page?: number;
        showDisabled?: boolean;
        triggerIds?: string;
        triggerNames?: string;
    };
};

/**
 * Class representing the details required to initialize and configure the API client.
 */
export declare class BackendClient {
    /**
     * The API key used for authenticating requests.
     */
    apiKey: string;
    /**
     * The base URL of the API against which requests will be made.
     */
    baseUrl: string;
    /**
     * The runtime environment where the client is being used.
     */
    runtime: string;
    /**
     * Creates an instance of apiClientDetails.
     * @param {string} apiKey - The API key for client initialization.
     * @param {string} baseUrl - The base URL for the API client.
     * @param {string} runtime - The runtime environment identifier.
     * @throws Will throw an error if the API key is not provided.
     */
    constructor(apiKey: string, baseUrl: string, runtime?: string);
    /**
     * Retrieves the client ID from the user's information.
     * @returns {Promise<string>} A promise that resolves to the client ID.
     * @throws Will throw an error if the HTTP request fails.
     */
    getClientId(): Promise<string>;
    /**
     * Initializes the API client with the provided configuration.
     * @private
     */
    private initializeApiClient;
}

export type ListAllIntegrationsData = {
    /**
     * Page number to fetch
     */
    page?: number;
    /**
     * Page Size to assume
     */
    pageSize?: number;
    /**
     * The name of the app to filter by
     */
    appName?: string;
    /**
     * Whether to show disabled integrations
     */
    showDisabled?: boolean;
};
export type GetIntegrationData = {
    /**
     * The unique identifier of the integration.
     */
    integrationId: string;
};
export type CreateIntegrationData = {
    requestBody?: {
        /**
         * The name of the connector.
         */
        name?: string;
        /**
         * The authentication scheme used by the connector (e.g., "OAUTH2", "API_KEY").
         */
        authScheme?: string;
        /**
         * The unique identifier of the app associated with the connector.
         */
        appId?: string;
        forceNewIntegration?: boolean;
        /**
         * An object containing the authentication configuration for the connector.
         */
        authConfig?: {
            /**
             * The client ID used for authentication with the app - if authScheme is OAUTH2
             */
            client_id?: string;
            /**
             * The client secret used for authentication with the app - if authScheme is OAUTH2
             */
            client_secret?: string;
            /**
             * The API key used for authentication with the app - if authScheme is API_KEY
             */
            api_key?: string;
            /**
             * The Consumer key used for authentication with the app - if authScheme is OAUTH1
             */
            consumer_key?: string;
            /**
             * The Consumer secret used for authentication with the app - if authScheme is OAUTH1
             */
            consumer_secret?: string;
            /**
             *  The base URL for making API requests to the app.
             */
            base_url?: string;
            [key: string]: unknown;
        };
        /**
         * Use default Composio credentials to proceed. The developer app credentials will be of Composio.
         */
        useComposioAuth?: boolean;
    };
};
export declare class Integrations {
    backendClient: BackendClient;
    fileName: string;
    constructor(backendClient: BackendClient);
    /**
     * Retrieves a list of all available integrations in the Composio platform.
     *
     * This method allows clients to explore and discover the supported integrations. It returns an array of integration objects, each containing essential details such as the integration's key, name, description, logo, categories, and unique identifier.
     *
     * @returns {Promise<ListAllIntegrationsResponse>} A promise that resolves to the list of all integrations.
     * @throws {ApiError} If the request fails.
     */
    list(data?: ListAllIntegrationsData): Promise<GetConnectorListResDTO | undefined>;
    /**
     * Retrieves details of a specific integration in the Composio platform by providing its integration name.
     *
     * The response includes the integration's name, display name, description, input parameters, expected response, associated app information, and enabled status.
     *
     * @param {GetIntegrationData} data The data for the request.
     * @returns {Promise<AppConnectorControllerGetConnectorInfoResponse | undefined>} A promise that resolves to the details of the integration.
     * @throws {ApiError} If the request fails.
     */
    get(data: GetIntegrationData): Promise<GetConnectorInfoResDTO | undefined>;
    getRequiredParams(integrationId: string): Promise<ExpectedInputFieldsDTO[]>;
    /**
     * Creates a new integration in the Composio platform.
     *
     * This method allows clients to create a new integration by providing the necessary details such as app ID, name, authentication mode, and configuration.
     *
     * @param {CreateIntegrationData["requestBody"]} data The data for the request.
     * @returns {Promise<CreateIntegrationResponse>} A promise that resolves to the created integration model.
     * @throws {ApiError} If the request fails.
     */
    create(data: CreateIntegrationData["requestBody"]): Promise<GetConnectorInfoResDTO>;
    delete(data: DeleteConnectorData): Promise<DeleteRowAPIDTO | undefined>;
}

export type GetAppData = {
    appKey: string;
};
export type RequiredParamsResponse = {
    required_fields: string[];
    expected_from_user: string[];
    optional_fields: string[];
};
export type RequiredParamsFullResponse = {
    availableAuthSchemes: string[];
    authSchemes: Record<string, RequiredParamsResponse>;
};
export declare class Apps {
    backendClient: BackendClient;
    fileName: string;
    constructor(backendClient: BackendClient);
    /**
     * Retrieves a list of all available apps in the Composio platform.
     *
     * This method allows clients to explore and discover the supported apps. It returns an array of app objects, each containing essential details such as the app's key, name, description, logo, categories, and unique identifier.
     *
     * @returns {Promise<AppListResDTO>} A promise that resolves to the list of all apps.
     * @throws {ApiError} If the request fails.
     */
    list(): Promise<AppInfoResponseDto[]>;
    /**
     * Retrieves details of a specific app in the Composio platform.
     *
     * This method allows clients to fetch detailed information about a specific app by providing its unique key. The response includes the app's name, key, status, description, logo, categories, authentication schemes, and other metadata.
     *
     * @param {GetAppData} data The data for the request, including the app's unique key.
     * @returns {CancelablePromise<GetAppResponse>} A promise that resolves to the details of the app.
     * @throws {ApiError} If the request fails.
     */
    get(data: GetAppData): Promise<SingleAppInfoResDTO>;
    getRequiredParams(appId: string): Promise<RequiredParamsFullResponse>;
    getRequiredParamsForAuthScheme({ appId, authScheme, }: {
        appId: string;
        authScheme: string;
    }): Promise<RequiredParamsResponse>;
}

export type ConnectedAccountsListData = GetConnectionsData["query"] & {
    appNames?: string;
};
export type InitiateConnectionDataReq = InitiateConnectionPayloadDto & {
    data?: Record<string, unknown> | unknown;
    entityId?: string;
    labels?: string[];
    integrationId?: string;
    redirectUri?: string;
    authMode?: string;
    authConfig?: {
        [key: string]: any;
    };
    appName?: string;
};
export declare class ConnectedAccounts {
    backendClient: BackendClient;
    integrations: Integrations;
    apps: Apps;
    fileName: string;
    constructor(backendClient: BackendClient);
    list(data: ConnectedAccountsListData): Promise<GetConnectionsResponseDto>;
    create(data: InitiateConnectionPayloadDto): Promise<ConnectionRequest>;
    get(data: {
        connectedAccountId: string;
    }): Promise<ConnectedAccountResponseDTO | undefined>;
    delete(data: {
        connectedAccountId: string;
    }): Promise<DeleteRowAPIDTO | undefined>;
    getAuthParams(data: {
        connectedAccountId: string;
    }): Promise<ConnectedAccountResponseDTO | undefined>;
    initiate(payload: InitiateConnectionDataReq): Promise<ConnectionRequest>;
}
export declare class ConnectionRequest {
    connectionStatus: string;
    connectedAccountId: string;
    redirectUrl: string | null;
    constructor({ connectionStatus, connectedAccountId, redirectUri, }: {
        connectionStatus: string;
        connectedAccountId: string;
        redirectUri: string | null;
    });
    saveUserAccessData(data: {
        fieldInputs: Record<string, string>;
        redirectUrl?: string;
        entityId?: string;
    }): Promise<(axios.AxiosError<unknown, any> & {
        data: undefined;
        error: unknown;
    }) | (axios.AxiosResponse<InitiateConnectionResponse, any> & {
        error: undefined;
    })>;
    getAuthInfo(data: GetConnectionInfoData["path"]): Promise<GetConnectionInfoResponse>;
    waitUntilActive(timeout?: number): Promise<ConnectedAccountResponseDTO>;
}

/**
 * The `Actions` class provides methods to interact with the Composio platform's actions.
 * It allows fetching details of specific actions, listing all actions, and executing actions.
 *
 * - `get` method retrieves details of a specific action.
 * - `list` method retrieves a list of all actions.
 * - `execute` method executes a specific action.
 *
 * Each method returns a `CancelablePromise` which can be canceled. If canceled, the promise
 * will reject with a `Cancellation` object.
 *
 * @typeParam Composio The client configuration object type.
 * @groupDescription Methods
 * The methods in this class are grouped under 'Actions Methods' and provide functionalities
 * to interact with actions in the Composio platform. This includes fetching, listing, and
 * executing actions.
 */
export type GetListActionsData = {
    /**
     * Name of the apps like "github", "linear" separated by a comma
     */
    apps?: string;
    /**
     * Filter by Action names
     */
    actions?: string;
    /**
     * Filter by Action tags
     */
    tags?: string;
    /**
     * Filter by use case
     */
    useCase?: string | undefined;
    /**
     * Limit of use-cases based search
     */
    usecaseLimit?: number;
    /**
     * Show all actions - i.e disable pagination
     */
    showAll?: boolean;
    /**
     * Show actions enabled for the API Key
     */
    showEnabledOnly?: boolean;
    /**
     * Use smart tag filtering
     */
    filterImportantActions?: boolean;
    /**
     * Should search in available apps only
     */
    filterByAvailableApps?: boolean;
};
export type Parameter = {
    /**
     * The name of the parameter.
     */
    name: string;
    /**
     * The location of the parameter (e.g., query, header).
     */
    in: string;
    /**
     * The value of the parameter.
     */
    value: string | number;
};
export type CustomAuthData = {
    /**
     * The base URL for the custom authentication.
     */
    base_url?: string;
    /**
     * An array of parameters for the custom authentication.
     */
    parameters: Parameter[];
    /**
     * An optional object containing the body for the custom authentication.
     */
    body?: Record<string, unknown>;
};
export type ExecuteActionData = {
    /**
     * The name of the action to execute.
     */
    actionName: string;
    requestBody?: {
        /**
         * The unique identifier of the connection to use for executing the action.
         */
        connectedAccountId?: string;
        /**
         * An object containing the input parameters for the action. If you want to execute
         * NLP based action (i.e text), you can use text parameter instead of input.
         */
        input?: {
            [key: string]: unknown;
        };
        appName?: string;
        /**
         * The text to supply to the action which will be automatically converted to
         * appropriate input parameters.
         */
        text?: string;
        /**
         * The custom authentication configuration for executing the action.
         */
        authConfig?: CustomAuthData;
    };
};
export declare class Actions {
    backendClient: BackendClient;
    fileName: string;
    constructor(backendClient: BackendClient);
    /**
     * Retrieves details of a specific action in the Composio platform by providing its action name.
     *
     * The response includes the action's name, display name, description, input parameters, expected response, associated app information, and enabled status.
     *
     * @param {GetActionData} data The data for the request.
     * @returns {CancelablePromise<GetActionResponse[0]>} A promise that resolves to the details of the action.
     * @throws {ApiError} If the request fails.
     */
    get(data: {
        actionName: string;
    }): Promise<ActionDetails>;
    /**
     * Retrieves a list of all actions in the Composio platform.
     *
     * This method allows you to fetch a list of all the available actions. It supports pagination to handle large numbers of actions. The response includes an array of action objects, each containing information such as the action's name, display name, description, input parameters, expected response, associated app information, and enabled status.
     *
     * @param {GetListActionsData} data The data for the request.
     * @returns {Promise<ActionsListResponseDTO>} A promise that resolves to the list of all actions.
     * @throws {ApiError} If the request fails.
     */
    list(data?: GetListActionsData): Promise<ActionsListResponseDTO>;
    /**
     * Executes a specific action in the Composio platform.
     *
     * This method allows you to trigger the execution of an action by providing its name and the necessary input parameters. The request includes the connected account ID to identify the app connection to use for the action, and the input parameters required by the action. The response provides details about the execution status and the response data returned by the action.
     *
     * @param {ExecuteActionData} data The data for the request.
     * @returns {Promise<ActionExecutionResDto>} A promise that resolves to the execution status and response data.
     * @throws {ApiError} If the request fails.
     */
    execute(data: ExecuteActionData): Promise<ActionExecutionResDto>;
    findActionEnumsByUseCase(data: {
        apps: Array<string>;
        useCase: string;
        limit?: number;
        filterByAvailableApps?: boolean;
    }): Promise<Array<string>>;
    /**
     * Executes a action using Composio Proxy
     *
     * This method allows you to trigger the execution of an action by providing its name and the necessary input parameters. The request includes the connected account ID to identify the app connection to use for the action, and the input parameters required by the action. The response provides details about the execution status and the response data returned by the action.
     *
     * @param {ExecuteActionData} data The data for the request.
     * @returns {Promise<ActionExecutionResDto>} A promise that resolves to the execution status and response data.
     * @throws {ApiError} If the request fails.
     */
    executeRequest(data: ActionProxyRequestConfigDTO): Promise<ActionExecutionResDto>;
}

export type TriggerData = {
    appName: string;
    clientId: number;
    payload: {};
    originalPayload: Record<string, any>;
    metadata: {
        id: string;
        connectionId: string;
        triggerName: string;
        triggerData: string;
        triggerConfig: Record<string, any>;
        connection: {
            id: string;
            integrationId: string;
            clientUniqueUserId: string;
            status: string;
        };
    };
};

export type RequiredQuery = ListTriggersData["query"];
export declare class Triggers {
    trigger_to_client_event: string;
    backendClient: BackendClient;
    fileName: string;
    constructor(backendClient: BackendClient);
    /**
     * Retrieves a list of all triggers in the Composio platform.
     *
     * This method allows you to fetch a list of all the available triggers. It supports pagination to handle large numbers of triggers. The response includes an array of trigger objects, each containing information such as the trigger's name, description, input parameters, expected response, associated app information, and enabled status.
     *
     * @param {ListTriggersData} data The data for the request.
     * @returns {CancelablePromise<ListTriggersResponse>} A promise that resolves to the list of all triggers.
     * @throws {ApiError} If the request fails.
     */
    list(data?: RequiredQuery): Promise<ListTriggersResponse>;
    /**
     * Setup a trigger for a connected account.
     *
     * @param {SetupTriggerData} data The data for the request.
     * @returns {CancelablePromise<SetupTriggerResponse>} A promise that resolves to the setup trigger response.
     * @throws {ApiError} If the request fails.
     */
    setup({ connectedAccountId, triggerName, config, }: {
        connectedAccountId: string;
        triggerName: string;
        config: Record<string, any>;
    }): Promise<{
        status: string;
        triggerId: string;
    }>;
    enable(data: {
        triggerId: string;
    }): Promise<{
        status: string;
    }>;
    disable(data: {
        triggerId: string;
    }): Promise<{
        status: string;
    }>;
    delete(data: {
        triggerInstanceId: string;
    }): Promise<{
        status: string;
    }>;
    subscribe(fn: (data: TriggerData) => void, filters?: {
        appName?: string;
        triggerId?: string;
        connectionId?: string;
        integrationId?: string;
        triggerName?: string;
        triggerData?: string;
        entityId?: string;
    }): Promise<void>;
    unsubscribe(): Promise<void>;
}

export declare class ActiveTriggers {
    backendClient: BackendClient;
    fileName: string;
    constructor(backendClient: BackendClient);
    /**
     * Retrieves details of a specific active trigger in the Composio platform by providing its trigger name.
     *
     * The response includes the trigger's name, description, input parameters, expected response, associated app information, and enabled status.
     *
     * @param {GetActiveTriggerData} data The data for the request.
     * @returns {CancelablePromise<GetActiveTriggerResponse>} A promise that resolves to the details of the active trigger.
     * @throws {ApiError} If the request fails.
     */
    get({ triggerId }: {
        triggerId: string;
    }): Promise<{
        [key: string]: unknown;
    } | undefined>;
    /**
     * Retrieves a list of all active triggers in the Composio platform.
     *
     * This method allows you to fetch a list of all the available active triggers. It supports pagination to handle large numbers of triggers. The response includes an array of trigger objects, each containing information such as the trigger's name, description, input parameters, expected response, associated app information, and enabled status.
     *
     * @param {ListActiveTriggersData} data The data for the request.
     * @returns {CancelablePromise<ListActiveTriggersResponse>} A promise that resolves to the list of all active triggers.
     * @throws {ApiError} If the request fails.
     */
    list(data?: GetActiveTriggersData): Promise<{
        [key: string]: unknown;
    }[]>;
    /**
     * Enables the previously disabled trigger.
     *
     * @param {Object} data The data for the request.
     * @param {string} data.triggerId Id of the trigger
     * @returns {CancelablePromise<Record<string, any>>} A promise that resolves to the response of the enable request.
     * @throws {ApiError} If the request fails.
     */
    enable(data: {
        triggerId: string;
    }): Promise<boolean>;
    disable(data: {
        triggerId: string;
    }): Promise<boolean>;
}

export declare const ZExecuteActionParams$1: z.ZodObject<{
    actionName: z.ZodString;
    params: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
    text: z.ZodOptional<z.ZodString>;
    connectedAccountId: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    actionName: string;
    connectedAccountId?: string | undefined;
    text?: string | undefined;
    params?: Record<string, any> | undefined;
}, {
    actionName: string;
    connectedAccountId?: string | undefined;
    text?: string | undefined;
    params?: Record<string, any> | undefined;
}>;
export type TExecuteActionParams = z.infer<typeof ZExecuteActionParams$1>;
export declare const ZInitiateConnectionParams: z.ZodObject<{
    appName: z.ZodOptional<z.ZodString>;
    authConfig: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
    integrationId: z.ZodOptional<z.ZodString>;
    authMode: z.ZodOptional<z.ZodString>;
    connectionData: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
    config: z.ZodOptional<z.ZodObject<{
        labels: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        redirectUrl: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        labels?: string[] | undefined;
        redirectUrl?: string | undefined;
    }, {
        labels?: string[] | undefined;
        redirectUrl?: string | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    authConfig?: Record<string, any> | undefined;
    appName?: string | undefined;
    integrationId?: string | undefined;
    config?: {
        labels?: string[] | undefined;
        redirectUrl?: string | undefined;
    } | undefined;
    authMode?: string | undefined;
    connectionData?: Record<string, any> | undefined;
}, {
    authConfig?: Record<string, any> | undefined;
    appName?: string | undefined;
    integrationId?: string | undefined;
    config?: {
        labels?: string[] | undefined;
        redirectUrl?: string | undefined;
    } | undefined;
    authMode?: string | undefined;
    connectionData?: Record<string, any> | undefined;
}>;
export type TInitiateConnectionParams = z.infer<typeof ZInitiateConnectionParams>;
export declare class Entity {
    id: string;
    backendClient: BackendClient;
    triggerModel: Triggers;
    actionsModel: Actions;
    apps: Apps;
    connectedAccounts: ConnectedAccounts;
    integrations: Integrations;
    activeTriggers: ActiveTriggers;
    fileName: string;
    constructor(backendClient: BackendClient, id?: string);
    execute({ actionName, params, text, connectedAccountId, }: TExecuteActionParams): Promise<ActionExecutionResDto>;
    getConnection({ app, connectedAccountId, }: {
        app?: string;
        connectedAccountId?: string;
    }): Promise<any | null>;
    setupTrigger(app: string, triggerName: string, config: {
        [key: string]: any;
    }): Promise<{
        status: string;
        triggerId: string;
    }>;
    disableTrigger(triggerId: string): Promise<{
        status: string;
    }>;
    getConnections(): Promise<ConnectionParams[]>;
    getActiveTriggers(): Promise<{
        [key: string]: unknown;
    }[]>;
    initiateConnection(data: TInitiateConnectionParams): Promise<ConnectionRequest>;
}

export declare class Composio {
    /**
     * The Composio class serves as the main entry point for interacting with the Composio SDK.
     * It provides access to various models that allow for operations on connected accounts, apps,
     * actions, triggers, integrations, and active triggers.
     */
    backendClient: BackendClient;
    connectedAccounts: ConnectedAccounts;
    apps: Apps;
    actions: Actions;
    triggers: Triggers;
    integrations: Integrations;
    activeTriggers: ActiveTriggers;
    fileName: string;
    /**
     * Initializes a new instance of the Composio class.
     *
     * @param {Object} config - Configuration object for the Composio SDK
     * @param {string} [config.apiKey] - The API key for authenticating with the Composio backend. Can also be set locally in an environment variable.
     * @param {string} [config.baseUrl] - The base URL for the Composio backend. By default, it is set to the production URL.
     * @param {string} [config.runtime] - The runtime environment for the SDK.
     */
    constructor(config: {
        apiKey?: string;
        baseUrl?: string;
        runtime?: string;
    });
    /**
     * Checks for the latest version of the Composio SDK from NPM.
     * If a newer version is available, it logs a warning to the console.
     */
    checkForLatestVersionFromNPM(): Promise<void>;
    /**
     * Retrieves an Entity instance associated with a given ID.
     *
     * @param {string} [id='default'] - The ID of the entity to retrieve.
     * @returns {Entity} An instance of the Entity class.
     */
    getEntity(id?: string): Entity;
    getExpectedParamsForUser(params?: {
        app?: string;
        integrationId?: string;
        entityId?: string;
        authScheme?: "OAUTH2" | "OAUTH1" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "BASIC_WITH_JWT";
    }): Promise<{
        expectedInputFields: GetConnectorInfoResDTO["expectedInputFields"];
        integrationId: string;
        authScheme: "OAUTH2" | "OAUTH1" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "BASIC_WITH_JWT";
    }>;
}

type Optional$3<T> = T | null;
type Sequence$2<T> = Array<T>;

export type IPythonActionDetails = {
  data: {
    name: string;
    display_name: string;
    description: string;
    parameters: any;
    response: any;
    appKey: string;
    appId: string;
    tags: string[];
    appName: string;
    enabled: boolean;
    logo: string;
  }[];
  error: any | null;
  traceback: any | null;
};

export type IWorkspaceConfig = {
    composioAPIKey?: string | null;
    composioBaseURL?: string | null;
    githubAccessToken?: string | null;
    environment?: {
        [key: string]: string;
    };
};
export declare class WorkspaceConfig<TConfig extends IWorkspaceConfig = IWorkspaceConfig> {
    env: ExecEnv;
    config: TConfig;
    constructor(env: ExecEnv, config: TConfig);
}

export declare class Shell {
    private _id;
    constructor();
    sanitizeCommand(cmd: string): string;
    toString(): string;
    get id(): string;
    setup(): void;
    exec(cmd: string): void;
    stop(): void;
}
export declare class ShellFactory {
    private _factory;
    private _recent;
    private _shells;
    constructor(factory: () => Shell);
    get recent(): Shell;
    set recent(shell: Shell);
    new(): Shell;
    get(id?: string | null): Shell;
    exec(cmd: string, id?: string | null): void;
    stop(id: string): void;
    teardown(): void;
}
export type IExecuteActionMetadata = {
    entityId?: string | null;
};
export declare class Workspace$1 {
    id: string;
    accessToken: string;
    composioAPIKey: string;
    composioBaseURL: string;
    githubAccessToken: string;
    environment: {
        [key: string]: string;
    };
    private _shell_factory;
    constructor(configRepo: WorkspaceConfig<IWorkspaceConfig>);
    toString(): string;
    setup(): void;
    get shells(): ShellFactory;
    _createShell(): Shell;
    executeAction(action: any, request_data: any, metadata?: IExecuteActionMetadata): Promise<Record<string, any>>;
    teardown(): void;
}

declare enum ExecEnv {
    HOST = "HOST",
    DOCKER = "DOCKER",
    E2B = "E2B"
}
export declare class WorkspaceFactory {
    workspace: Workspace$1 | null;
    id: string | null;
    env: ExecEnv;
    workspaceConfig: WorkspaceConfig;
    constructor(env: ExecEnv, kwargs: WorkspaceConfig);
    new(): Promise<void>;
    get(id?: string | null): Promise<Workspace$1>;
    close(): Promise<void>;
}

export type ExecuteRequest = Omit<ActionProxyRequestConfigDTO, "connectedAccountId">;
export type CreateActionOptions = {
    actionName?: string;
    toolName?: string;
    description?: string;
    inputParams: ZodObject<{
        [key: string]: ZodString | ZodOptional<ZodString>;
    }>;
    callback: (inputParams: Record<string, any>, authCredentials: Record<string, any> | undefined, executeRequest: (data: ExecuteRequest) => Promise<any>) => Promise<Record<string, any>>;
};
interface ExecuteMetadata {
    entityId?: string;
    connectionId?: string;
}
export declare class ActionRegistry {
    client: Composio;
    customActions: Map<string, {
        metadata: CreateActionOptions;
        schema: any;
    }>;
    constructor(client: Composio);
    createAction(options: CreateActionOptions): Promise<Record<string, any>>;
    getActions({ actions, }: {
        actions: Array<string>;
    }): Promise<Array<any>>;
    getAllActions(): Promise<Array<any>>;
    executeAction(name: string, inputParams: Record<string, any>, metadata: ExecuteMetadata): Promise<any>;
}

export type GetListActionsResponse = {
    items: any[];
};
export declare const ZExecuteActionParams: z.ZodObject<{
    action: z.ZodString;
    params: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
    entityId: z.ZodString;
    nlaText: z.ZodOptional<z.ZodString>;
    connectedAccountId: z.ZodOptional<z.ZodString>;
    config: z.ZodOptional<z.ZodObject<{
        labels: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    }, "strip", z.ZodTypeAny, {
        labels?: string[] | undefined;
    }, {
        labels?: string[] | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    entityId: string;
    action: string;
    connectedAccountId?: string | undefined;
    config?: {
        labels?: string[] | undefined;
    } | undefined;
    params?: Record<string, any> | undefined;
    nlaText?: string | undefined;
}, {
    entityId: string;
    action: string;
    connectedAccountId?: string | undefined;
    config?: {
        labels?: string[] | undefined;
    } | undefined;
    params?: Record<string, any> | undefined;
    nlaText?: string | undefined;
}>;
export type TPreProcessor = ({ action, toolRequest, }: {
    action: string;
    toolRequest: Record<string, unknown>;
}) => Record<string, unknown>;
export type TPostProcessor = ({ action, toolResponse, }: {
    action: string;
    toolResponse: ActionExecutionResDto;
}) => ActionExecutionResDto;
export declare class ComposioToolSet {
    client: Composio;
    apiKey: string;
    runtime: string | null;
    entityId: string;
    workspace: WorkspaceFactory;
    workspaceEnv: ExecEnv;
    localActions: IPythonActionDetails["data"] | undefined;
    customActionRegistry: ActionRegistry;
    private processors;
    constructor(apiKey: string | null, baseUrl?: string | null, runtime?: string | null, entityId?: string, workspaceConfig?: WorkspaceConfig);
    /**
     * @deprecated This method is deprecated. Please use this.client.getExpectedParamsForUser instead.
     */
    getExpectedParamsForUser(params?: {
        app?: string;
        integrationId?: string;
        entityId?: string;
        authScheme?: "OAUTH2" | "OAUTH1" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "BASIC_WITH_JWT";
    }): Promise<{
        expectedInputFields: ExpectedInputFieldsDTO[];
        integrationId: string;
        authScheme: "OAUTH2" | "OAUTH1" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "BASIC_WITH_JWT";
    }>;
    setup(): Promise<void>;
    getActionsSchema(filters?: {
        actions?: Optional$3<Sequence$2<string>>;
    }, entityId?: Optional$3<string>): Promise<Sequence$2<NonNullable<GetListActionsResponse["items"]>[0]>>;
    /**
     * @deprecated This method is deprecated. Please use this.client.connectedAccounts.getAuthParams instead.
     */
    getAuthParams(data: {
        connectedAccountId: string;
    }): Promise<ConnectedAccountResponseDTO | undefined>;
    getTools(filters: {
        apps: Sequence$2<string>;
        tags?: Optional$3<Array<string>>;
        useCase?: Optional$3<string>;
    }, entityId?: Optional$3<string>): Promise<unknown>;
    getToolsSchema(filters: {
        actions?: Optional$3<Array<string>>;
        apps?: Array<string>;
        tags?: Optional$3<Array<string>>;
        useCase?: Optional$3<string>;
        useCaseLimit?: Optional$3<number>;
        filterByAvailableApps?: Optional$3<boolean>;
    }, entityId?: Optional$3<string>): Promise<Sequence$2<NonNullable<GetListActionsResponse["items"]>[0]>>;
    modifyActionForLocalExecution(toolSchema: any): any;
    createAction(options: CreateActionOptions): Promise<Record<string, any>>;
    private isCustomAction;
    executeAction(functionParams: z.infer<typeof ZExecuteActionParams>): Promise<any>;
    private processResponse;
    addPreProcessor(processor: TPreProcessor): Promise<void>;
    addPostProcessor(processor: TPostProcessor): Promise<void>;
    removePreProcessor(): Promise<void>;
    removePostProcessor(): Promise<void>;
}

export declare class LangchainToolSet extends ComposioToolSet {
    /**
     * Composio toolset for Langchain framework.
     *
     */
    static FRAMEWORK_NAME: string;
    static DEFAULT_ENTITY_ID: string;
    fileName: string;
    constructor(config?: {
        apiKey?: Optional$3<string>;
        baseUrl?: Optional$3<string>;
        entityId?: string;
        workspaceConfig?: WorkspaceConfig;
        runtime?: string;
    });
    private _wrapTool;
    getTools(filters: {
        actions?: Optional$3<Array<string>>;
        apps?: Sequence$2<string>;
        tags?: Optional$3<Array<string>>;
        useCase?: Optional$3<string>;
        usecaseLimit?: Optional$3<number>;
        filterByAvailableApps?: Optional$3<boolean>;
    }, entityId?: Optional$3<string>): Promise<Sequence$2<DynamicStructuredTool>>;
}

type Optional$2<T> = T | null;
type Sequence$1<T> = Array<T>;
export declare class OpenAIToolSet extends ComposioToolSet {
    static FRAMEWORK_NAME: string;
    static DEFAULT_ENTITY_ID: string;
    fileName: string;
    /**
     * Composio toolset for OpenAI framework.
     *
     * Example:
     * ```typescript
     *
     * ```
     */
    constructor(config?: {
        apiKey?: Optional$2<string>;
        baseUrl?: Optional$2<string>;
        entityId?: string;
        workspaceConfig?: WorkspaceConfig;
    });
    getTools(filters: {
        actions?: Sequence$1<string>;
        apps?: Sequence$1<string>;
        tags?: Optional$2<Array<string>>;
        useCase?: Optional$2<string>;
        useCaseLimit?: Optional$2<number>;
        filterByAvailableApps?: Optional$2<boolean>;
    }, entityId?: Optional$2<string>): Promise<Sequence$1<OpenAI.ChatCompletionTool>>;
    executeToolCall(tool: OpenAI.ChatCompletionMessageToolCall, entityId?: Optional$2<string>): Promise<string>;
    handleToolCall(chatCompletion: OpenAI.ChatCompletion, entityId?: Optional$2<string>): Promise<Sequence$1<string>>;
    handleAssistantMessage(run: OpenAI.Beta.Threads.Run, entityId?: Optional$2<string>): Promise<Array<OpenAI.Beta.Threads.Runs.RunSubmitToolOutputsParams.ToolOutput>>;
    waitAndHandleAssistantStreamToolCalls(client: OpenAI, runStream: Stream<OpenAI.Beta.Assistants.AssistantStreamEvent>, thread: OpenAI.Beta.Threads.Thread, entityId?: string | null): AsyncGenerator<any, void, unknown>;
    waitAndHandleAssistantToolCalls(client: OpenAI, run: OpenAI.Beta.Threads.Run, thread: OpenAI.Beta.Threads.Thread, entityId?: Optional$2<string>): Promise<OpenAI.Beta.Threads.Run>;
}

type Optional$1<T> = T | null;
type Sequence<T> = Array<T>;
/**
 * CloudflareToolSet provides integration with Cloudflare Workers AI
 * for executing AI tool calls and handling responses
 */
export declare class CloudflareToolSet extends ComposioToolSet {
    static FRAMEWORK_NAME: string;
    static DEFAULT_ENTITY_ID: string;
    fileName: string;
    /**
     * Initialize a new CloudflareToolSet instance
     *
     * @param config Configuration options including API key, base URL, entity ID and workspace config
     */
    constructor(config?: {
        apiKey?: Optional$1<string>;
        baseUrl?: Optional$1<string>;
        entityId?: string;
        workspaceConfig?: WorkspaceConfig;
    });
    /**
     * Retrieve available tools based on provided filters
     *
     * @param filters Optional filters for actions, apps, tags and use cases
     * @returns Promise resolving to array of AI text generation tools
     */
    getTools(filters: {
        actions?: Optional$1<Sequence<string>>;
        apps?: Sequence<string>;
        tags?: Optional$1<Array<string>>;
        useCase?: Optional$1<string>;
        usecaseLimit?: Optional$1<number>;
        filterByAvailableApps?: Optional$1<boolean>;
    }): Promise<Sequence<AiTextGenerationToolInput>>;
    /**
     * Execute a single tool call
     *
     * @param tool The tool to execute with name and arguments
     * @param entityId Optional entity ID to execute the tool for
     * @returns Promise resolving to stringified tool execution result
     */
    executeToolCall(tool: {
        name: string;
        arguments: unknown;
    }, entityId?: Optional$1<string>): Promise<string>;
    /**
     * Handle tool calls from AI text generation output
     *
     * @param result The AI text generation output containing tool calls
     * @param entityId Optional entity ID to execute the tools for
     * @returns Promise resolving to array of tool execution results
     */
    handleToolCall(result: AiTextGenerationOutput, entityId?: Optional$1<string>): Promise<Sequence<string>>;
}

type Optional<T> = T | null;
export declare class VercelAIToolSet extends ComposioToolSet {
    fileName: string;
    constructor(config?: {
        apiKey?: Optional<string>;
        baseUrl?: Optional<string>;
        entityId?: string;
    });
    private generateVercelTool;
    getTools(filters: {
        actions?: Array<string>;
        apps?: Array<string>;
        tags?: Optional<Array<string>>;
        useCase?: Optional<string>;
        usecaseLimit?: Optional<number>;
        filterByAvailableApps?: Optional<boolean>;
    }): Promise<{
        [key: string]: any;
    }>;
    executeToolCall(tool: {
        name: string;
        arguments: unknown;
    }, entityId?: Optional<string>): Promise<string>;
}

export declare class LangGraphToolSet extends LangchainToolSet {
    /**
     * Composio toolset for Langgraph framework.
     *
     */
    static FRAMEWORK_NAME: string;
    static DEFAULT_ENTITY_ID: string;
    constructor(config?: {
        apiKey?: Optional$3<string>;
        baseUrl?: Optional$3<string>;
        entityId?: string;
        workspaceConfig?: WorkspaceConfig;
    });
}

export type IDockerConfig = IWorkspaceConfig & {
    /** Name of the docker image. */
    image?: string;
    /**
     * Ports to bind inside the container
     *
     * Note: port 8000 is reserved for the tooling server inside the container
     */
    ports?: {
        [key: number]: any;
    };
    /** Volumes to bind inside the container */
    volumes?: {
        [key: string]: any;
    };
};

export type IE2BConfig = IWorkspaceConfig & {
    template?: string;
    apiKey?: string;
    port?: number;
};

export declare class Workspace {
    static Docker(config?: IDockerConfig): WorkspaceConfig<IDockerConfig>;
    static E2B(config?: IE2BConfig): WorkspaceConfig<IE2BConfig>;
    static Host(): WorkspaceConfig<{}>;
}

export declare const APPS: any;
export declare const ACTIONS: any;

export { ACTIONS, APPS, CloudflareToolSet, Composio, ConnectionRequest, LangGraphToolSet, LangchainToolSet, OpenAIToolSet, VercelAIToolSet, Workspace };
